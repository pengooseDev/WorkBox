/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/@ffmpeg/ffmpeg/src/browser/defaultOptions.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@ffmpeg/ffmpeg/src/browser/defaultOptions.js ***!
  \*******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var resolveURL = __webpack_require__(/*! resolve-url */ \"./node_modules/resolve-url/resolve-url.js\");\n\nvar _require = __webpack_require__(/*! ../../package.json */ \"./node_modules/@ffmpeg/ffmpeg/package.json\"),\n    devDependencies = _require.devDependencies;\n/*\n * Default options for browser environment\n */\n\n\nmodule.exports = {\n  corePath:  true ? resolveURL('/node_modules/@ffmpeg/core/dist/ffmpeg-core.js') : 0\n};\n\n//# sourceURL=webpack://WorkBox/./node_modules/@ffmpeg/ffmpeg/src/browser/defaultOptions.js?");

/***/ }),

/***/ "./node_modules/@ffmpeg/ffmpeg/src/browser/fetchFile.js":
/*!**************************************************************!*\
  !*** ./node_modules/@ffmpeg/ffmpeg/src/browser/fetchFile.js ***!
  \**************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }\n\nfunction _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err); } _next(undefined); }); }; }\n\nvar resolveURL = __webpack_require__(/*! resolve-url */ \"./node_modules/resolve-url/resolve-url.js\");\n\nvar readFromBlobOrFile = function readFromBlobOrFile(blob) {\n  return new Promise(function (resolve, reject) {\n    var fileReader = new FileReader();\n\n    fileReader.onload = function () {\n      resolve(fileReader.result);\n    };\n\n    fileReader.onerror = function (_ref) {\n      var code = _ref.target.error.code;\n      reject(Error(\"File could not be read! Code=\".concat(code)));\n    };\n\n    fileReader.readAsArrayBuffer(blob);\n  });\n};\n\nmodule.exports = /*#__PURE__*/function () {\n  var _ref2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(_data) {\n    var data, res;\n    return regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            data = _data;\n\n            if (!(typeof _data === 'undefined')) {\n              _context.next = 3;\n              break;\n            }\n\n            return _context.abrupt(\"return\", new Uint8Array());\n\n          case 3:\n            if (!(typeof _data === 'string')) {\n              _context.next = 16;\n              break;\n            }\n\n            if (!/data:_data\\/([a-zA-Z]*);base64,([^\"]*)/.test(_data)) {\n              _context.next = 8;\n              break;\n            }\n\n            data = atob(_data.split(',')[1]).split('').map(function (c) {\n              return c.charCodeAt(0);\n            });\n            /* From remote server/URL */\n\n            _context.next = 14;\n            break;\n\n          case 8:\n            _context.next = 10;\n            return fetch(resolveURL(_data));\n\n          case 10:\n            res = _context.sent;\n            _context.next = 13;\n            return res.arrayBuffer();\n\n          case 13:\n            data = _context.sent;\n\n          case 14:\n            _context.next = 20;\n            break;\n\n          case 16:\n            if (!(_data instanceof File || _data instanceof Blob)) {\n              _context.next = 20;\n              break;\n            }\n\n            _context.next = 19;\n            return readFromBlobOrFile(_data);\n\n          case 19:\n            data = _context.sent;\n\n          case 20:\n            return _context.abrupt(\"return\", new Uint8Array(data));\n\n          case 21:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  }));\n\n  return function (_x) {\n    return _ref2.apply(this, arguments);\n  };\n}();\n\n//# sourceURL=webpack://WorkBox/./node_modules/@ffmpeg/ffmpeg/src/browser/fetchFile.js?");

/***/ }),

/***/ "./node_modules/@ffmpeg/ffmpeg/src/browser/getCreateFFmpegCore.js":
/*!************************************************************************!*\
  !*** ./node_modules/@ffmpeg/ffmpeg/src/browser/getCreateFFmpegCore.js ***!
  \************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }\n\nfunction _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err); } _next(undefined); }); }; }\n\n/* eslint-disable no-undef */\nvar resolveURL = __webpack_require__(/*! resolve-url */ \"./node_modules/resolve-url/resolve-url.js\");\n\nvar _require = __webpack_require__(/*! ../utils/log */ \"./node_modules/@ffmpeg/ffmpeg/src/utils/log.js\"),\n    log = _require.log;\n/*\n * Fetch data from remote URL and convert to blob URL\n * to avoid CORS issue\n */\n\n\nvar toBlobURL = /*#__PURE__*/function () {\n  var _ref = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(url, mimeType) {\n    var buf, blob, blobURL;\n    return regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            log('info', \"fetch \".concat(url));\n            _context.next = 3;\n            return fetch(url);\n\n          case 3:\n            _context.next = 5;\n            return _context.sent.arrayBuffer();\n\n          case 5:\n            buf = _context.sent;\n            log('info', \"\".concat(url, \" file size = \").concat(buf.byteLength, \" bytes\"));\n            blob = new Blob([buf], {\n              type: mimeType\n            });\n            blobURL = URL.createObjectURL(blob);\n            log('info', \"\".concat(url, \" blob URL = \").concat(blobURL));\n            return _context.abrupt(\"return\", blobURL);\n\n          case 11:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  }));\n\n  return function toBlobURL(_x, _x2) {\n    return _ref.apply(this, arguments);\n  };\n}();\n\nmodule.exports = /*#__PURE__*/function () {\n  var _ref3 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(_ref2) {\n    var _corePath, coreRemotePath, corePath, wasmPath, workerPath;\n\n    return regeneratorRuntime.wrap(function _callee2$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            _corePath = _ref2.corePath;\n\n            if (!(typeof _corePath !== 'string')) {\n              _context2.next = 3;\n              break;\n            }\n\n            throw Error('corePath should be a string!');\n\n          case 3:\n            coreRemotePath = resolveURL(_corePath);\n            _context2.next = 6;\n            return toBlobURL(coreRemotePath, 'application/javascript');\n\n          case 6:\n            corePath = _context2.sent;\n            _context2.next = 9;\n            return toBlobURL(coreRemotePath.replace('ffmpeg-core.js', 'ffmpeg-core.wasm'), 'application/wasm');\n\n          case 9:\n            wasmPath = _context2.sent;\n            _context2.next = 12;\n            return toBlobURL(coreRemotePath.replace('ffmpeg-core.js', 'ffmpeg-core.worker.js'), 'application/javascript');\n\n          case 12:\n            workerPath = _context2.sent;\n\n            if (!(typeof createFFmpegCore === 'undefined')) {\n              _context2.next = 15;\n              break;\n            }\n\n            return _context2.abrupt(\"return\", new Promise(function (resolve) {\n              var script = document.createElement('script');\n\n              var eventHandler = function eventHandler() {\n                script.removeEventListener('load', eventHandler);\n                log('info', 'ffmpeg-core.js script loaded');\n                resolve({\n                  createFFmpegCore: createFFmpegCore,\n                  corePath: corePath,\n                  wasmPath: wasmPath,\n                  workerPath: workerPath\n                });\n              };\n\n              script.src = corePath;\n              script.type = 'text/javascript';\n              script.addEventListener('load', eventHandler);\n              document.getElementsByTagName('head')[0].appendChild(script);\n            }));\n\n          case 15:\n            log('info', 'ffmpeg-core.js script is loaded already');\n            return _context2.abrupt(\"return\", Promise.resolve({\n              createFFmpegCore: createFFmpegCore,\n              corePath: corePath,\n              wasmPath: wasmPath,\n              workerPath: workerPath\n            }));\n\n          case 17:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, _callee2);\n  }));\n\n  return function (_x3) {\n    return _ref3.apply(this, arguments);\n  };\n}();\n\n//# sourceURL=webpack://WorkBox/./node_modules/@ffmpeg/ffmpeg/src/browser/getCreateFFmpegCore.js?");

/***/ }),

/***/ "./node_modules/@ffmpeg/ffmpeg/src/browser/index.js":
/*!**********************************************************!*\
  !*** ./node_modules/@ffmpeg/ffmpeg/src/browser/index.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var defaultOptions = __webpack_require__(/*! ./defaultOptions */ \"./node_modules/@ffmpeg/ffmpeg/src/browser/defaultOptions.js\");\n\nvar getCreateFFmpegCore = __webpack_require__(/*! ./getCreateFFmpegCore */ \"./node_modules/@ffmpeg/ffmpeg/src/browser/getCreateFFmpegCore.js\");\n\nvar fetchFile = __webpack_require__(/*! ./fetchFile */ \"./node_modules/@ffmpeg/ffmpeg/src/browser/fetchFile.js\");\n\nmodule.exports = {\n  defaultOptions: defaultOptions,\n  getCreateFFmpegCore: getCreateFFmpegCore,\n  fetchFile: fetchFile\n};\n\n//# sourceURL=webpack://WorkBox/./node_modules/@ffmpeg/ffmpeg/src/browser/index.js?");

/***/ }),

/***/ "./node_modules/@ffmpeg/ffmpeg/src/config.js":
/*!***************************************************!*\
  !*** ./node_modules/@ffmpeg/ffmpeg/src/config.js ***!
  \***************************************************/
/***/ ((module) => {

eval("module.exports = {\n  defaultArgs: [\n  /* args[0] is always the binary path */\n  './ffmpeg',\n  /* Disable interaction mode */\n  '-nostdin',\n  /* Force to override output file */\n  '-y'],\n  baseOptions: {\n    /* Flag to turn on/off log messages in console */\n    log: false,\n\n    /*\n     * Custom logger to get ffmpeg.wasm output messages.\n     * a sample logger looks like this:\n     *\n     * ```\n     * logger = ({ type, message }) => {\n     *   console.log(type, message);\n     * }\n     * ```\n     *\n     * type can be one of following:\n     *\n     * info: internal workflow debug messages\n     * fferr: ffmpeg native stderr output\n     * ffout: ffmpeg native stdout output\n     */\n    logger: function logger() {},\n\n    /*\n     * Progress handler to get current progress of ffmpeg command.\n     * a sample progress handler looks like this:\n     *\n     * ```\n     * progress = ({ ratio }) => {\n     *   console.log(ratio);\n     * }\n     * ```\n     *\n     * ratio is a float number between 0 to 1.\n     */\n    progress: function progress() {},\n\n    /*\n     * Path to find/download ffmpeg.wasm-core,\n     * this value should be overwriten by `defaultOptions` in\n     * each environment.\n     */\n    corePath: ''\n  }\n};\n\n//# sourceURL=webpack://WorkBox/./node_modules/@ffmpeg/ffmpeg/src/config.js?");

/***/ }),

/***/ "./node_modules/@ffmpeg/ffmpeg/src/createFFmpeg.js":
/*!*********************************************************!*\
  !*** ./node_modules/@ffmpeg/ffmpeg/src/createFFmpeg.js ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var _excluded = [\"log\", \"logger\", \"progress\"];\n\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }\n\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _iterableToArray(iter) { if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter); }\n\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }\n\nfunction _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err); } _next(undefined); }); }; }\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\nvar _require = __webpack_require__(/*! ./config */ \"./node_modules/@ffmpeg/ffmpeg/src/config.js\"),\n    defaultArgs = _require.defaultArgs,\n    baseOptions = _require.baseOptions;\n\nvar _require2 = __webpack_require__(/*! ./utils/log */ \"./node_modules/@ffmpeg/ffmpeg/src/utils/log.js\"),\n    setLogging = _require2.setLogging,\n    setCustomLogger = _require2.setCustomLogger,\n    log = _require2.log;\n\nvar parseProgress = __webpack_require__(/*! ./utils/parseProgress */ \"./node_modules/@ffmpeg/ffmpeg/src/utils/parseProgress.js\");\n\nvar parseArgs = __webpack_require__(/*! ./utils/parseArgs */ \"./node_modules/@ffmpeg/ffmpeg/src/utils/parseArgs.js\");\n\nvar _require3 = __webpack_require__(/*! ./node */ \"./node_modules/@ffmpeg/ffmpeg/src/browser/index.js\"),\n    defaultOptions = _require3.defaultOptions,\n    getCreateFFmpegCore = _require3.getCreateFFmpegCore;\n\nvar _require4 = __webpack_require__(/*! ../package.json */ \"./node_modules/@ffmpeg/ffmpeg/package.json\"),\n    version = _require4.version;\n\nvar NO_LOAD = Error('ffmpeg.wasm is not ready, make sure you have completed load().');\n\nmodule.exports = function () {\n  var _options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n  var _baseOptions$defaultO = _objectSpread(_objectSpread(_objectSpread({}, baseOptions), defaultOptions), _options),\n      logging = _baseOptions$defaultO.log,\n      logger = _baseOptions$defaultO.logger,\n      optProgress = _baseOptions$defaultO.progress,\n      options = _objectWithoutProperties(_baseOptions$defaultO, _excluded);\n\n  var Core = null;\n  var ffmpeg = null;\n  var runResolve = null;\n  var running = false;\n  var progress = optProgress;\n\n  var detectCompletion = function detectCompletion(message) {\n    if (message === 'FFMPEG_END' && runResolve !== null) {\n      runResolve();\n      runResolve = null;\n      running = false;\n    }\n  };\n\n  var parseMessage = function parseMessage(_ref) {\n    var type = _ref.type,\n        message = _ref.message;\n    log(type, message);\n    parseProgress(message, progress);\n    detectCompletion(message);\n  };\n  /*\n   * Load ffmpeg.wasm-core script.\n   * In browser environment, the ffmpeg.wasm-core script is fetch from\n   * CDN and can be assign to a local path by assigning `corePath`.\n   * In node environment, we use dynamic require and the default `corePath`\n   * is `$ffmpeg/core`.\n   *\n   * Typically the load() func might take few seconds to minutes to complete,\n   * better to do it as early as possible.\n   *\n   */\n\n\n  var load = /*#__PURE__*/function () {\n    var _ref2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {\n      var _yield$getCreateFFmpe, createFFmpegCore, corePath, workerPath, wasmPath;\n\n      return regeneratorRuntime.wrap(function _callee$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              log('info', 'load ffmpeg-core');\n\n              if (!(Core === null)) {\n                _context.next = 17;\n                break;\n              }\n\n              log('info', 'loading ffmpeg-core');\n              /*\n               * In node environment, all paths are undefined as there\n               * is no need to set them.\n               */\n\n              _context.next = 5;\n              return getCreateFFmpegCore(options);\n\n            case 5:\n              _yield$getCreateFFmpe = _context.sent;\n              createFFmpegCore = _yield$getCreateFFmpe.createFFmpegCore;\n              corePath = _yield$getCreateFFmpe.corePath;\n              workerPath = _yield$getCreateFFmpe.workerPath;\n              wasmPath = _yield$getCreateFFmpe.wasmPath;\n              _context.next = 12;\n              return createFFmpegCore({\n                /*\n                 * Assign mainScriptUrlOrBlob fixes chrome extension web worker issue\n                 * as there is no document.currentScript in the context of content_scripts\n                 */\n                mainScriptUrlOrBlob: corePath,\n                printErr: function printErr(message) {\n                  return parseMessage({\n                    type: 'fferr',\n                    message: message\n                  });\n                },\n                print: function print(message) {\n                  return parseMessage({\n                    type: 'ffout',\n                    message: message\n                  });\n                },\n\n                /*\n                 * locateFile overrides paths of files that is loaded by main script (ffmpeg-core.js).\n                 * It is critical for browser environment and we override both wasm and worker paths\n                 * as we are using blob URL instead of original URL to avoid cross origin issues.\n                 */\n                locateFile: function locateFile(path, prefix) {\n                  if (typeof window !== 'undefined') {\n                    if (typeof wasmPath !== 'undefined' && path.endsWith('ffmpeg-core.wasm')) {\n                      return wasmPath;\n                    }\n\n                    if (typeof workerPath !== 'undefined' && path.endsWith('ffmpeg-core.worker.js')) {\n                      return workerPath;\n                    }\n                  }\n\n                  return prefix + path;\n                }\n              });\n\n            case 12:\n              Core = _context.sent;\n              ffmpeg = Core.cwrap('proxy_main', 'number', ['number', 'number']);\n              log('info', 'ffmpeg-core loaded');\n              _context.next = 18;\n              break;\n\n            case 17:\n              throw Error('ffmpeg.wasm was loaded, you should not load it again, use ffmpeg.isLoaded() to check next time.');\n\n            case 18:\n            case \"end\":\n              return _context.stop();\n          }\n        }\n      }, _callee);\n    }));\n\n    return function load() {\n      return _ref2.apply(this, arguments);\n    };\n  }();\n  /*\n   * Determine whether the Core is loaded.\n   */\n\n\n  var isLoaded = function isLoaded() {\n    return Core !== null;\n  };\n  /*\n   * Run ffmpeg command.\n   * This is the major function in ffmpeg.wasm, you can just imagine it\n   * as ffmpeg native cli and what you need to pass is the same.\n   *\n   * For example, you can convert native command below:\n   *\n   * ```\n   * $ ffmpeg -i video.avi -c:v libx264 video.mp4\n   * ```\n   *\n   * To\n   *\n   * ```\n   * await ffmpeg.run('-i', 'video.avi', '-c:v', 'libx264', 'video.mp4');\n   * ```\n   *\n   */\n\n\n  var run = function run() {\n    for (var _len = arguments.length, _args = new Array(_len), _key = 0; _key < _len; _key++) {\n      _args[_key] = arguments[_key];\n    }\n\n    log('info', \"run ffmpeg command: \".concat(_args.join(' ')));\n\n    if (Core === null) {\n      throw NO_LOAD;\n    } else if (running) {\n      throw Error('ffmpeg.wasm can only run one command at a time');\n    } else {\n      running = true;\n      return new Promise(function (resolve) {\n        var args = [].concat(_toConsumableArray(defaultArgs), _args).filter(function (s) {\n          return s.length !== 0;\n        });\n        runResolve = resolve;\n        ffmpeg.apply(void 0, _toConsumableArray(parseArgs(Core, args)));\n      });\n    }\n  };\n  /*\n   * Run FS operations.\n   * For input/output file of ffmpeg.wasm, it is required to save them to MEMFS\n   * first so that ffmpeg.wasm is able to consume them. Here we rely on the FS\n   * methods provided by Emscripten.\n   *\n   * Common methods to use are:\n   * ffmpeg.FS('writeFile', 'video.avi', new Uint8Array(...)): writeFile writes\n   * data to MEMFS. You need to use Uint8Array for binary data.\n   * ffmpeg.FS('readFile', 'video.mp4'): readFile from MEMFS.\n   * ffmpeg.FS('unlink', 'video.map'): delete file from MEMFS.\n   *\n   * For more info, check https://emscripten.org/docs/api_reference/Filesystem-API.html\n   *\n   */\n\n\n  var FS = function FS(method) {\n    for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n      args[_key2 - 1] = arguments[_key2];\n    }\n\n    log('info', \"run FS.\".concat(method, \" \").concat(args.map(function (arg) {\n      return typeof arg === 'string' ? arg : \"<\".concat(arg.length, \" bytes binary file>\");\n    }).join(' ')));\n\n    if (Core === null) {\n      throw NO_LOAD;\n    } else {\n      var ret = null;\n\n      try {\n        var _Core$FS;\n\n        ret = (_Core$FS = Core.FS)[method].apply(_Core$FS, args);\n      } catch (e) {\n        if (method === 'readdir') {\n          throw Error(\"ffmpeg.FS('readdir', '\".concat(args[0], \"') error. Check if the path exists, ex: ffmpeg.FS('readdir', '/')\"));\n        } else if (method === 'readFile') {\n          throw Error(\"ffmpeg.FS('readFile', '\".concat(args[0], \"') error. Check if the path exists\"));\n        } else {\n          throw Error('Oops, something went wrong in FS operation.');\n        }\n      }\n\n      return ret;\n    }\n  };\n  /**\n   * forcibly terminate the ffmpeg program.\n   */\n\n\n  var exit = function exit() {\n    if (Core === null) {\n      throw NO_LOAD;\n    } else {\n      running = false;\n      Core.exit(1);\n      Core = null;\n      ffmpeg = null;\n      runResolve = null;\n    }\n  };\n\n  var setProgress = function setProgress(_progress) {\n    progress = _progress;\n  };\n\n  var setLogger = function setLogger(_logger) {\n    setCustomLogger(_logger);\n  };\n\n  setLogging(logging);\n  setCustomLogger(logger);\n  log('info', \"use ffmpeg.wasm v\".concat(version));\n  return {\n    setProgress: setProgress,\n    setLogger: setLogger,\n    setLogging: setLogging,\n    load: load,\n    isLoaded: isLoaded,\n    run: run,\n    exit: exit,\n    FS: FS\n  };\n};\n\n//# sourceURL=webpack://WorkBox/./node_modules/@ffmpeg/ffmpeg/src/createFFmpeg.js?");

/***/ }),

/***/ "./node_modules/@ffmpeg/ffmpeg/src/index.js":
/*!**************************************************!*\
  !*** ./node_modules/@ffmpeg/ffmpeg/src/index.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("__webpack_require__(/*! regenerator-runtime/runtime */ \"./node_modules/regenerator-runtime/runtime.js\");\n\nvar createFFmpeg = __webpack_require__(/*! ./createFFmpeg */ \"./node_modules/@ffmpeg/ffmpeg/src/createFFmpeg.js\");\n\nvar _require = __webpack_require__(/*! ./node */ \"./node_modules/@ffmpeg/ffmpeg/src/browser/index.js\"),\n    fetchFile = _require.fetchFile;\n\nmodule.exports = {\n  /*\n   * Create ffmpeg instance.\n   * Each ffmpeg instance owns an isolated MEMFS and works\n   * independently.\n   *\n   * For example:\n   *\n   * ```\n   * const ffmpeg = createFFmpeg({\n   *  log: true,\n   *  logger: () => {},\n   *  progress: () => {},\n   *  corePath: '',\n   * })\n   * ```\n   *\n   * For the usage of these four arguments, check config.js\n   *\n   */\n  createFFmpeg: createFFmpeg,\n\n  /*\n   * Helper function for fetching files from various resource.\n   * Sometimes the video/audio file you want to process may located\n   * in a remote URL and somewhere in your local file system.\n   *\n   * This helper function helps you to fetch to file and return an\n   * Uint8Array variable for ffmpeg.wasm to consume.\n   *\n   */\n  fetchFile: fetchFile\n};\n\n//# sourceURL=webpack://WorkBox/./node_modules/@ffmpeg/ffmpeg/src/index.js?");

/***/ }),

/***/ "./node_modules/@ffmpeg/ffmpeg/src/utils/log.js":
/*!******************************************************!*\
  !*** ./node_modules/@ffmpeg/ffmpeg/src/utils/log.js ***!
  \******************************************************/
/***/ ((module) => {

eval("var logging = false;\n\nvar customLogger = function customLogger() {};\n\nvar setLogging = function setLogging(_logging) {\n  logging = _logging;\n};\n\nvar setCustomLogger = function setCustomLogger(logger) {\n  customLogger = logger;\n};\n\nvar log = function log(type, message) {\n  customLogger({\n    type: type,\n    message: message\n  });\n\n  if (logging) {\n    console.log(\"[\".concat(type, \"] \").concat(message));\n  }\n};\n\nmodule.exports = {\n  logging: logging,\n  setLogging: setLogging,\n  setCustomLogger: setCustomLogger,\n  log: log\n};\n\n//# sourceURL=webpack://WorkBox/./node_modules/@ffmpeg/ffmpeg/src/utils/log.js?");

/***/ }),

/***/ "./node_modules/@ffmpeg/ffmpeg/src/utils/parseArgs.js":
/*!************************************************************!*\
  !*** ./node_modules/@ffmpeg/ffmpeg/src/utils/parseArgs.js ***!
  \************************************************************/
/***/ ((module) => {

eval("module.exports = function (Core, args) {\n  var argsPtr = Core._malloc(args.length * Uint32Array.BYTES_PER_ELEMENT);\n\n  args.forEach(function (s, idx) {\n    var buf = Core._malloc(s.length + 1);\n\n    Core.writeAsciiToMemory(s, buf);\n    Core.setValue(argsPtr + Uint32Array.BYTES_PER_ELEMENT * idx, buf, 'i32');\n  });\n  return [args.length, argsPtr];\n};\n\n//# sourceURL=webpack://WorkBox/./node_modules/@ffmpeg/ffmpeg/src/utils/parseArgs.js?");

/***/ }),

/***/ "./node_modules/@ffmpeg/ffmpeg/src/utils/parseProgress.js":
/*!****************************************************************!*\
  !*** ./node_modules/@ffmpeg/ffmpeg/src/utils/parseProgress.js ***!
  \****************************************************************/
/***/ ((module) => {

eval("function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\n\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== \"undefined\" && arr[Symbol.iterator] || arr[\"@@iterator\"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nvar duration = 0;\nvar ratio = 0;\n\nvar ts2sec = function ts2sec(ts) {\n  var _ts$split = ts.split(':'),\n      _ts$split2 = _slicedToArray(_ts$split, 3),\n      h = _ts$split2[0],\n      m = _ts$split2[1],\n      s = _ts$split2[2];\n\n  return parseFloat(h) * 60 * 60 + parseFloat(m) * 60 + parseFloat(s);\n};\n\nmodule.exports = function (message, progress) {\n  if (typeof message === 'string') {\n    if (message.startsWith('  Duration')) {\n      var ts = message.split(', ')[0].split(': ')[1];\n      var d = ts2sec(ts);\n      progress({\n        duration: d,\n        ratio: ratio\n      });\n\n      if (duration === 0 || duration > d) {\n        duration = d;\n      }\n    } else if (message.startsWith('frame') || message.startsWith('size')) {\n      var _ts = message.split('time=')[1].split(' ')[0];\n      var t = ts2sec(_ts);\n      ratio = t / duration;\n      progress({\n        ratio: ratio,\n        time: t\n      });\n    } else if (message.startsWith('video:')) {\n      progress({\n        ratio: 1\n      });\n      duration = 0;\n    }\n  }\n};\n\n//# sourceURL=webpack://WorkBox/./node_modules/@ffmpeg/ffmpeg/src/utils/parseProgress.js?");

/***/ }),

/***/ "./node_modules/base64-js/index.js":
/*!*****************************************!*\
  !*** ./node_modules/base64-js/index.js ***!
  \*****************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n\nexports.byteLength = byteLength;\nexports.toByteArray = toByteArray;\nexports.fromByteArray = fromByteArray;\nvar lookup = [];\nvar revLookup = [];\nvar Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array;\nvar code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\n\nfor (var i = 0, len = code.length; i < len; ++i) {\n  lookup[i] = code[i];\n  revLookup[code.charCodeAt(i)] = i;\n} // Support decoding URL-safe base64 strings, as Node.js does.\n// See: https://en.wikipedia.org/wiki/Base64#URL_applications\n\n\nrevLookup['-'.charCodeAt(0)] = 62;\nrevLookup['_'.charCodeAt(0)] = 63;\n\nfunction getLens(b64) {\n  var len = b64.length;\n\n  if (len % 4 > 0) {\n    throw new Error('Invalid string. Length must be a multiple of 4');\n  } // Trim off extra bytes after placeholder bytes are found\n  // See: https://github.com/beatgammit/base64-js/issues/42\n\n\n  var validLen = b64.indexOf('=');\n  if (validLen === -1) validLen = len;\n  var placeHoldersLen = validLen === len ? 0 : 4 - validLen % 4;\n  return [validLen, placeHoldersLen];\n} // base64 is 4/3 + up to two characters of the original data\n\n\nfunction byteLength(b64) {\n  var lens = getLens(b64);\n  var validLen = lens[0];\n  var placeHoldersLen = lens[1];\n  return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;\n}\n\nfunction _byteLength(b64, validLen, placeHoldersLen) {\n  return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;\n}\n\nfunction toByteArray(b64) {\n  var tmp;\n  var lens = getLens(b64);\n  var validLen = lens[0];\n  var placeHoldersLen = lens[1];\n  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));\n  var curByte = 0; // if there are placeholders, only get up to the last complete 4 chars\n\n  var len = placeHoldersLen > 0 ? validLen - 4 : validLen;\n  var i;\n\n  for (i = 0; i < len; i += 4) {\n    tmp = revLookup[b64.charCodeAt(i)] << 18 | revLookup[b64.charCodeAt(i + 1)] << 12 | revLookup[b64.charCodeAt(i + 2)] << 6 | revLookup[b64.charCodeAt(i + 3)];\n    arr[curByte++] = tmp >> 16 & 0xFF;\n    arr[curByte++] = tmp >> 8 & 0xFF;\n    arr[curByte++] = tmp & 0xFF;\n  }\n\n  if (placeHoldersLen === 2) {\n    tmp = revLookup[b64.charCodeAt(i)] << 2 | revLookup[b64.charCodeAt(i + 1)] >> 4;\n    arr[curByte++] = tmp & 0xFF;\n  }\n\n  if (placeHoldersLen === 1) {\n    tmp = revLookup[b64.charCodeAt(i)] << 10 | revLookup[b64.charCodeAt(i + 1)] << 4 | revLookup[b64.charCodeAt(i + 2)] >> 2;\n    arr[curByte++] = tmp >> 8 & 0xFF;\n    arr[curByte++] = tmp & 0xFF;\n  }\n\n  return arr;\n}\n\nfunction tripletToBase64(num) {\n  return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F];\n}\n\nfunction encodeChunk(uint8, start, end) {\n  var tmp;\n  var output = [];\n\n  for (var i = start; i < end; i += 3) {\n    tmp = (uint8[i] << 16 & 0xFF0000) + (uint8[i + 1] << 8 & 0xFF00) + (uint8[i + 2] & 0xFF);\n    output.push(tripletToBase64(tmp));\n  }\n\n  return output.join('');\n}\n\nfunction fromByteArray(uint8) {\n  var tmp;\n  var len = uint8.length;\n  var extraBytes = len % 3; // if we have 1 byte left, pad 2 bytes\n\n  var parts = [];\n  var maxChunkLength = 16383; // must be multiple of 3\n  // go through the array every three bytes, we'll deal with trailing stuff later\n\n  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {\n    parts.push(encodeChunk(uint8, i, i + maxChunkLength > len2 ? len2 : i + maxChunkLength));\n  } // pad the end with zeros, but make sure to not forget the extra bytes\n\n\n  if (extraBytes === 1) {\n    tmp = uint8[len - 1];\n    parts.push(lookup[tmp >> 2] + lookup[tmp << 4 & 0x3F] + '==');\n  } else if (extraBytes === 2) {\n    tmp = (uint8[len - 2] << 8) + uint8[len - 1];\n    parts.push(lookup[tmp >> 10] + lookup[tmp >> 4 & 0x3F] + lookup[tmp << 2 & 0x3F] + '=');\n  }\n\n  return parts.join('');\n}\n\n//# sourceURL=webpack://WorkBox/./node_modules/base64-js/index.js?");

/***/ }),

/***/ "./node_modules/buffer/index.js":
/*!**************************************!*\
  !*** ./node_modules/buffer/index.js ***!
  \**************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("/*!\n * The buffer module from node.js, for the browser.\n *\n * @author   Feross Aboukhadijeh <https://feross.org>\n * @license  MIT\n */\n\n/* eslint-disable no-proto */\n\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nvar base64 = __webpack_require__(/*! base64-js */ \"./node_modules/base64-js/index.js\");\n\nvar ieee754 = __webpack_require__(/*! ieee754 */ \"./node_modules/ieee754/index.js\");\n\nvar customInspectSymbol = typeof Symbol === 'function' && typeof Symbol['for'] === 'function' ? Symbol['for']('nodejs.util.inspect.custom') // eslint-disable-line dot-notation\n: null;\nexports.Buffer = Buffer;\nexports.SlowBuffer = SlowBuffer;\nexports.INSPECT_MAX_BYTES = 50;\nvar K_MAX_LENGTH = 0x7fffffff;\nexports.kMaxLength = K_MAX_LENGTH;\n/**\n * If `Buffer.TYPED_ARRAY_SUPPORT`:\n *   === true    Use Uint8Array implementation (fastest)\n *   === false   Print warning and recommend using `buffer` v4.x which has an Object\n *               implementation (most compatible, even IE6)\n *\n * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,\n * Opera 11.6+, iOS 4.2+.\n *\n * We report that the browser does not support typed arrays if the are not subclassable\n * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`\n * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support\n * for __proto__ and has a buggy typed array implementation.\n */\n\nBuffer.TYPED_ARRAY_SUPPORT = typedArraySupport();\n\nif (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== 'undefined' && typeof console.error === 'function') {\n  console.error('This browser lacks typed array (Uint8Array) support which is required by ' + '`buffer` v5.x. Use `buffer` v4.x if you require old browser support.');\n}\n\nfunction typedArraySupport() {\n  // Can typed array instances can be augmented?\n  try {\n    var arr = new Uint8Array(1);\n    var proto = {\n      foo: function foo() {\n        return 42;\n      }\n    };\n    Object.setPrototypeOf(proto, Uint8Array.prototype);\n    Object.setPrototypeOf(arr, proto);\n    return arr.foo() === 42;\n  } catch (e) {\n    return false;\n  }\n}\n\nObject.defineProperty(Buffer.prototype, 'parent', {\n  enumerable: true,\n  get: function get() {\n    if (!Buffer.isBuffer(this)) return undefined;\n    return this.buffer;\n  }\n});\nObject.defineProperty(Buffer.prototype, 'offset', {\n  enumerable: true,\n  get: function get() {\n    if (!Buffer.isBuffer(this)) return undefined;\n    return this.byteOffset;\n  }\n});\n\nfunction createBuffer(length) {\n  if (length > K_MAX_LENGTH) {\n    throw new RangeError('The value \"' + length + '\" is invalid for option \"size\"');\n  } // Return an augmented `Uint8Array` instance\n\n\n  var buf = new Uint8Array(length);\n  Object.setPrototypeOf(buf, Buffer.prototype);\n  return buf;\n}\n/**\n * The Buffer constructor returns instances of `Uint8Array` that have their\n * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of\n * `Uint8Array`, so the returned instances will have all the node `Buffer` methods\n * and the `Uint8Array` methods. Square bracket notation works as expected -- it\n * returns a single octet.\n *\n * The `Uint8Array` prototype remains unmodified.\n */\n\n\nfunction Buffer(arg, encodingOrOffset, length) {\n  // Common case.\n  if (typeof arg === 'number') {\n    if (typeof encodingOrOffset === 'string') {\n      throw new TypeError('The \"string\" argument must be of type string. Received type number');\n    }\n\n    return allocUnsafe(arg);\n  }\n\n  return from(arg, encodingOrOffset, length);\n}\n\nBuffer.poolSize = 8192; // not used by this implementation\n\nfunction from(value, encodingOrOffset, length) {\n  if (typeof value === 'string') {\n    return fromString(value, encodingOrOffset);\n  }\n\n  if (ArrayBuffer.isView(value)) {\n    return fromArrayView(value);\n  }\n\n  if (value == null) {\n    throw new TypeError('The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' + 'or Array-like Object. Received type ' + _typeof(value));\n  }\n\n  if (isInstance(value, ArrayBuffer) || value && isInstance(value.buffer, ArrayBuffer)) {\n    return fromArrayBuffer(value, encodingOrOffset, length);\n  }\n\n  if (typeof SharedArrayBuffer !== 'undefined' && (isInstance(value, SharedArrayBuffer) || value && isInstance(value.buffer, SharedArrayBuffer))) {\n    return fromArrayBuffer(value, encodingOrOffset, length);\n  }\n\n  if (typeof value === 'number') {\n    throw new TypeError('The \"value\" argument must not be of type number. Received type number');\n  }\n\n  var valueOf = value.valueOf && value.valueOf();\n\n  if (valueOf != null && valueOf !== value) {\n    return Buffer.from(valueOf, encodingOrOffset, length);\n  }\n\n  var b = fromObject(value);\n  if (b) return b;\n\n  if (typeof Symbol !== 'undefined' && Symbol.toPrimitive != null && typeof value[Symbol.toPrimitive] === 'function') {\n    return Buffer.from(value[Symbol.toPrimitive]('string'), encodingOrOffset, length);\n  }\n\n  throw new TypeError('The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' + 'or Array-like Object. Received type ' + _typeof(value));\n}\n/**\n * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError\n * if value is a number.\n * Buffer.from(str[, encoding])\n * Buffer.from(array)\n * Buffer.from(buffer)\n * Buffer.from(arrayBuffer[, byteOffset[, length]])\n **/\n\n\nBuffer.from = function (value, encodingOrOffset, length) {\n  return from(value, encodingOrOffset, length);\n}; // Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:\n// https://github.com/feross/buffer/pull/148\n\n\nObject.setPrototypeOf(Buffer.prototype, Uint8Array.prototype);\nObject.setPrototypeOf(Buffer, Uint8Array);\n\nfunction assertSize(size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('\"size\" argument must be of type number');\n  } else if (size < 0) {\n    throw new RangeError('The value \"' + size + '\" is invalid for option \"size\"');\n  }\n}\n\nfunction alloc(size, fill, encoding) {\n  assertSize(size);\n\n  if (size <= 0) {\n    return createBuffer(size);\n  }\n\n  if (fill !== undefined) {\n    // Only pay attention to encoding if it's a string. This\n    // prevents accidentally sending in a number that would\n    // be interpreted as a start offset.\n    return typeof encoding === 'string' ? createBuffer(size).fill(fill, encoding) : createBuffer(size).fill(fill);\n  }\n\n  return createBuffer(size);\n}\n/**\n * Creates a new filled Buffer instance.\n * alloc(size[, fill[, encoding]])\n **/\n\n\nBuffer.alloc = function (size, fill, encoding) {\n  return alloc(size, fill, encoding);\n};\n\nfunction allocUnsafe(size) {\n  assertSize(size);\n  return createBuffer(size < 0 ? 0 : checked(size) | 0);\n}\n/**\n * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.\n * */\n\n\nBuffer.allocUnsafe = function (size) {\n  return allocUnsafe(size);\n};\n/**\n * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.\n */\n\n\nBuffer.allocUnsafeSlow = function (size) {\n  return allocUnsafe(size);\n};\n\nfunction fromString(string, encoding) {\n  if (typeof encoding !== 'string' || encoding === '') {\n    encoding = 'utf8';\n  }\n\n  if (!Buffer.isEncoding(encoding)) {\n    throw new TypeError('Unknown encoding: ' + encoding);\n  }\n\n  var length = byteLength(string, encoding) | 0;\n  var buf = createBuffer(length);\n  var actual = buf.write(string, encoding);\n\n  if (actual !== length) {\n    // Writing a hex string, for example, that contains invalid characters will\n    // cause everything after the first invalid character to be ignored. (e.g.\n    // 'abxxcd' will be treated as 'ab')\n    buf = buf.slice(0, actual);\n  }\n\n  return buf;\n}\n\nfunction fromArrayLike(array) {\n  var length = array.length < 0 ? 0 : checked(array.length) | 0;\n  var buf = createBuffer(length);\n\n  for (var i = 0; i < length; i += 1) {\n    buf[i] = array[i] & 255;\n  }\n\n  return buf;\n}\n\nfunction fromArrayView(arrayView) {\n  if (isInstance(arrayView, Uint8Array)) {\n    var copy = new Uint8Array(arrayView);\n    return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength);\n  }\n\n  return fromArrayLike(arrayView);\n}\n\nfunction fromArrayBuffer(array, byteOffset, length) {\n  if (byteOffset < 0 || array.byteLength < byteOffset) {\n    throw new RangeError('\"offset\" is outside of buffer bounds');\n  }\n\n  if (array.byteLength < byteOffset + (length || 0)) {\n    throw new RangeError('\"length\" is outside of buffer bounds');\n  }\n\n  var buf;\n\n  if (byteOffset === undefined && length === undefined) {\n    buf = new Uint8Array(array);\n  } else if (length === undefined) {\n    buf = new Uint8Array(array, byteOffset);\n  } else {\n    buf = new Uint8Array(array, byteOffset, length);\n  } // Return an augmented `Uint8Array` instance\n\n\n  Object.setPrototypeOf(buf, Buffer.prototype);\n  return buf;\n}\n\nfunction fromObject(obj) {\n  if (Buffer.isBuffer(obj)) {\n    var len = checked(obj.length) | 0;\n    var buf = createBuffer(len);\n\n    if (buf.length === 0) {\n      return buf;\n    }\n\n    obj.copy(buf, 0, 0, len);\n    return buf;\n  }\n\n  if (obj.length !== undefined) {\n    if (typeof obj.length !== 'number' || numberIsNaN(obj.length)) {\n      return createBuffer(0);\n    }\n\n    return fromArrayLike(obj);\n  }\n\n  if (obj.type === 'Buffer' && Array.isArray(obj.data)) {\n    return fromArrayLike(obj.data);\n  }\n}\n\nfunction checked(length) {\n  // Note: cannot use `length < K_MAX_LENGTH` here because that fails when\n  // length is NaN (which is otherwise coerced to zero.)\n  if (length >= K_MAX_LENGTH) {\n    throw new RangeError('Attempt to allocate Buffer larger than maximum ' + 'size: 0x' + K_MAX_LENGTH.toString(16) + ' bytes');\n  }\n\n  return length | 0;\n}\n\nfunction SlowBuffer(length) {\n  if (+length != length) {\n    // eslint-disable-line eqeqeq\n    length = 0;\n  }\n\n  return Buffer.alloc(+length);\n}\n\nBuffer.isBuffer = function isBuffer(b) {\n  return b != null && b._isBuffer === true && b !== Buffer.prototype; // so Buffer.isBuffer(Buffer.prototype) will be false\n};\n\nBuffer.compare = function compare(a, b) {\n  if (isInstance(a, Uint8Array)) a = Buffer.from(a, a.offset, a.byteLength);\n  if (isInstance(b, Uint8Array)) b = Buffer.from(b, b.offset, b.byteLength);\n\n  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {\n    throw new TypeError('The \"buf1\", \"buf2\" arguments must be one of type Buffer or Uint8Array');\n  }\n\n  if (a === b) return 0;\n  var x = a.length;\n  var y = b.length;\n\n  for (var i = 0, len = Math.min(x, y); i < len; ++i) {\n    if (a[i] !== b[i]) {\n      x = a[i];\n      y = b[i];\n      break;\n    }\n  }\n\n  if (x < y) return -1;\n  if (y < x) return 1;\n  return 0;\n};\n\nBuffer.isEncoding = function isEncoding(encoding) {\n  switch (String(encoding).toLowerCase()) {\n    case 'hex':\n    case 'utf8':\n    case 'utf-8':\n    case 'ascii':\n    case 'latin1':\n    case 'binary':\n    case 'base64':\n    case 'ucs2':\n    case 'ucs-2':\n    case 'utf16le':\n    case 'utf-16le':\n      return true;\n\n    default:\n      return false;\n  }\n};\n\nBuffer.concat = function concat(list, length) {\n  if (!Array.isArray(list)) {\n    throw new TypeError('\"list\" argument must be an Array of Buffers');\n  }\n\n  if (list.length === 0) {\n    return Buffer.alloc(0);\n  }\n\n  var i;\n\n  if (length === undefined) {\n    length = 0;\n\n    for (i = 0; i < list.length; ++i) {\n      length += list[i].length;\n    }\n  }\n\n  var buffer = Buffer.allocUnsafe(length);\n  var pos = 0;\n\n  for (i = 0; i < list.length; ++i) {\n    var buf = list[i];\n\n    if (isInstance(buf, Uint8Array)) {\n      if (pos + buf.length > buffer.length) {\n        Buffer.from(buf).copy(buffer, pos);\n      } else {\n        Uint8Array.prototype.set.call(buffer, buf, pos);\n      }\n    } else if (!Buffer.isBuffer(buf)) {\n      throw new TypeError('\"list\" argument must be an Array of Buffers');\n    } else {\n      buf.copy(buffer, pos);\n    }\n\n    pos += buf.length;\n  }\n\n  return buffer;\n};\n\nfunction byteLength(string, encoding) {\n  if (Buffer.isBuffer(string)) {\n    return string.length;\n  }\n\n  if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {\n    return string.byteLength;\n  }\n\n  if (typeof string !== 'string') {\n    throw new TypeError('The \"string\" argument must be one of type string, Buffer, or ArrayBuffer. ' + 'Received type ' + _typeof(string));\n  }\n\n  var len = string.length;\n  var mustMatch = arguments.length > 2 && arguments[2] === true;\n  if (!mustMatch && len === 0) return 0; // Use a for loop to avoid recursion\n\n  var loweredCase = false;\n\n  for (;;) {\n    switch (encoding) {\n      case 'ascii':\n      case 'latin1':\n      case 'binary':\n        return len;\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8ToBytes(string).length;\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return len * 2;\n\n      case 'hex':\n        return len >>> 1;\n\n      case 'base64':\n        return base64ToBytes(string).length;\n\n      default:\n        if (loweredCase) {\n          return mustMatch ? -1 : utf8ToBytes(string).length; // assume utf8\n        }\n\n        encoding = ('' + encoding).toLowerCase();\n        loweredCase = true;\n    }\n  }\n}\n\nBuffer.byteLength = byteLength;\n\nfunction slowToString(encoding, start, end) {\n  var loweredCase = false; // No need to verify that \"this.length <= MAX_UINT32\" since it's a read-only\n  // property of a typed array.\n  // This behaves neither like String nor Uint8Array in that we set start/end\n  // to their upper/lower bounds if the value passed is out of range.\n  // undefined is handled specially as per ECMA-262 6th Edition,\n  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.\n\n  if (start === undefined || start < 0) {\n    start = 0;\n  } // Return early if start > this.length. Done here to prevent potential uint32\n  // coercion fail below.\n\n\n  if (start > this.length) {\n    return '';\n  }\n\n  if (end === undefined || end > this.length) {\n    end = this.length;\n  }\n\n  if (end <= 0) {\n    return '';\n  } // Force coercion to uint32. This will also coerce falsey/NaN values to 0.\n\n\n  end >>>= 0;\n  start >>>= 0;\n\n  if (end <= start) {\n    return '';\n  }\n\n  if (!encoding) encoding = 'utf8';\n\n  while (true) {\n    switch (encoding) {\n      case 'hex':\n        return hexSlice(this, start, end);\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Slice(this, start, end);\n\n      case 'ascii':\n        return asciiSlice(this, start, end);\n\n      case 'latin1':\n      case 'binary':\n        return latin1Slice(this, start, end);\n\n      case 'base64':\n        return base64Slice(this, start, end);\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return utf16leSlice(this, start, end);\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding);\n        encoding = (encoding + '').toLowerCase();\n        loweredCase = true;\n    }\n  }\n} // This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)\n// to detect a Buffer instance. It's not possible to use `instanceof Buffer`\n// reliably in a browserify context because there could be multiple different\n// copies of the 'buffer' package in use. This method works even for Buffer\n// instances that were created from another copy of the `buffer` package.\n// See: https://github.com/feross/buffer/issues/154\n\n\nBuffer.prototype._isBuffer = true;\n\nfunction swap(b, n, m) {\n  var i = b[n];\n  b[n] = b[m];\n  b[m] = i;\n}\n\nBuffer.prototype.swap16 = function swap16() {\n  var len = this.length;\n\n  if (len % 2 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 16-bits');\n  }\n\n  for (var i = 0; i < len; i += 2) {\n    swap(this, i, i + 1);\n  }\n\n  return this;\n};\n\nBuffer.prototype.swap32 = function swap32() {\n  var len = this.length;\n\n  if (len % 4 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 32-bits');\n  }\n\n  for (var i = 0; i < len; i += 4) {\n    swap(this, i, i + 3);\n    swap(this, i + 1, i + 2);\n  }\n\n  return this;\n};\n\nBuffer.prototype.swap64 = function swap64() {\n  var len = this.length;\n\n  if (len % 8 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 64-bits');\n  }\n\n  for (var i = 0; i < len; i += 8) {\n    swap(this, i, i + 7);\n    swap(this, i + 1, i + 6);\n    swap(this, i + 2, i + 5);\n    swap(this, i + 3, i + 4);\n  }\n\n  return this;\n};\n\nBuffer.prototype.toString = function toString() {\n  var length = this.length;\n  if (length === 0) return '';\n  if (arguments.length === 0) return utf8Slice(this, 0, length);\n  return slowToString.apply(this, arguments);\n};\n\nBuffer.prototype.toLocaleString = Buffer.prototype.toString;\n\nBuffer.prototype.equals = function equals(b) {\n  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer');\n  if (this === b) return true;\n  return Buffer.compare(this, b) === 0;\n};\n\nBuffer.prototype.inspect = function inspect() {\n  var str = '';\n  var max = exports.INSPECT_MAX_BYTES;\n  str = this.toString('hex', 0, max).replace(/(.{2})/g, '$1 ').trim();\n  if (this.length > max) str += ' ... ';\n  return '<Buffer ' + str + '>';\n};\n\nif (customInspectSymbol) {\n  Buffer.prototype[customInspectSymbol] = Buffer.prototype.inspect;\n}\n\nBuffer.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {\n  if (isInstance(target, Uint8Array)) {\n    target = Buffer.from(target, target.offset, target.byteLength);\n  }\n\n  if (!Buffer.isBuffer(target)) {\n    throw new TypeError('The \"target\" argument must be one of type Buffer or Uint8Array. ' + 'Received type ' + _typeof(target));\n  }\n\n  if (start === undefined) {\n    start = 0;\n  }\n\n  if (end === undefined) {\n    end = target ? target.length : 0;\n  }\n\n  if (thisStart === undefined) {\n    thisStart = 0;\n  }\n\n  if (thisEnd === undefined) {\n    thisEnd = this.length;\n  }\n\n  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {\n    throw new RangeError('out of range index');\n  }\n\n  if (thisStart >= thisEnd && start >= end) {\n    return 0;\n  }\n\n  if (thisStart >= thisEnd) {\n    return -1;\n  }\n\n  if (start >= end) {\n    return 1;\n  }\n\n  start >>>= 0;\n  end >>>= 0;\n  thisStart >>>= 0;\n  thisEnd >>>= 0;\n  if (this === target) return 0;\n  var x = thisEnd - thisStart;\n  var y = end - start;\n  var len = Math.min(x, y);\n  var thisCopy = this.slice(thisStart, thisEnd);\n  var targetCopy = target.slice(start, end);\n\n  for (var i = 0; i < len; ++i) {\n    if (thisCopy[i] !== targetCopy[i]) {\n      x = thisCopy[i];\n      y = targetCopy[i];\n      break;\n    }\n  }\n\n  if (x < y) return -1;\n  if (y < x) return 1;\n  return 0;\n}; // Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,\n// OR the last index of `val` in `buffer` at offset <= `byteOffset`.\n//\n// Arguments:\n// - buffer - a Buffer to search\n// - val - a string, Buffer, or number\n// - byteOffset - an index into `buffer`; will be clamped to an int32\n// - encoding - an optional encoding, relevant is val is a string\n// - dir - true for indexOf, false for lastIndexOf\n\n\nfunction bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {\n  // Empty buffer means no match\n  if (buffer.length === 0) return -1; // Normalize byteOffset\n\n  if (typeof byteOffset === 'string') {\n    encoding = byteOffset;\n    byteOffset = 0;\n  } else if (byteOffset > 0x7fffffff) {\n    byteOffset = 0x7fffffff;\n  } else if (byteOffset < -0x80000000) {\n    byteOffset = -0x80000000;\n  }\n\n  byteOffset = +byteOffset; // Coerce to Number.\n\n  if (numberIsNaN(byteOffset)) {\n    // byteOffset: it it's undefined, null, NaN, \"foo\", etc, search whole buffer\n    byteOffset = dir ? 0 : buffer.length - 1;\n  } // Normalize byteOffset: negative offsets start from the end of the buffer\n\n\n  if (byteOffset < 0) byteOffset = buffer.length + byteOffset;\n\n  if (byteOffset >= buffer.length) {\n    if (dir) return -1;else byteOffset = buffer.length - 1;\n  } else if (byteOffset < 0) {\n    if (dir) byteOffset = 0;else return -1;\n  } // Normalize val\n\n\n  if (typeof val === 'string') {\n    val = Buffer.from(val, encoding);\n  } // Finally, search either indexOf (if dir is true) or lastIndexOf\n\n\n  if (Buffer.isBuffer(val)) {\n    // Special case: looking for empty string/buffer always fails\n    if (val.length === 0) {\n      return -1;\n    }\n\n    return arrayIndexOf(buffer, val, byteOffset, encoding, dir);\n  } else if (typeof val === 'number') {\n    val = val & 0xFF; // Search for a byte value [0-255]\n\n    if (typeof Uint8Array.prototype.indexOf === 'function') {\n      if (dir) {\n        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);\n      } else {\n        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);\n      }\n    }\n\n    return arrayIndexOf(buffer, [val], byteOffset, encoding, dir);\n  }\n\n  throw new TypeError('val must be string, number or Buffer');\n}\n\nfunction arrayIndexOf(arr, val, byteOffset, encoding, dir) {\n  var indexSize = 1;\n  var arrLength = arr.length;\n  var valLength = val.length;\n\n  if (encoding !== undefined) {\n    encoding = String(encoding).toLowerCase();\n\n    if (encoding === 'ucs2' || encoding === 'ucs-2' || encoding === 'utf16le' || encoding === 'utf-16le') {\n      if (arr.length < 2 || val.length < 2) {\n        return -1;\n      }\n\n      indexSize = 2;\n      arrLength /= 2;\n      valLength /= 2;\n      byteOffset /= 2;\n    }\n  }\n\n  function read(buf, i) {\n    if (indexSize === 1) {\n      return buf[i];\n    } else {\n      return buf.readUInt16BE(i * indexSize);\n    }\n  }\n\n  var i;\n\n  if (dir) {\n    var foundIndex = -1;\n\n    for (i = byteOffset; i < arrLength; i++) {\n      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {\n        if (foundIndex === -1) foundIndex = i;\n        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize;\n      } else {\n        if (foundIndex !== -1) i -= i - foundIndex;\n        foundIndex = -1;\n      }\n    }\n  } else {\n    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;\n\n    for (i = byteOffset; i >= 0; i--) {\n      var found = true;\n\n      for (var j = 0; j < valLength; j++) {\n        if (read(arr, i + j) !== read(val, j)) {\n          found = false;\n          break;\n        }\n      }\n\n      if (found) return i;\n    }\n  }\n\n  return -1;\n}\n\nBuffer.prototype.includes = function includes(val, byteOffset, encoding) {\n  return this.indexOf(val, byteOffset, encoding) !== -1;\n};\n\nBuffer.prototype.indexOf = function indexOf(val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, true);\n};\n\nBuffer.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, false);\n};\n\nfunction hexWrite(buf, string, offset, length) {\n  offset = Number(offset) || 0;\n  var remaining = buf.length - offset;\n\n  if (!length) {\n    length = remaining;\n  } else {\n    length = Number(length);\n\n    if (length > remaining) {\n      length = remaining;\n    }\n  }\n\n  var strLen = string.length;\n\n  if (length > strLen / 2) {\n    length = strLen / 2;\n  }\n\n  for (var i = 0; i < length; ++i) {\n    var parsed = parseInt(string.substr(i * 2, 2), 16);\n    if (numberIsNaN(parsed)) return i;\n    buf[offset + i] = parsed;\n  }\n\n  return i;\n}\n\nfunction utf8Write(buf, string, offset, length) {\n  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);\n}\n\nfunction asciiWrite(buf, string, offset, length) {\n  return blitBuffer(asciiToBytes(string), buf, offset, length);\n}\n\nfunction base64Write(buf, string, offset, length) {\n  return blitBuffer(base64ToBytes(string), buf, offset, length);\n}\n\nfunction ucs2Write(buf, string, offset, length) {\n  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);\n}\n\nBuffer.prototype.write = function write(string, offset, length, encoding) {\n  // Buffer#write(string)\n  if (offset === undefined) {\n    encoding = 'utf8';\n    length = this.length;\n    offset = 0; // Buffer#write(string, encoding)\n  } else if (length === undefined && typeof offset === 'string') {\n    encoding = offset;\n    length = this.length;\n    offset = 0; // Buffer#write(string, offset[, length][, encoding])\n  } else if (isFinite(offset)) {\n    offset = offset >>> 0;\n\n    if (isFinite(length)) {\n      length = length >>> 0;\n      if (encoding === undefined) encoding = 'utf8';\n    } else {\n      encoding = length;\n      length = undefined;\n    }\n  } else {\n    throw new Error('Buffer.write(string, encoding, offset[, length]) is no longer supported');\n  }\n\n  var remaining = this.length - offset;\n  if (length === undefined || length > remaining) length = remaining;\n\n  if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {\n    throw new RangeError('Attempt to write outside buffer bounds');\n  }\n\n  if (!encoding) encoding = 'utf8';\n  var loweredCase = false;\n\n  for (;;) {\n    switch (encoding) {\n      case 'hex':\n        return hexWrite(this, string, offset, length);\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Write(this, string, offset, length);\n\n      case 'ascii':\n      case 'latin1':\n      case 'binary':\n        return asciiWrite(this, string, offset, length);\n\n      case 'base64':\n        // Warning: maxLength not taken into account in base64Write\n        return base64Write(this, string, offset, length);\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return ucs2Write(this, string, offset, length);\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding);\n        encoding = ('' + encoding).toLowerCase();\n        loweredCase = true;\n    }\n  }\n};\n\nBuffer.prototype.toJSON = function toJSON() {\n  return {\n    type: 'Buffer',\n    data: Array.prototype.slice.call(this._arr || this, 0)\n  };\n};\n\nfunction base64Slice(buf, start, end) {\n  if (start === 0 && end === buf.length) {\n    return base64.fromByteArray(buf);\n  } else {\n    return base64.fromByteArray(buf.slice(start, end));\n  }\n}\n\nfunction utf8Slice(buf, start, end) {\n  end = Math.min(buf.length, end);\n  var res = [];\n  var i = start;\n\n  while (i < end) {\n    var firstByte = buf[i];\n    var codePoint = null;\n    var bytesPerSequence = firstByte > 0xEF ? 4 : firstByte > 0xDF ? 3 : firstByte > 0xBF ? 2 : 1;\n\n    if (i + bytesPerSequence <= end) {\n      var secondByte, thirdByte, fourthByte, tempCodePoint;\n\n      switch (bytesPerSequence) {\n        case 1:\n          if (firstByte < 0x80) {\n            codePoint = firstByte;\n          }\n\n          break;\n\n        case 2:\n          secondByte = buf[i + 1];\n\n          if ((secondByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0x1F) << 0x6 | secondByte & 0x3F;\n\n            if (tempCodePoint > 0x7F) {\n              codePoint = tempCodePoint;\n            }\n          }\n\n          break;\n\n        case 3:\n          secondByte = buf[i + 1];\n          thirdByte = buf[i + 2];\n\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | thirdByte & 0x3F;\n\n            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {\n              codePoint = tempCodePoint;\n            }\n          }\n\n          break;\n\n        case 4:\n          secondByte = buf[i + 1];\n          thirdByte = buf[i + 2];\n          fourthByte = buf[i + 3];\n\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | fourthByte & 0x3F;\n\n            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {\n              codePoint = tempCodePoint;\n            }\n          }\n\n      }\n    }\n\n    if (codePoint === null) {\n      // we did not generate a valid codePoint so insert a\n      // replacement char (U+FFFD) and advance only 1 byte\n      codePoint = 0xFFFD;\n      bytesPerSequence = 1;\n    } else if (codePoint > 0xFFFF) {\n      // encode to utf16 (surrogate pair dance)\n      codePoint -= 0x10000;\n      res.push(codePoint >>> 10 & 0x3FF | 0xD800);\n      codePoint = 0xDC00 | codePoint & 0x3FF;\n    }\n\n    res.push(codePoint);\n    i += bytesPerSequence;\n  }\n\n  return decodeCodePointsArray(res);\n} // Based on http://stackoverflow.com/a/22747272/680742, the browser with\n// the lowest limit is Chrome, with 0x10000 args.\n// We go 1 magnitude less, for safety\n\n\nvar MAX_ARGUMENTS_LENGTH = 0x1000;\n\nfunction decodeCodePointsArray(codePoints) {\n  var len = codePoints.length;\n\n  if (len <= MAX_ARGUMENTS_LENGTH) {\n    return String.fromCharCode.apply(String, codePoints); // avoid extra slice()\n  } // Decode in chunks to avoid \"call stack size exceeded\".\n\n\n  var res = '';\n  var i = 0;\n\n  while (i < len) {\n    res += String.fromCharCode.apply(String, codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH));\n  }\n\n  return res;\n}\n\nfunction asciiSlice(buf, start, end) {\n  var ret = '';\n  end = Math.min(buf.length, end);\n\n  for (var i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i] & 0x7F);\n  }\n\n  return ret;\n}\n\nfunction latin1Slice(buf, start, end) {\n  var ret = '';\n  end = Math.min(buf.length, end);\n\n  for (var i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i]);\n  }\n\n  return ret;\n}\n\nfunction hexSlice(buf, start, end) {\n  var len = buf.length;\n  if (!start || start < 0) start = 0;\n  if (!end || end < 0 || end > len) end = len;\n  var out = '';\n\n  for (var i = start; i < end; ++i) {\n    out += hexSliceLookupTable[buf[i]];\n  }\n\n  return out;\n}\n\nfunction utf16leSlice(buf, start, end) {\n  var bytes = buf.slice(start, end);\n  var res = ''; // If bytes.length is odd, the last 8 bits must be ignored (same as node.js)\n\n  for (var i = 0; i < bytes.length - 1; i += 2) {\n    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);\n  }\n\n  return res;\n}\n\nBuffer.prototype.slice = function slice(start, end) {\n  var len = this.length;\n  start = ~~start;\n  end = end === undefined ? len : ~~end;\n\n  if (start < 0) {\n    start += len;\n    if (start < 0) start = 0;\n  } else if (start > len) {\n    start = len;\n  }\n\n  if (end < 0) {\n    end += len;\n    if (end < 0) end = 0;\n  } else if (end > len) {\n    end = len;\n  }\n\n  if (end < start) end = start;\n  var newBuf = this.subarray(start, end); // Return an augmented `Uint8Array` instance\n\n  Object.setPrototypeOf(newBuf, Buffer.prototype);\n  return newBuf;\n};\n/*\n * Need to make sure that buffer isn't trying to write out of bounds.\n */\n\n\nfunction checkOffset(offset, ext, length) {\n  if (offset % 1 !== 0 || offset < 0) throw new RangeError('offset is not uint');\n  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length');\n}\n\nBuffer.prototype.readUintLE = Buffer.prototype.readUIntLE = function readUIntLE(offset, byteLength, noAssert) {\n  offset = offset >>> 0;\n  byteLength = byteLength >>> 0;\n  if (!noAssert) checkOffset(offset, byteLength, this.length);\n  var val = this[offset];\n  var mul = 1;\n  var i = 0;\n\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul;\n  }\n\n  return val;\n};\n\nBuffer.prototype.readUintBE = Buffer.prototype.readUIntBE = function readUIntBE(offset, byteLength, noAssert) {\n  offset = offset >>> 0;\n  byteLength = byteLength >>> 0;\n\n  if (!noAssert) {\n    checkOffset(offset, byteLength, this.length);\n  }\n\n  var val = this[offset + --byteLength];\n  var mul = 1;\n\n  while (byteLength > 0 && (mul *= 0x100)) {\n    val += this[offset + --byteLength] * mul;\n  }\n\n  return val;\n};\n\nBuffer.prototype.readUint8 = Buffer.prototype.readUInt8 = function readUInt8(offset, noAssert) {\n  offset = offset >>> 0;\n  if (!noAssert) checkOffset(offset, 1, this.length);\n  return this[offset];\n};\n\nBuffer.prototype.readUint16LE = Buffer.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {\n  offset = offset >>> 0;\n  if (!noAssert) checkOffset(offset, 2, this.length);\n  return this[offset] | this[offset + 1] << 8;\n};\n\nBuffer.prototype.readUint16BE = Buffer.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {\n  offset = offset >>> 0;\n  if (!noAssert) checkOffset(offset, 2, this.length);\n  return this[offset] << 8 | this[offset + 1];\n};\n\nBuffer.prototype.readUint32LE = Buffer.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {\n  offset = offset >>> 0;\n  if (!noAssert) checkOffset(offset, 4, this.length);\n  return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 0x1000000;\n};\n\nBuffer.prototype.readUint32BE = Buffer.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {\n  offset = offset >>> 0;\n  if (!noAssert) checkOffset(offset, 4, this.length);\n  return this[offset] * 0x1000000 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);\n};\n\nBuffer.prototype.readIntLE = function readIntLE(offset, byteLength, noAssert) {\n  offset = offset >>> 0;\n  byteLength = byteLength >>> 0;\n  if (!noAssert) checkOffset(offset, byteLength, this.length);\n  var val = this[offset];\n  var mul = 1;\n  var i = 0;\n\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul;\n  }\n\n  mul *= 0x80;\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength);\n  return val;\n};\n\nBuffer.prototype.readIntBE = function readIntBE(offset, byteLength, noAssert) {\n  offset = offset >>> 0;\n  byteLength = byteLength >>> 0;\n  if (!noAssert) checkOffset(offset, byteLength, this.length);\n  var i = byteLength;\n  var mul = 1;\n  var val = this[offset + --i];\n\n  while (i > 0 && (mul *= 0x100)) {\n    val += this[offset + --i] * mul;\n  }\n\n  mul *= 0x80;\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength);\n  return val;\n};\n\nBuffer.prototype.readInt8 = function readInt8(offset, noAssert) {\n  offset = offset >>> 0;\n  if (!noAssert) checkOffset(offset, 1, this.length);\n  if (!(this[offset] & 0x80)) return this[offset];\n  return (0xff - this[offset] + 1) * -1;\n};\n\nBuffer.prototype.readInt16LE = function readInt16LE(offset, noAssert) {\n  offset = offset >>> 0;\n  if (!noAssert) checkOffset(offset, 2, this.length);\n  var val = this[offset] | this[offset + 1] << 8;\n  return val & 0x8000 ? val | 0xFFFF0000 : val;\n};\n\nBuffer.prototype.readInt16BE = function readInt16BE(offset, noAssert) {\n  offset = offset >>> 0;\n  if (!noAssert) checkOffset(offset, 2, this.length);\n  var val = this[offset + 1] | this[offset] << 8;\n  return val & 0x8000 ? val | 0xFFFF0000 : val;\n};\n\nBuffer.prototype.readInt32LE = function readInt32LE(offset, noAssert) {\n  offset = offset >>> 0;\n  if (!noAssert) checkOffset(offset, 4, this.length);\n  return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;\n};\n\nBuffer.prototype.readInt32BE = function readInt32BE(offset, noAssert) {\n  offset = offset >>> 0;\n  if (!noAssert) checkOffset(offset, 4, this.length);\n  return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];\n};\n\nBuffer.prototype.readFloatLE = function readFloatLE(offset, noAssert) {\n  offset = offset >>> 0;\n  if (!noAssert) checkOffset(offset, 4, this.length);\n  return ieee754.read(this, offset, true, 23, 4);\n};\n\nBuffer.prototype.readFloatBE = function readFloatBE(offset, noAssert) {\n  offset = offset >>> 0;\n  if (!noAssert) checkOffset(offset, 4, this.length);\n  return ieee754.read(this, offset, false, 23, 4);\n};\n\nBuffer.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {\n  offset = offset >>> 0;\n  if (!noAssert) checkOffset(offset, 8, this.length);\n  return ieee754.read(this, offset, true, 52, 8);\n};\n\nBuffer.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {\n  offset = offset >>> 0;\n  if (!noAssert) checkOffset(offset, 8, this.length);\n  return ieee754.read(this, offset, false, 52, 8);\n};\n\nfunction checkInt(buf, value, offset, ext, max, min) {\n  if (!Buffer.isBuffer(buf)) throw new TypeError('\"buffer\" argument must be a Buffer instance');\n  if (value > max || value < min) throw new RangeError('\"value\" argument is out of bounds');\n  if (offset + ext > buf.length) throw new RangeError('Index out of range');\n}\n\nBuffer.prototype.writeUintLE = Buffer.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength, noAssert) {\n  value = +value;\n  offset = offset >>> 0;\n  byteLength = byteLength >>> 0;\n\n  if (!noAssert) {\n    var maxBytes = Math.pow(2, 8 * byteLength) - 1;\n    checkInt(this, value, offset, byteLength, maxBytes, 0);\n  }\n\n  var mul = 1;\n  var i = 0;\n  this[offset] = value & 0xFF;\n\n  while (++i < byteLength && (mul *= 0x100)) {\n    this[offset + i] = value / mul & 0xFF;\n  }\n\n  return offset + byteLength;\n};\n\nBuffer.prototype.writeUintBE = Buffer.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength, noAssert) {\n  value = +value;\n  offset = offset >>> 0;\n  byteLength = byteLength >>> 0;\n\n  if (!noAssert) {\n    var maxBytes = Math.pow(2, 8 * byteLength) - 1;\n    checkInt(this, value, offset, byteLength, maxBytes, 0);\n  }\n\n  var i = byteLength - 1;\n  var mul = 1;\n  this[offset + i] = value & 0xFF;\n\n  while (--i >= 0 && (mul *= 0x100)) {\n    this[offset + i] = value / mul & 0xFF;\n  }\n\n  return offset + byteLength;\n};\n\nBuffer.prototype.writeUint8 = Buffer.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {\n  value = +value;\n  offset = offset >>> 0;\n  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0);\n  this[offset] = value & 0xff;\n  return offset + 1;\n};\n\nBuffer.prototype.writeUint16LE = Buffer.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {\n  value = +value;\n  offset = offset >>> 0;\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);\n  this[offset] = value & 0xff;\n  this[offset + 1] = value >>> 8;\n  return offset + 2;\n};\n\nBuffer.prototype.writeUint16BE = Buffer.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {\n  value = +value;\n  offset = offset >>> 0;\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);\n  this[offset] = value >>> 8;\n  this[offset + 1] = value & 0xff;\n  return offset + 2;\n};\n\nBuffer.prototype.writeUint32LE = Buffer.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {\n  value = +value;\n  offset = offset >>> 0;\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);\n  this[offset + 3] = value >>> 24;\n  this[offset + 2] = value >>> 16;\n  this[offset + 1] = value >>> 8;\n  this[offset] = value & 0xff;\n  return offset + 4;\n};\n\nBuffer.prototype.writeUint32BE = Buffer.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {\n  value = +value;\n  offset = offset >>> 0;\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);\n  this[offset] = value >>> 24;\n  this[offset + 1] = value >>> 16;\n  this[offset + 2] = value >>> 8;\n  this[offset + 3] = value & 0xff;\n  return offset + 4;\n};\n\nBuffer.prototype.writeIntLE = function writeIntLE(value, offset, byteLength, noAssert) {\n  value = +value;\n  offset = offset >>> 0;\n\n  if (!noAssert) {\n    var limit = Math.pow(2, 8 * byteLength - 1);\n    checkInt(this, value, offset, byteLength, limit - 1, -limit);\n  }\n\n  var i = 0;\n  var mul = 1;\n  var sub = 0;\n  this[offset] = value & 0xFF;\n\n  while (++i < byteLength && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {\n      sub = 1;\n    }\n\n    this[offset + i] = (value / mul >> 0) - sub & 0xFF;\n  }\n\n  return offset + byteLength;\n};\n\nBuffer.prototype.writeIntBE = function writeIntBE(value, offset, byteLength, noAssert) {\n  value = +value;\n  offset = offset >>> 0;\n\n  if (!noAssert) {\n    var limit = Math.pow(2, 8 * byteLength - 1);\n    checkInt(this, value, offset, byteLength, limit - 1, -limit);\n  }\n\n  var i = byteLength - 1;\n  var mul = 1;\n  var sub = 0;\n  this[offset + i] = value & 0xFF;\n\n  while (--i >= 0 && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {\n      sub = 1;\n    }\n\n    this[offset + i] = (value / mul >> 0) - sub & 0xFF;\n  }\n\n  return offset + byteLength;\n};\n\nBuffer.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {\n  value = +value;\n  offset = offset >>> 0;\n  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80);\n  if (value < 0) value = 0xff + value + 1;\n  this[offset] = value & 0xff;\n  return offset + 1;\n};\n\nBuffer.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {\n  value = +value;\n  offset = offset >>> 0;\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);\n  this[offset] = value & 0xff;\n  this[offset + 1] = value >>> 8;\n  return offset + 2;\n};\n\nBuffer.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {\n  value = +value;\n  offset = offset >>> 0;\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);\n  this[offset] = value >>> 8;\n  this[offset + 1] = value & 0xff;\n  return offset + 2;\n};\n\nBuffer.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {\n  value = +value;\n  offset = offset >>> 0;\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);\n  this[offset] = value & 0xff;\n  this[offset + 1] = value >>> 8;\n  this[offset + 2] = value >>> 16;\n  this[offset + 3] = value >>> 24;\n  return offset + 4;\n};\n\nBuffer.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {\n  value = +value;\n  offset = offset >>> 0;\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);\n  if (value < 0) value = 0xffffffff + value + 1;\n  this[offset] = value >>> 24;\n  this[offset + 1] = value >>> 16;\n  this[offset + 2] = value >>> 8;\n  this[offset + 3] = value & 0xff;\n  return offset + 4;\n};\n\nfunction checkIEEE754(buf, value, offset, ext, max, min) {\n  if (offset + ext > buf.length) throw new RangeError('Index out of range');\n  if (offset < 0) throw new RangeError('Index out of range');\n}\n\nfunction writeFloat(buf, value, offset, littleEndian, noAssert) {\n  value = +value;\n  offset = offset >>> 0;\n\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38);\n  }\n\n  ieee754.write(buf, value, offset, littleEndian, 23, 4);\n  return offset + 4;\n}\n\nBuffer.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {\n  return writeFloat(this, value, offset, true, noAssert);\n};\n\nBuffer.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {\n  return writeFloat(this, value, offset, false, noAssert);\n};\n\nfunction writeDouble(buf, value, offset, littleEndian, noAssert) {\n  value = +value;\n  offset = offset >>> 0;\n\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308);\n  }\n\n  ieee754.write(buf, value, offset, littleEndian, 52, 8);\n  return offset + 8;\n}\n\nBuffer.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {\n  return writeDouble(this, value, offset, true, noAssert);\n};\n\nBuffer.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {\n  return writeDouble(this, value, offset, false, noAssert);\n}; // copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)\n\n\nBuffer.prototype.copy = function copy(target, targetStart, start, end) {\n  if (!Buffer.isBuffer(target)) throw new TypeError('argument should be a Buffer');\n  if (!start) start = 0;\n  if (!end && end !== 0) end = this.length;\n  if (targetStart >= target.length) targetStart = target.length;\n  if (!targetStart) targetStart = 0;\n  if (end > 0 && end < start) end = start; // Copy 0 bytes; we're done\n\n  if (end === start) return 0;\n  if (target.length === 0 || this.length === 0) return 0; // Fatal error conditions\n\n  if (targetStart < 0) {\n    throw new RangeError('targetStart out of bounds');\n  }\n\n  if (start < 0 || start >= this.length) throw new RangeError('Index out of range');\n  if (end < 0) throw new RangeError('sourceEnd out of bounds'); // Are we oob?\n\n  if (end > this.length) end = this.length;\n\n  if (target.length - targetStart < end - start) {\n    end = target.length - targetStart + start;\n  }\n\n  var len = end - start;\n\n  if (this === target && typeof Uint8Array.prototype.copyWithin === 'function') {\n    // Use built-in when available, missing from IE11\n    this.copyWithin(targetStart, start, end);\n  } else {\n    Uint8Array.prototype.set.call(target, this.subarray(start, end), targetStart);\n  }\n\n  return len;\n}; // Usage:\n//    buffer.fill(number[, offset[, end]])\n//    buffer.fill(buffer[, offset[, end]])\n//    buffer.fill(string[, offset[, end]][, encoding])\n\n\nBuffer.prototype.fill = function fill(val, start, end, encoding) {\n  // Handle string cases:\n  if (typeof val === 'string') {\n    if (typeof start === 'string') {\n      encoding = start;\n      start = 0;\n      end = this.length;\n    } else if (typeof end === 'string') {\n      encoding = end;\n      end = this.length;\n    }\n\n    if (encoding !== undefined && typeof encoding !== 'string') {\n      throw new TypeError('encoding must be a string');\n    }\n\n    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {\n      throw new TypeError('Unknown encoding: ' + encoding);\n    }\n\n    if (val.length === 1) {\n      var code = val.charCodeAt(0);\n\n      if (encoding === 'utf8' && code < 128 || encoding === 'latin1') {\n        // Fast path: If `val` fits into a single byte, use that numeric value.\n        val = code;\n      }\n    }\n  } else if (typeof val === 'number') {\n    val = val & 255;\n  } else if (typeof val === 'boolean') {\n    val = Number(val);\n  } // Invalid ranges are not set to a default, so can range check early.\n\n\n  if (start < 0 || this.length < start || this.length < end) {\n    throw new RangeError('Out of range index');\n  }\n\n  if (end <= start) {\n    return this;\n  }\n\n  start = start >>> 0;\n  end = end === undefined ? this.length : end >>> 0;\n  if (!val) val = 0;\n  var i;\n\n  if (typeof val === 'number') {\n    for (i = start; i < end; ++i) {\n      this[i] = val;\n    }\n  } else {\n    var bytes = Buffer.isBuffer(val) ? val : Buffer.from(val, encoding);\n    var len = bytes.length;\n\n    if (len === 0) {\n      throw new TypeError('The value \"' + val + '\" is invalid for argument \"value\"');\n    }\n\n    for (i = 0; i < end - start; ++i) {\n      this[i + start] = bytes[i % len];\n    }\n  }\n\n  return this;\n}; // HELPER FUNCTIONS\n// ================\n\n\nvar INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;\n\nfunction base64clean(str) {\n  // Node takes equal signs as end of the Base64 encoding\n  str = str.split('=')[0]; // Node strips out invalid characters like \\n and \\t from the string, base64-js does not\n\n  str = str.trim().replace(INVALID_BASE64_RE, ''); // Node converts strings with length < 2 to ''\n\n  if (str.length < 2) return ''; // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not\n\n  while (str.length % 4 !== 0) {\n    str = str + '=';\n  }\n\n  return str;\n}\n\nfunction utf8ToBytes(string, units) {\n  units = units || Infinity;\n  var codePoint;\n  var length = string.length;\n  var leadSurrogate = null;\n  var bytes = [];\n\n  for (var i = 0; i < length; ++i) {\n    codePoint = string.charCodeAt(i); // is surrogate component\n\n    if (codePoint > 0xD7FF && codePoint < 0xE000) {\n      // last char was a lead\n      if (!leadSurrogate) {\n        // no lead yet\n        if (codePoint > 0xDBFF) {\n          // unexpected trail\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);\n          continue;\n        } else if (i + 1 === length) {\n          // unpaired lead\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);\n          continue;\n        } // valid lead\n\n\n        leadSurrogate = codePoint;\n        continue;\n      } // 2 leads in a row\n\n\n      if (codePoint < 0xDC00) {\n        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);\n        leadSurrogate = codePoint;\n        continue;\n      } // valid surrogate pair\n\n\n      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000;\n    } else if (leadSurrogate) {\n      // valid bmp char, but last char was a lead\n      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);\n    }\n\n    leadSurrogate = null; // encode utf8\n\n    if (codePoint < 0x80) {\n      if ((units -= 1) < 0) break;\n      bytes.push(codePoint);\n    } else if (codePoint < 0x800) {\n      if ((units -= 2) < 0) break;\n      bytes.push(codePoint >> 0x6 | 0xC0, codePoint & 0x3F | 0x80);\n    } else if (codePoint < 0x10000) {\n      if ((units -= 3) < 0) break;\n      bytes.push(codePoint >> 0xC | 0xE0, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);\n    } else if (codePoint < 0x110000) {\n      if ((units -= 4) < 0) break;\n      bytes.push(codePoint >> 0x12 | 0xF0, codePoint >> 0xC & 0x3F | 0x80, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);\n    } else {\n      throw new Error('Invalid code point');\n    }\n  }\n\n  return bytes;\n}\n\nfunction asciiToBytes(str) {\n  var byteArray = [];\n\n  for (var i = 0; i < str.length; ++i) {\n    // Node's code seems to be doing this and not & 0x7F..\n    byteArray.push(str.charCodeAt(i) & 0xFF);\n  }\n\n  return byteArray;\n}\n\nfunction utf16leToBytes(str, units) {\n  var c, hi, lo;\n  var byteArray = [];\n\n  for (var i = 0; i < str.length; ++i) {\n    if ((units -= 2) < 0) break;\n    c = str.charCodeAt(i);\n    hi = c >> 8;\n    lo = c % 256;\n    byteArray.push(lo);\n    byteArray.push(hi);\n  }\n\n  return byteArray;\n}\n\nfunction base64ToBytes(str) {\n  return base64.toByteArray(base64clean(str));\n}\n\nfunction blitBuffer(src, dst, offset, length) {\n  for (var i = 0; i < length; ++i) {\n    if (i + offset >= dst.length || i >= src.length) break;\n    dst[i + offset] = src[i];\n  }\n\n  return i;\n} // ArrayBuffer or Uint8Array objects from other contexts (i.e. iframes) do not pass\n// the `instanceof` check but they should be treated as of that type.\n// See: https://github.com/feross/buffer/issues/166\n\n\nfunction isInstance(obj, type) {\n  return obj instanceof type || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type.name;\n}\n\nfunction numberIsNaN(obj) {\n  // For IE11 support\n  return obj !== obj; // eslint-disable-line no-self-compare\n} // Create lookup table for `toString('hex')`\n// See: https://github.com/feross/buffer/issues/219\n\n\nvar hexSliceLookupTable = function () {\n  var alphabet = '0123456789abcdef';\n  var table = new Array(256);\n\n  for (var i = 0; i < 16; ++i) {\n    var i16 = i * 16;\n\n    for (var j = 0; j < 16; ++j) {\n      table[i16 + j] = alphabet[i] + alphabet[j];\n    }\n  }\n\n  return table;\n}();\n\n//# sourceURL=webpack://WorkBox/./node_modules/buffer/index.js?");

/***/ }),

/***/ "./node_modules/ieee754/index.js":
/*!***************************************!*\
  !*** ./node_modules/ieee754/index.js ***!
  \***************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */\nexports.read = function (buffer, offset, isLE, mLen, nBytes) {\n  var e, m;\n  var eLen = nBytes * 8 - mLen - 1;\n  var eMax = (1 << eLen) - 1;\n  var eBias = eMax >> 1;\n  var nBits = -7;\n  var i = isLE ? nBytes - 1 : 0;\n  var d = isLE ? -1 : 1;\n  var s = buffer[offset + i];\n  i += d;\n  e = s & (1 << -nBits) - 1;\n  s >>= -nBits;\n  nBits += eLen;\n\n  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}\n\n  m = e & (1 << -nBits) - 1;\n  e >>= -nBits;\n  nBits += mLen;\n\n  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}\n\n  if (e === 0) {\n    e = 1 - eBias;\n  } else if (e === eMax) {\n    return m ? NaN : (s ? -1 : 1) * Infinity;\n  } else {\n    m = m + Math.pow(2, mLen);\n    e = e - eBias;\n  }\n\n  return (s ? -1 : 1) * m * Math.pow(2, e - mLen);\n};\n\nexports.write = function (buffer, value, offset, isLE, mLen, nBytes) {\n  var e, m, c;\n  var eLen = nBytes * 8 - mLen - 1;\n  var eMax = (1 << eLen) - 1;\n  var eBias = eMax >> 1;\n  var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;\n  var i = isLE ? 0 : nBytes - 1;\n  var d = isLE ? 1 : -1;\n  var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;\n  value = Math.abs(value);\n\n  if (isNaN(value) || value === Infinity) {\n    m = isNaN(value) ? 1 : 0;\n    e = eMax;\n  } else {\n    e = Math.floor(Math.log(value) / Math.LN2);\n\n    if (value * (c = Math.pow(2, -e)) < 1) {\n      e--;\n      c *= 2;\n    }\n\n    if (e + eBias >= 1) {\n      value += rt / c;\n    } else {\n      value += rt * Math.pow(2, 1 - eBias);\n    }\n\n    if (value * c >= 2) {\n      e++;\n      c /= 2;\n    }\n\n    if (e + eBias >= eMax) {\n      m = 0;\n      e = eMax;\n    } else if (e + eBias >= 1) {\n      m = (value * c - 1) * Math.pow(2, mLen);\n      e = e + eBias;\n    } else {\n      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);\n      e = 0;\n    }\n  }\n\n  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}\n\n  e = e << mLen | m;\n  eLen += mLen;\n\n  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}\n\n  buffer[offset + i - d] |= s * 128;\n};\n\n//# sourceURL=webpack://WorkBox/./node_modules/ieee754/index.js?");

/***/ }),

/***/ "./node_modules/m3u8stream/dist/dash-mpd-parser.js":
/*!*********************************************************!*\
  !*** ./node_modules/m3u8stream/dist/dash-mpd-parser.js ***!
  \*********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } else if (call !== void 0) { throw new TypeError(\"Derived constructors may only return object or undefined\"); } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\n\nvar stream_1 = __webpack_require__(Object(function webpackMissingModule() { var e = new Error(\"Cannot find module 'stream'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }()));\n\nvar sax_1 = __importDefault(__webpack_require__(/*! sax */ \"./node_modules/sax/lib/sax.js\"));\n\nvar parse_time_1 = __webpack_require__(/*! ./parse-time */ \"./node_modules/m3u8stream/dist/parse-time.js\");\n/**\n * A wrapper around sax that emits segments.\n */\n\n\nvar DashMPDParser = /*#__PURE__*/function (_stream_1$Writable) {\n  _inherits(DashMPDParser, _stream_1$Writable);\n\n  var _super = _createSuper(DashMPDParser);\n\n  function DashMPDParser(targetID) {\n    var _this;\n\n    _classCallCheck(this, DashMPDParser);\n\n    _this = _super.call(this);\n    _this._parser = sax_1.default.createStream(false, {\n      lowercase: true\n    });\n\n    _this._parser.on('error', _this.destroy.bind(_assertThisInitialized(_this)));\n\n    var lastTag;\n    var currtime = 0;\n    var seq = 0;\n    var segmentTemplate;\n    var timescale, offset, duration, baseURL;\n    var timeline = [];\n    var getSegments = false;\n    var gotSegments = false;\n    var isStatic;\n    var treeLevel;\n    var periodStart;\n\n    var tmpl = function tmpl(str) {\n      var context = {\n        RepresentationID: targetID,\n        Number: seq,\n        Time: currtime\n      };\n      return str.replace(/\\$(\\w+)\\$/g, function (m, p1) {\n        return \"\".concat(context[p1]);\n      });\n    };\n\n    _this._parser.on('opentag', function (node) {\n      switch (node.name) {\n        case 'mpd':\n          currtime = node.attributes.availabilitystarttime ? new Date(node.attributes.availabilitystarttime).getTime() : 0;\n          isStatic = node.attributes.type !== 'dynamic';\n          break;\n\n        case 'period':\n          // Reset everything on <Period> tag.\n          seq = 0;\n          timescale = 1000;\n          duration = 0;\n          offset = 0;\n          baseURL = [];\n          treeLevel = 0;\n          periodStart = parse_time_1.durationStr(node.attributes.start) || 0;\n          break;\n\n        case 'segmentlist':\n          seq = parseInt(node.attributes.startnumber) || seq;\n          timescale = parseInt(node.attributes.timescale) || timescale;\n          duration = parseInt(node.attributes.duration) || duration;\n          offset = parseInt(node.attributes.presentationtimeoffset) || offset;\n          break;\n\n        case 'segmenttemplate':\n          segmentTemplate = node.attributes;\n          seq = parseInt(node.attributes.startnumber) || seq;\n          timescale = parseInt(node.attributes.timescale) || timescale;\n          break;\n\n        case 'segmenttimeline':\n        case 'baseurl':\n          lastTag = node.name;\n          break;\n\n        case 's':\n          timeline.push({\n            duration: parseInt(node.attributes.d),\n            repeat: parseInt(node.attributes.r),\n            time: parseInt(node.attributes.t)\n          });\n          break;\n\n        case 'adaptationset':\n        case 'representation':\n          treeLevel++;\n\n          if (!targetID) {\n            targetID = node.attributes.id;\n          }\n\n          getSegments = node.attributes.id === \"\".concat(targetID);\n\n          if (getSegments) {\n            if (periodStart) {\n              currtime += periodStart;\n            }\n\n            if (offset) {\n              currtime -= offset / timescale * 1000;\n            }\n\n            _this.emit('starttime', currtime);\n          }\n\n          break;\n\n        case 'initialization':\n          if (getSegments) {\n            _this.emit('item', {\n              url: baseURL.filter(function (s) {\n                return !!s;\n              }).join('') + node.attributes.sourceurl,\n              seq: seq,\n              init: true,\n              duration: 0\n            });\n          }\n\n          break;\n\n        case 'segmenturl':\n          if (getSegments) {\n            gotSegments = true;\n            var tl = timeline.shift();\n            var segmentDuration = ((tl === null || tl === void 0 ? void 0 : tl.duration) || duration) / timescale * 1000;\n\n            _this.emit('item', {\n              url: baseURL.filter(function (s) {\n                return !!s;\n              }).join('') + node.attributes.media,\n              seq: seq++,\n              duration: segmentDuration\n            });\n\n            currtime += segmentDuration;\n          }\n\n          break;\n      }\n    });\n\n    var onEnd = function onEnd() {\n      if (isStatic) {\n        _this.emit('endlist');\n      }\n\n      if (!getSegments) {\n        _this.destroy(Error(\"Representation '\".concat(targetID, \"' not found\")));\n      } else {\n        _this.emit('end');\n      }\n    };\n\n    _this._parser.on('closetag', function (tagName) {\n      switch (tagName) {\n        case 'adaptationset':\n        case 'representation':\n          treeLevel--;\n\n          if (segmentTemplate && timeline.length) {\n            gotSegments = true;\n\n            if (segmentTemplate.initialization) {\n              _this.emit('item', {\n                url: baseURL.filter(function (s) {\n                  return !!s;\n                }).join('') + tmpl(segmentTemplate.initialization),\n                seq: seq,\n                init: true,\n                duration: 0\n              });\n            }\n\n            var _iterator = _createForOfIteratorHelper(timeline),\n                _step;\n\n            try {\n              for (_iterator.s(); !(_step = _iterator.n()).done;) {\n                var _step$value = _step.value,\n                    itemDuration = _step$value.duration,\n                    repeat = _step$value.repeat,\n                    time = _step$value.time;\n                itemDuration = itemDuration / timescale * 1000;\n                repeat = repeat || 1;\n                currtime = time || currtime;\n\n                for (var i = 0; i < repeat; i++) {\n                  _this.emit('item', {\n                    url: baseURL.filter(function (s) {\n                      return !!s;\n                    }).join('') + tmpl(segmentTemplate.media),\n                    seq: seq++,\n                    duration: itemDuration\n                  });\n\n                  currtime += itemDuration;\n                }\n              }\n            } catch (err) {\n              _iterator.e(err);\n            } finally {\n              _iterator.f();\n            }\n          }\n\n          if (gotSegments) {\n            _this.emit('endearly');\n\n            onEnd();\n\n            _this._parser.removeAllListeners();\n\n            _this.removeAllListeners('finish');\n          }\n\n          break;\n      }\n    });\n\n    _this._parser.on('text', function (text) {\n      if (lastTag === 'baseurl') {\n        baseURL[treeLevel] = text;\n        lastTag = null;\n      }\n    });\n\n    _this.on('finish', onEnd);\n\n    return _this;\n  }\n\n  _createClass(DashMPDParser, [{\n    key: \"_write\",\n    value: function _write(chunk, encoding, callback) {\n      this._parser.write(chunk);\n\n      callback();\n    }\n  }]);\n\n  return DashMPDParser;\n}(stream_1.Writable);\n\nexports[\"default\"] = DashMPDParser;\n\n//# sourceURL=webpack://WorkBox/./node_modules/m3u8stream/dist/dash-mpd-parser.js?");

/***/ }),

/***/ "./node_modules/m3u8stream/dist/index.js":
/*!***********************************************!*\
  !*** ./node_modules/m3u8stream/dist/index.js ***!
  \***********************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval("\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nvar stream_1 = __webpack_require__(Object(function webpackMissingModule() { var e = new Error(\"Cannot find module 'stream'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }()));\n\nvar miniget_1 = __importDefault(__webpack_require__(/*! miniget */ \"./node_modules/miniget/dist/index.js\"));\n\nvar m3u8_parser_1 = __importDefault(__webpack_require__(/*! ./m3u8-parser */ \"./node_modules/m3u8stream/dist/m3u8-parser.js\"));\n\nvar dash_mpd_parser_1 = __importDefault(__webpack_require__(/*! ./dash-mpd-parser */ \"./node_modules/m3u8stream/dist/dash-mpd-parser.js\"));\n\nvar queue_1 = __webpack_require__(/*! ./queue */ \"./node_modules/m3u8stream/dist/queue.js\");\n\nvar parse_time_1 = __webpack_require__(/*! ./parse-time */ \"./node_modules/m3u8stream/dist/parse-time.js\");\n\nvar supportedParsers = {\n  m3u8: m3u8_parser_1.default,\n  'dash-mpd': dash_mpd_parser_1.default\n};\n\nvar m3u8stream = function m3u8stream(playlistURL) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var stream = new stream_1.PassThrough({\n    highWaterMark: options.highWaterMark\n  });\n  var chunkReadahead = options.chunkReadahead || 3; // 20 seconds.\n\n  var liveBuffer = options.liveBuffer || 20000;\n  var requestOptions = options.requestOptions;\n  var Parser = supportedParsers[options.parser || (/\\.mpd$/.test(playlistURL) ? 'dash-mpd' : 'm3u8')];\n\n  if (!Parser) {\n    throw TypeError(\"parser '\".concat(options.parser, \"' not supported\"));\n  }\n\n  var begin = 0;\n\n  if (typeof options.begin !== 'undefined') {\n    begin = typeof options.begin === 'string' ? parse_time_1.humanStr(options.begin) : Math.max(options.begin - liveBuffer, 0);\n  }\n\n  var forwardEvents = function forwardEvents(req) {\n    for (var _i = 0, _arr = ['abort', 'request', 'response', 'redirect', 'retry', 'reconnect']; _i < _arr.length; _i++) {\n      var event = _arr[_i];\n      req.on(event, stream.emit.bind(stream, event));\n    }\n  };\n\n  var currSegment;\n  var streamQueue = new queue_1.Queue(function (req, callback) {\n    currSegment = req; // Count the size manually, since the `content-length` header is not\n    // always there.\n\n    var size = 0;\n    req.on('data', function (chunk) {\n      return size += chunk.length;\n    });\n    req.pipe(stream, {\n      end: false\n    });\n    req.on('end', function () {\n      return callback(null, size);\n    });\n  }, {\n    concurrency: 1\n  });\n  var segmentNumber = 0;\n  var downloaded = 0;\n  var requestQueue = new queue_1.Queue(function (segment, callback) {\n    var reqOptions = Object.assign({}, requestOptions);\n\n    if (segment.range) {\n      reqOptions.headers = Object.assign({}, reqOptions.headers, {\n        Range: \"bytes=\".concat(segment.range.start, \"-\").concat(segment.range.end)\n      });\n    }\n\n    var req = miniget_1.default(new URL(segment.url, playlistURL).toString(), reqOptions);\n    req.on('error', callback);\n    forwardEvents(req);\n    streamQueue.push(req, function (_, size) {\n      downloaded += +size;\n      stream.emit('progress', {\n        num: ++segmentNumber,\n        size: size,\n        duration: segment.duration,\n        url: segment.url\n      }, requestQueue.total, downloaded);\n      callback(null);\n    });\n  }, {\n    concurrency: chunkReadahead\n  });\n\n  var onError = function onError(err) {\n    stream.emit('error', err); // Stop on any error.\n\n    stream.end();\n  }; // When to look for items again.\n\n\n  var refreshThreshold;\n  var minRefreshTime;\n  var refreshTimeout;\n  var fetchingPlaylist = true;\n  var ended = false;\n  var isStatic = false;\n  var lastRefresh;\n\n  var onQueuedEnd = function onQueuedEnd(err) {\n    currSegment = null;\n\n    if (err) {\n      onError(err);\n    } else if (!fetchingPlaylist && !ended && !isStatic && requestQueue.tasks.length + requestQueue.active <= refreshThreshold) {\n      var ms = Math.max(0, minRefreshTime - (Date.now() - lastRefresh));\n      fetchingPlaylist = true;\n      refreshTimeout = setTimeout(refreshPlaylist, ms);\n    } else if ((ended || isStatic) && !requestQueue.tasks.length && !requestQueue.active) {\n      stream.end();\n    }\n  };\n\n  var currPlaylist;\n  var lastSeq;\n  var starttime = 0;\n\n  var refreshPlaylist = function refreshPlaylist() {\n    lastRefresh = Date.now();\n    currPlaylist = miniget_1.default(playlistURL, requestOptions);\n    currPlaylist.on('error', onError);\n    forwardEvents(currPlaylist);\n    var parser = currPlaylist.pipe(new Parser(options.id));\n    parser.on('starttime', function (a) {\n      if (starttime) {\n        return;\n      }\n\n      starttime = a;\n\n      if (typeof options.begin === 'string' && begin >= 0) {\n        begin += starttime;\n      }\n    });\n    parser.on('endlist', function () {\n      isStatic = true;\n    });\n    parser.on('endearly', currPlaylist.unpipe.bind(currPlaylist, parser));\n    var addedItems = [];\n\n    var addItem = function addItem(item) {\n      if (!item.init) {\n        if (item.seq <= lastSeq) {\n          return;\n        }\n\n        lastSeq = item.seq;\n      }\n\n      begin = item.time;\n      requestQueue.push(item, onQueuedEnd);\n      addedItems.push(item);\n    };\n\n    var tailedItems = [],\n        tailedItemsDuration = 0;\n    parser.on('item', function (item) {\n      var timedItem = Object.assign({\n        time: starttime\n      }, item);\n\n      if (begin <= timedItem.time) {\n        addItem(timedItem);\n      } else {\n        tailedItems.push(timedItem);\n        tailedItemsDuration += timedItem.duration; // Only keep the last `liveBuffer` of items.\n\n        while (tailedItems.length > 1 && tailedItemsDuration - tailedItems[0].duration > liveBuffer) {\n          var lastItem = tailedItems.shift();\n          tailedItemsDuration -= lastItem.duration;\n        }\n      }\n\n      starttime += timedItem.duration;\n    });\n    parser.on('end', function () {\n      currPlaylist = null; // If we are too ahead of the stream, make sure to get the\n      // latest available items with a small buffer.\n\n      if (!addedItems.length && tailedItems.length) {\n        tailedItems.forEach(function (item) {\n          addItem(item);\n        });\n      } // Refresh the playlist when remaining segments get low.\n\n\n      refreshThreshold = Math.max(1, Math.ceil(addedItems.length * 0.01)); // Throttle refreshing the playlist by looking at the duration\n      // of live items added on this refresh.\n\n      minRefreshTime = addedItems.reduce(function (total, item) {\n        return item.duration + total;\n      }, 0);\n      fetchingPlaylist = false;\n      onQueuedEnd(null);\n    });\n  };\n\n  refreshPlaylist();\n\n  stream.end = function () {\n    ended = true;\n    streamQueue.die();\n    requestQueue.die();\n    clearTimeout(refreshTimeout);\n    currPlaylist === null || currPlaylist === void 0 ? void 0 : currPlaylist.destroy();\n    currSegment === null || currSegment === void 0 ? void 0 : currSegment.destroy();\n    stream_1.PassThrough.prototype.end.call(stream, null);\n    return stream;\n  };\n\n  return stream;\n};\n\nm3u8stream.parseTimestamp = parse_time_1.humanStr;\nmodule.exports = m3u8stream;\n\n//# sourceURL=webpack://WorkBox/./node_modules/m3u8stream/dist/index.js?");

/***/ }),

/***/ "./node_modules/m3u8stream/dist/m3u8-parser.js":
/*!*****************************************************!*\
  !*** ./node_modules/m3u8stream/dist/m3u8-parser.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } else if (call !== void 0) { throw new TypeError(\"Derived constructors may only return object or undefined\"); } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\n\nvar stream_1 = __webpack_require__(Object(function webpackMissingModule() { var e = new Error(\"Cannot find module 'stream'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }()));\n/**\n * A very simple m3u8 playlist file parser that detects tags and segments.\n */\n\n\nvar m3u8Parser = /*#__PURE__*/function (_stream_1$Writable) {\n  _inherits(m3u8Parser, _stream_1$Writable);\n\n  var _super = _createSuper(m3u8Parser);\n\n  function m3u8Parser() {\n    var _this;\n\n    _classCallCheck(this, m3u8Parser);\n\n    _this = _super.call(this);\n    _this._lastLine = '';\n    _this._seq = 0;\n    _this._nextItemDuration = null;\n    _this._nextItemRange = null;\n    _this._lastItemRangeEnd = 0;\n\n    _this.on('finish', function () {\n      _this._parseLine(_this._lastLine);\n\n      _this.emit('end');\n    });\n\n    return _this;\n  }\n\n  _createClass(m3u8Parser, [{\n    key: \"_parseAttrList\",\n    value: function _parseAttrList(value) {\n      var attrs = {};\n      var regex = /([A-Z0-9-]+)=(?:\"([^\"]*?)\"|([^,]*?))/g;\n      var match;\n\n      while ((match = regex.exec(value)) !== null) {\n        attrs[match[1]] = match[2] || match[3];\n      }\n\n      return attrs;\n    }\n  }, {\n    key: \"_parseRange\",\n    value: function _parseRange(value) {\n      if (!value) return null;\n      var svalue = value.split('@');\n      var start = svalue[1] ? parseInt(svalue[1]) : this._lastItemRangeEnd + 1;\n      var end = start + parseInt(svalue[0]) - 1;\n      var range = {\n        start: start,\n        end: end\n      };\n      this._lastItemRangeEnd = range.end;\n      return range;\n    }\n  }, {\n    key: \"_parseLine\",\n    value: function _parseLine(line) {\n      var match = line.match(/^#(EXT[A-Z0-9-]+)(?::(.*))?/);\n\n      if (match) {\n        // This is a tag.\n        var tag = match[1];\n        var value = match[2] || '';\n\n        switch (tag) {\n          case 'EXT-X-PROGRAM-DATE-TIME':\n            this.emit('starttime', new Date(value).getTime());\n            break;\n\n          case 'EXT-X-MEDIA-SEQUENCE':\n            this._seq = parseInt(value);\n            break;\n\n          case 'EXT-X-MAP':\n            {\n              var attrs = this._parseAttrList(value);\n\n              if (!attrs.URI) {\n                this.destroy(new Error('`EXT-X-MAP` found without required attribute `URI`'));\n                return;\n              }\n\n              this.emit('item', {\n                url: attrs.URI,\n                seq: this._seq,\n                init: true,\n                duration: 0,\n                range: this._parseRange(attrs.BYTERANGE)\n              });\n              break;\n            }\n\n          case 'EXT-X-BYTERANGE':\n            {\n              this._nextItemRange = this._parseRange(value);\n              break;\n            }\n\n          case 'EXTINF':\n            this._nextItemDuration = Math.round(parseFloat(value.split(',')[0]) * 1000);\n            break;\n\n          case 'EXT-X-ENDLIST':\n            this.emit('endlist');\n            break;\n        }\n      } else if (!/^#/.test(line) && line.trim()) {\n        // This is a segment\n        this.emit('item', {\n          url: line.trim(),\n          seq: this._seq++,\n          duration: this._nextItemDuration,\n          range: this._nextItemRange\n        });\n        this._nextItemRange = null;\n      }\n    }\n  }, {\n    key: \"_write\",\n    value: function _write(chunk, encoding, callback) {\n      var _this2 = this;\n\n      var lines = chunk.toString('utf8').split('\\n');\n\n      if (this._lastLine) {\n        lines[0] = this._lastLine + lines[0];\n      }\n\n      lines.forEach(function (line, i) {\n        if (_this2.destroyed) return;\n\n        if (i < lines.length - 1) {\n          _this2._parseLine(line);\n        } else {\n          // Save the last line in case it has been broken up.\n          _this2._lastLine = line;\n        }\n      });\n      callback();\n    }\n  }]);\n\n  return m3u8Parser;\n}(stream_1.Writable);\n\nexports[\"default\"] = m3u8Parser;\n\n//# sourceURL=webpack://WorkBox/./node_modules/m3u8stream/dist/m3u8-parser.js?");

/***/ }),

/***/ "./node_modules/m3u8stream/dist/parse-time.js":
/*!****************************************************!*\
  !*** ./node_modules/m3u8stream/dist/parse-time.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.durationStr = exports.humanStr = void 0;\nvar numberFormat = /^\\d+$/;\nvar timeFormat = /^(?:(?:(\\d+):)?(\\d{1,2}):)?(\\d{1,2})(?:\\.(\\d{3}))?$/;\nvar timeUnits = {\n  ms: 1,\n  s: 1000,\n  m: 60000,\n  h: 3600000\n};\n/**\n * Converts human friendly time to milliseconds. Supports the format\n * 00:00:00.000 for hours, minutes, seconds, and milliseconds respectively.\n * And 0ms, 0s, 0m, 0h, and together 1m1s.\n *\n * @param {number|string} time\n * @returns {number}\n */\n\nexports.humanStr = function (time) {\n  if (typeof time === 'number') {\n    return time;\n  }\n\n  if (numberFormat.test(time)) {\n    return +time;\n  }\n\n  var firstFormat = timeFormat.exec(time);\n\n  if (firstFormat) {\n    return +(firstFormat[1] || 0) * timeUnits.h + +(firstFormat[2] || 0) * timeUnits.m + +firstFormat[3] * timeUnits.s + +(firstFormat[4] || 0);\n  } else {\n    var total = 0;\n    var r = /(-?\\d+)(ms|s|m|h)/g;\n    var rs;\n\n    while ((rs = r.exec(time)) !== null) {\n      total += +rs[1] * timeUnits[rs[2]];\n    }\n\n    return total;\n  }\n};\n/**\n * Parses a duration string in the form of \"123.456S\", returns milliseconds.\n *\n * @param {string} time\n * @returns {number}\n */\n\n\nexports.durationStr = function (time) {\n  var total = 0;\n  var r = /(\\d+(?:\\.\\d+)?)(S|M|H)/g;\n  var rs;\n\n  while ((rs = r.exec(time)) !== null) {\n    total += +rs[1] * timeUnits[rs[2].toLowerCase()];\n  }\n\n  return total;\n};\n\n//# sourceURL=webpack://WorkBox/./node_modules/m3u8stream/dist/parse-time.js?");

/***/ }),

/***/ "./node_modules/m3u8stream/dist/queue.js":
/*!***********************************************!*\
  !*** ./node_modules/m3u8stream/dist/queue.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.Queue = void 0;\n\nvar Queue = /*#__PURE__*/function () {\n  /**\n   * A really simple queue with concurrency.\n   *\n   * @param {Function} worker\n   * @param {Object} options\n   * @param {!number} options.concurrency\n   */\n  function Queue(worker) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    _classCallCheck(this, Queue);\n\n    this._worker = worker;\n    this._concurrency = options.concurrency || 1;\n    this.tasks = [];\n    this.total = 0;\n    this.active = 0;\n  }\n  /**\n   * Push a task to the queue.\n   *\n   *  @param {T} item\n   *  @param {!Function} callback\n   */\n\n\n  _createClass(Queue, [{\n    key: \"push\",\n    value: function push(item, callback) {\n      this.tasks.push({\n        item: item,\n        callback: callback\n      });\n      this.total++;\n\n      this._next();\n    }\n    /**\n     * Process next job in queue.\n     */\n\n  }, {\n    key: \"_next\",\n    value: function _next() {\n      var _this = this;\n\n      if (this.active >= this._concurrency || !this.tasks.length) {\n        return;\n      }\n\n      var _this$tasks$shift = this.tasks.shift(),\n          item = _this$tasks$shift.item,\n          callback = _this$tasks$shift.callback;\n\n      var callbackCalled = false;\n      this.active++;\n\n      this._worker(item, function (err, result) {\n        if (callbackCalled) {\n          return;\n        }\n\n        _this.active--;\n        callbackCalled = true;\n        callback === null || callback === void 0 ? void 0 : callback(err, result);\n\n        _this._next();\n      });\n    }\n    /**\n     * Stops processing queued jobs.\n     */\n\n  }, {\n    key: \"die\",\n    value: function die() {\n      this.tasks = [];\n    }\n  }]);\n\n  return Queue;\n}();\n\nexports.Queue = Queue;\n\n//# sourceURL=webpack://WorkBox/./node_modules/m3u8stream/dist/queue.js?");

/***/ }),

/***/ "./node_modules/miniget/dist/index.js":
/*!********************************************!*\
  !*** ./node_modules/miniget/dist/index.js ***!
  \********************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval("\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }\n\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _iterableToArray(iter) { if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter); }\n\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } else if (call !== void 0) { throw new TypeError(\"Derived constructors may only return object or undefined\"); } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _wrapNativeSuper(Class) { var _cache = typeof Map === \"function\" ? new Map() : undefined; _wrapNativeSuper = function _wrapNativeSuper(Class) { if (Class === null || !_isNativeFunction(Class)) return Class; if (typeof Class !== \"function\") { throw new TypeError(\"Super expression must either be null or a function\"); } if (typeof _cache !== \"undefined\") { if (_cache.has(Class)) return _cache.get(Class); _cache.set(Class, Wrapper); } function Wrapper() { return _construct(Class, arguments, _getPrototypeOf(this).constructor); } Wrapper.prototype = Object.create(Class.prototype, { constructor: { value: Wrapper, enumerable: false, writable: true, configurable: true } }); return _setPrototypeOf(Wrapper, Class); }; return _wrapNativeSuper(Class); }\n\nfunction _construct(Parent, args, Class) { if (_isNativeReflectConstruct()) { _construct = Reflect.construct; } else { _construct = function _construct(Parent, args, Class) { var a = [null]; a.push.apply(a, args); var Constructor = Function.bind.apply(Parent, a); var instance = new Constructor(); if (Class) _setPrototypeOf(instance, Class.prototype); return instance; }; } return _construct.apply(null, arguments); }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _isNativeFunction(fn) { return Function.toString.call(fn).indexOf(\"[native code]\") !== -1; }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nvar http_1 = __importDefault(__webpack_require__(Object(function webpackMissingModule() { var e = new Error(\"Cannot find module 'http'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }())));\n\nvar https_1 = __importDefault(__webpack_require__(Object(function webpackMissingModule() { var e = new Error(\"Cannot find module 'https'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }())));\n\nvar stream_1 = __webpack_require__(Object(function webpackMissingModule() { var e = new Error(\"Cannot find module 'stream'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }()));\n\nvar httpLibs = {\n  'http:': http_1.default,\n  'https:': https_1.default\n};\nvar redirectStatusCodes = new Set([301, 302, 303, 307, 308]);\nvar retryStatusCodes = new Set([429, 503]); // `request`, `response`, `abort`, left out, miniget will emit these.\n\nvar requestEvents = ['connect', 'continue', 'information', 'socket', 'timeout', 'upgrade'];\nvar responseEvents = ['aborted'];\n\nMiniget.MinigetError = /*#__PURE__*/function (_Error) {\n  _inherits(MinigetError, _Error);\n\n  var _super = _createSuper(MinigetError);\n\n  function MinigetError(message, statusCode) {\n    var _this;\n\n    _classCallCheck(this, MinigetError);\n\n    _this = _super.call(this, message);\n    _this.statusCode = statusCode;\n    return _this;\n  }\n\n  return MinigetError;\n}( /*#__PURE__*/_wrapNativeSuper(Error));\n\nMiniget.defaultOptions = {\n  maxRedirects: 10,\n  maxRetries: 2,\n  maxReconnects: 0,\n  backoff: {\n    inc: 100,\n    max: 10000\n  }\n};\n\nfunction Miniget(url) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n  var _a;\n\n  var opts = Object.assign({}, Miniget.defaultOptions, options);\n  var stream = new stream_1.PassThrough({\n    highWaterMark: opts.highWaterMark\n  });\n  stream.destroyed = stream.aborted = false;\n  var activeRequest;\n  var activeResponse;\n  var activeDecodedStream;\n  var redirects = 0;\n  var retries = 0;\n  var retryTimeout;\n  var reconnects = 0;\n  var contentLength;\n  var acceptRanges = false;\n  var rangeStart = 0,\n      rangeEnd;\n  var downloaded = 0; // Check if this is a ranged request.\n\n  if ((_a = opts.headers) === null || _a === void 0 ? void 0 : _a.Range) {\n    var r = /bytes=(\\d+)-(\\d+)?/.exec(\"\".concat(opts.headers.Range));\n\n    if (r) {\n      rangeStart = parseInt(r[1], 10);\n      rangeEnd = parseInt(r[2], 10);\n    }\n  } // Add `Accept-Encoding` header.\n\n\n  if (opts.acceptEncoding) {\n    opts.headers = Object.assign({\n      'Accept-Encoding': Object.keys(opts.acceptEncoding).join(', ')\n    }, opts.headers);\n  }\n\n  var downloadHasStarted = function downloadHasStarted() {\n    return activeDecodedStream && downloaded > 0;\n  };\n\n  var downloadComplete = function downloadComplete() {\n    return !acceptRanges || downloaded === contentLength;\n  };\n\n  var reconnect = function reconnect(err) {\n    activeDecodedStream = null;\n    retries = 0;\n    var inc = opts.backoff.inc;\n    var ms = Math.min(inc, opts.backoff.max);\n    retryTimeout = setTimeout(doDownload, ms);\n    stream.emit('reconnect', reconnects, err);\n  };\n\n  var reconnectIfEndedEarly = function reconnectIfEndedEarly(err) {\n    if (options.method !== 'HEAD' && !downloadComplete() && reconnects++ < opts.maxReconnects) {\n      reconnect(err);\n      return true;\n    }\n\n    return false;\n  };\n\n  var retryRequest = function retryRequest(retryOptions) {\n    if (stream.destroyed) {\n      return false;\n    }\n\n    if (downloadHasStarted()) {\n      return reconnectIfEndedEarly(retryOptions.err);\n    } else if ((!retryOptions.err || retryOptions.err.message === 'ENOTFOUND') && retries++ < opts.maxRetries) {\n      var ms = retryOptions.retryAfter || Math.min(retries * opts.backoff.inc, opts.backoff.max);\n      retryTimeout = setTimeout(doDownload, ms);\n      stream.emit('retry', retries, retryOptions.err);\n      return true;\n    }\n\n    return false;\n  };\n\n  var forwardEvents = function forwardEvents(ee, events) {\n    var _iterator = _createForOfIteratorHelper(events),\n        _step;\n\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var event = _step.value;\n        ee.on(event, stream.emit.bind(stream, event));\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n  };\n\n  var doDownload = function doDownload() {\n    var parsed = {},\n        httpLib;\n\n    try {\n      var urlObj = typeof url === 'string' ? new URL(url) : url;\n      parsed = Object.assign({}, {\n        host: urlObj.host,\n        hostname: urlObj.hostname,\n        path: urlObj.pathname + urlObj.search + urlObj.hash,\n        port: urlObj.port,\n        protocol: urlObj.protocol\n      });\n\n      if (urlObj.username) {\n        parsed.auth = \"\".concat(urlObj.username, \":\").concat(urlObj.password);\n      }\n\n      httpLib = httpLibs[String(parsed.protocol)];\n    } catch (err) {// Let the error be caught by the if statement below.\n    }\n\n    if (!httpLib) {\n      stream.emit('error', new Miniget.MinigetError(\"Invalid URL: \".concat(url)));\n      return;\n    }\n\n    Object.assign(parsed, opts);\n\n    if (acceptRanges && downloaded > 0) {\n      var start = downloaded + rangeStart;\n      var end = rangeEnd || '';\n      parsed.headers = Object.assign({}, parsed.headers, {\n        Range: \"bytes=\".concat(start, \"-\").concat(end)\n      });\n    }\n\n    if (opts.transform) {\n      try {\n        parsed = opts.transform(parsed);\n      } catch (err) {\n        stream.emit('error', err);\n        return;\n      }\n\n      if (!parsed || parsed.protocol) {\n        httpLib = httpLibs[String(parsed === null || parsed === void 0 ? void 0 : parsed.protocol)];\n\n        if (!httpLib) {\n          stream.emit('error', new Miniget.MinigetError('Invalid URL object from `transform` function'));\n          return;\n        }\n      }\n    }\n\n    var onError = function onError(err) {\n      if (stream.destroyed || stream.readableEnded) {\n        return;\n      }\n\n      cleanup();\n\n      if (!retryRequest({\n        err: err\n      })) {\n        stream.emit('error', err);\n      } else {\n        activeRequest.removeListener('close', onRequestClose);\n      }\n    };\n\n    var onRequestClose = function onRequestClose() {\n      cleanup();\n      retryRequest({});\n    };\n\n    var cleanup = function cleanup() {\n      activeRequest.removeListener('close', onRequestClose);\n      activeResponse === null || activeResponse === void 0 ? void 0 : activeResponse.removeListener('data', onData);\n      activeDecodedStream === null || activeDecodedStream === void 0 ? void 0 : activeDecodedStream.removeListener('end', onEnd);\n    };\n\n    var onData = function onData(chunk) {\n      downloaded += chunk.length;\n    };\n\n    var onEnd = function onEnd() {\n      cleanup();\n\n      if (!reconnectIfEndedEarly()) {\n        stream.end();\n      }\n    };\n\n    activeRequest = httpLib.request(parsed, function (res) {\n      // Needed for node v10, v12.\n      // istanbul ignore next\n      if (stream.destroyed) {\n        return;\n      }\n\n      if (redirectStatusCodes.has(res.statusCode)) {\n        if (redirects++ >= opts.maxRedirects) {\n          stream.emit('error', new Miniget.MinigetError('Too many redirects'));\n        } else {\n          if (res.headers.location) {\n            url = res.headers.location;\n          } else {\n            var err = new Miniget.MinigetError('Redirect status code given with no location', res.statusCode);\n            stream.emit('error', err);\n            cleanup();\n            return;\n          }\n\n          setTimeout(doDownload, parseInt(res.headers['retry-after'] || '0', 10) * 1000);\n          stream.emit('redirect', url);\n        }\n\n        cleanup();\n        return; // Check for rate limiting.\n      } else if (retryStatusCodes.has(res.statusCode)) {\n        if (!retryRequest({\n          retryAfter: parseInt(res.headers['retry-after'] || '0', 10)\n        })) {\n          var _err = new Miniget.MinigetError(\"Status code: \".concat(res.statusCode), res.statusCode);\n\n          stream.emit('error', _err);\n        }\n\n        cleanup();\n        return;\n      } else if (res.statusCode && (res.statusCode < 200 || res.statusCode >= 400)) {\n        var _err2 = new Miniget.MinigetError(\"Status code: \".concat(res.statusCode), res.statusCode);\n\n        if (res.statusCode >= 500) {\n          onError(_err2);\n        } else {\n          stream.emit('error', _err2);\n        }\n\n        cleanup();\n        return;\n      }\n\n      activeDecodedStream = res;\n\n      if (opts.acceptEncoding && res.headers['content-encoding']) {\n        var _iterator2 = _createForOfIteratorHelper(res.headers['content-encoding'].split(', ').reverse()),\n            _step2;\n\n        try {\n          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n            var enc = _step2.value;\n            var fn = opts.acceptEncoding[enc];\n\n            if (fn) {\n              activeDecodedStream = activeDecodedStream.pipe(fn());\n              activeDecodedStream.on('error', onError);\n            }\n          }\n        } catch (err) {\n          _iterator2.e(err);\n        } finally {\n          _iterator2.f();\n        }\n      }\n\n      if (!contentLength) {\n        contentLength = parseInt(\"\".concat(res.headers['content-length']), 10);\n        acceptRanges = res.headers['accept-ranges'] === 'bytes' && contentLength > 0 && opts.maxReconnects > 0;\n      }\n\n      res.on('data', onData);\n      activeDecodedStream.on('end', onEnd);\n      activeDecodedStream.pipe(stream, {\n        end: !acceptRanges\n      });\n      activeResponse = res;\n      stream.emit('response', res);\n      res.on('error', onError);\n      forwardEvents(res, responseEvents);\n    });\n    activeRequest.on('error', onError);\n    activeRequest.on('close', onRequestClose);\n    forwardEvents(activeRequest, requestEvents);\n\n    if (stream.destroyed) {\n      streamDestroy.apply(void 0, _toConsumableArray(destroyArgs));\n    }\n\n    stream.emit('request', activeRequest);\n    activeRequest.end();\n  };\n\n  stream.abort = function (err) {\n    console.warn('`MinigetStream#abort()` has been deprecated in favor of `MinigetStream#destroy()`');\n    stream.aborted = true;\n    stream.emit('abort');\n    stream.destroy(err);\n  };\n\n  var destroyArgs;\n\n  var streamDestroy = function streamDestroy(err) {\n    activeRequest.destroy(err);\n    activeDecodedStream === null || activeDecodedStream === void 0 ? void 0 : activeDecodedStream.unpipe(stream);\n    activeDecodedStream === null || activeDecodedStream === void 0 ? void 0 : activeDecodedStream.destroy();\n    clearTimeout(retryTimeout);\n  };\n\n  stream._destroy = function () {\n    stream.destroyed = true;\n\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    if (activeRequest) {\n      streamDestroy.apply(void 0, args);\n    } else {\n      destroyArgs = args;\n    }\n  };\n\n  stream.text = function () {\n    return new Promise(function (resolve, reject) {\n      var body = '';\n      stream.setEncoding('utf8');\n      stream.on('data', function (chunk) {\n        return body += chunk;\n      });\n      stream.on('end', function () {\n        return resolve(body);\n      });\n      stream.on('error', reject);\n    });\n  };\n\n  process.nextTick(doDownload);\n  return stream;\n}\n\nmodule.exports = Miniget;\n\n//# sourceURL=webpack://WorkBox/./node_modules/miniget/dist/index.js?");

/***/ }),

/***/ "./node_modules/regenerator-runtime/runtime.js":
/*!*****************************************************!*\
  !*** ./node_modules/regenerator-runtime/runtime.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/* module decorator */ module = __webpack_require__.nmd(module);\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\n/**\n * Copyright (c) 2014-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nvar runtime = function (exports) {\n  \"use strict\";\n\n  var Op = Object.prototype;\n  var hasOwn = Op.hasOwnProperty;\n  var undefined; // More compressible than void 0.\n\n  var $Symbol = typeof Symbol === \"function\" ? Symbol : {};\n  var iteratorSymbol = $Symbol.iterator || \"@@iterator\";\n  var asyncIteratorSymbol = $Symbol.asyncIterator || \"@@asyncIterator\";\n  var toStringTagSymbol = $Symbol.toStringTag || \"@@toStringTag\";\n\n  function define(obj, key, value) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n    return obj[key];\n  }\n\n  try {\n    // IE 8 has a broken Object.defineProperty that only works on DOM objects.\n    define({}, \"\");\n  } catch (err) {\n    define = function define(obj, key, value) {\n      return obj[key] = value;\n    };\n  }\n\n  function wrap(innerFn, outerFn, self, tryLocsList) {\n    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.\n    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;\n    var generator = Object.create(protoGenerator.prototype);\n    var context = new Context(tryLocsList || []); // The ._invoke method unifies the implementations of the .next,\n    // .throw, and .return methods.\n\n    generator._invoke = makeInvokeMethod(innerFn, self, context);\n    return generator;\n  }\n\n  exports.wrap = wrap; // Try/catch helper to minimize deoptimizations. Returns a completion\n  // record like context.tryEntries[i].completion. This interface could\n  // have been (and was previously) designed to take a closure to be\n  // invoked without arguments, but in all the cases we care about we\n  // already have an existing method we want to call, so there's no need\n  // to create a new function object. We can even get away with assuming\n  // the method takes exactly one argument, since that happens to be true\n  // in every case, so we don't have to touch the arguments object. The\n  // only additional allocation required is the completion record, which\n  // has a stable shape and so hopefully should be cheap to allocate.\n\n  function tryCatch(fn, obj, arg) {\n    try {\n      return {\n        type: \"normal\",\n        arg: fn.call(obj, arg)\n      };\n    } catch (err) {\n      return {\n        type: \"throw\",\n        arg: err\n      };\n    }\n  }\n\n  var GenStateSuspendedStart = \"suspendedStart\";\n  var GenStateSuspendedYield = \"suspendedYield\";\n  var GenStateExecuting = \"executing\";\n  var GenStateCompleted = \"completed\"; // Returning this object from the innerFn has the same effect as\n  // breaking out of the dispatch switch statement.\n\n  var ContinueSentinel = {}; // Dummy constructor functions that we use as the .constructor and\n  // .constructor.prototype properties for functions that return Generator\n  // objects. For full spec compliance, you may wish to configure your\n  // minifier not to mangle the names of these two functions.\n\n  function Generator() {}\n\n  function GeneratorFunction() {}\n\n  function GeneratorFunctionPrototype() {} // This is a polyfill for %IteratorPrototype% for environments that\n  // don't natively support it.\n\n\n  var IteratorPrototype = {};\n  define(IteratorPrototype, iteratorSymbol, function () {\n    return this;\n  });\n  var getProto = Object.getPrototypeOf;\n  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));\n\n  if (NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {\n    // This environment has a native %IteratorPrototype%; use it instead\n    // of the polyfill.\n    IteratorPrototype = NativeIteratorPrototype;\n  }\n\n  var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype);\n  GeneratorFunction.prototype = GeneratorFunctionPrototype;\n  define(Gp, \"constructor\", GeneratorFunctionPrototype);\n  define(GeneratorFunctionPrototype, \"constructor\", GeneratorFunction);\n  GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, \"GeneratorFunction\"); // Helper for defining the .next, .throw, and .return methods of the\n  // Iterator interface in terms of a single ._invoke method.\n\n  function defineIteratorMethods(prototype) {\n    [\"next\", \"throw\", \"return\"].forEach(function (method) {\n      define(prototype, method, function (arg) {\n        return this._invoke(method, arg);\n      });\n    });\n  }\n\n  exports.isGeneratorFunction = function (genFun) {\n    var ctor = typeof genFun === \"function\" && genFun.constructor;\n    return ctor ? ctor === GeneratorFunction || // For the native GeneratorFunction constructor, the best we can\n    // do is to check its .name property.\n    (ctor.displayName || ctor.name) === \"GeneratorFunction\" : false;\n  };\n\n  exports.mark = function (genFun) {\n    if (Object.setPrototypeOf) {\n      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);\n    } else {\n      genFun.__proto__ = GeneratorFunctionPrototype;\n      define(genFun, toStringTagSymbol, \"GeneratorFunction\");\n    }\n\n    genFun.prototype = Object.create(Gp);\n    return genFun;\n  }; // Within the body of any async function, `await x` is transformed to\n  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test\n  // `hasOwn.call(value, \"__await\")` to determine if the yielded value is\n  // meant to be awaited.\n\n\n  exports.awrap = function (arg) {\n    return {\n      __await: arg\n    };\n  };\n\n  function AsyncIterator(generator, PromiseImpl) {\n    function invoke(method, arg, resolve, reject) {\n      var record = tryCatch(generator[method], generator, arg);\n\n      if (record.type === \"throw\") {\n        reject(record.arg);\n      } else {\n        var result = record.arg;\n        var value = result.value;\n\n        if (value && _typeof(value) === \"object\" && hasOwn.call(value, \"__await\")) {\n          return PromiseImpl.resolve(value.__await).then(function (value) {\n            invoke(\"next\", value, resolve, reject);\n          }, function (err) {\n            invoke(\"throw\", err, resolve, reject);\n          });\n        }\n\n        return PromiseImpl.resolve(value).then(function (unwrapped) {\n          // When a yielded Promise is resolved, its final value becomes\n          // the .value of the Promise<{value,done}> result for the\n          // current iteration.\n          result.value = unwrapped;\n          resolve(result);\n        }, function (error) {\n          // If a rejected Promise was yielded, throw the rejection back\n          // into the async generator function so it can be handled there.\n          return invoke(\"throw\", error, resolve, reject);\n        });\n      }\n    }\n\n    var previousPromise;\n\n    function enqueue(method, arg) {\n      function callInvokeWithMethodAndArg() {\n        return new PromiseImpl(function (resolve, reject) {\n          invoke(method, arg, resolve, reject);\n        });\n      }\n\n      return previousPromise = // If enqueue has been called before, then we want to wait until\n      // all previous Promises have been resolved before calling invoke,\n      // so that results are always delivered in the correct order. If\n      // enqueue has not been called before, then it is important to\n      // call invoke immediately, without waiting on a callback to fire,\n      // so that the async generator function has the opportunity to do\n      // any necessary setup in a predictable way. This predictability\n      // is why the Promise constructor synchronously invokes its\n      // executor callback, and why async functions synchronously\n      // execute code before the first await. Since we implement simple\n      // async functions in terms of async generators, it is especially\n      // important to get this right, even though it requires care.\n      previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, // Avoid propagating failures to Promises returned by later\n      // invocations of the iterator.\n      callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();\n    } // Define the unified helper method that is used to implement .next,\n    // .throw, and .return (see defineIteratorMethods).\n\n\n    this._invoke = enqueue;\n  }\n\n  defineIteratorMethods(AsyncIterator.prototype);\n  define(AsyncIterator.prototype, asyncIteratorSymbol, function () {\n    return this;\n  });\n  exports.AsyncIterator = AsyncIterator; // Note that simple async functions are implemented on top of\n  // AsyncIterator objects; they just return a Promise for the value of\n  // the final result produced by the iterator.\n\n  exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) {\n    if (PromiseImpl === void 0) PromiseImpl = Promise;\n    var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl);\n    return exports.isGeneratorFunction(outerFn) ? iter // If outerFn is a generator, return the full iterator.\n    : iter.next().then(function (result) {\n      return result.done ? result.value : iter.next();\n    });\n  };\n\n  function makeInvokeMethod(innerFn, self, context) {\n    var state = GenStateSuspendedStart;\n    return function invoke(method, arg) {\n      if (state === GenStateExecuting) {\n        throw new Error(\"Generator is already running\");\n      }\n\n      if (state === GenStateCompleted) {\n        if (method === \"throw\") {\n          throw arg;\n        } // Be forgiving, per 25.3.3.3.3 of the spec:\n        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume\n\n\n        return doneResult();\n      }\n\n      context.method = method;\n      context.arg = arg;\n\n      while (true) {\n        var delegate = context.delegate;\n\n        if (delegate) {\n          var delegateResult = maybeInvokeDelegate(delegate, context);\n\n          if (delegateResult) {\n            if (delegateResult === ContinueSentinel) continue;\n            return delegateResult;\n          }\n        }\n\n        if (context.method === \"next\") {\n          // Setting context._sent for legacy support of Babel's\n          // function.sent implementation.\n          context.sent = context._sent = context.arg;\n        } else if (context.method === \"throw\") {\n          if (state === GenStateSuspendedStart) {\n            state = GenStateCompleted;\n            throw context.arg;\n          }\n\n          context.dispatchException(context.arg);\n        } else if (context.method === \"return\") {\n          context.abrupt(\"return\", context.arg);\n        }\n\n        state = GenStateExecuting;\n        var record = tryCatch(innerFn, self, context);\n\n        if (record.type === \"normal\") {\n          // If an exception is thrown from innerFn, we leave state ===\n          // GenStateExecuting and loop back for another invocation.\n          state = context.done ? GenStateCompleted : GenStateSuspendedYield;\n\n          if (record.arg === ContinueSentinel) {\n            continue;\n          }\n\n          return {\n            value: record.arg,\n            done: context.done\n          };\n        } else if (record.type === \"throw\") {\n          state = GenStateCompleted; // Dispatch the exception by looping back around to the\n          // context.dispatchException(context.arg) call above.\n\n          context.method = \"throw\";\n          context.arg = record.arg;\n        }\n      }\n    };\n  } // Call delegate.iterator[context.method](context.arg) and handle the\n  // result, either by returning a { value, done } result from the\n  // delegate iterator, or by modifying context.method and context.arg,\n  // setting context.delegate to null, and returning the ContinueSentinel.\n\n\n  function maybeInvokeDelegate(delegate, context) {\n    var method = delegate.iterator[context.method];\n\n    if (method === undefined) {\n      // A .throw or .return when the delegate iterator has no .throw\n      // method always terminates the yield* loop.\n      context.delegate = null;\n\n      if (context.method === \"throw\") {\n        // Note: [\"return\"] must be used for ES3 parsing compatibility.\n        if (delegate.iterator[\"return\"]) {\n          // If the delegate iterator has a return method, give it a\n          // chance to clean up.\n          context.method = \"return\";\n          context.arg = undefined;\n          maybeInvokeDelegate(delegate, context);\n\n          if (context.method === \"throw\") {\n            // If maybeInvokeDelegate(context) changed context.method from\n            // \"return\" to \"throw\", let that override the TypeError below.\n            return ContinueSentinel;\n          }\n        }\n\n        context.method = \"throw\";\n        context.arg = new TypeError(\"The iterator does not provide a 'throw' method\");\n      }\n\n      return ContinueSentinel;\n    }\n\n    var record = tryCatch(method, delegate.iterator, context.arg);\n\n    if (record.type === \"throw\") {\n      context.method = \"throw\";\n      context.arg = record.arg;\n      context.delegate = null;\n      return ContinueSentinel;\n    }\n\n    var info = record.arg;\n\n    if (!info) {\n      context.method = \"throw\";\n      context.arg = new TypeError(\"iterator result is not an object\");\n      context.delegate = null;\n      return ContinueSentinel;\n    }\n\n    if (info.done) {\n      // Assign the result of the finished delegate to the temporary\n      // variable specified by delegate.resultName (see delegateYield).\n      context[delegate.resultName] = info.value; // Resume execution at the desired location (see delegateYield).\n\n      context.next = delegate.nextLoc; // If context.method was \"throw\" but the delegate handled the\n      // exception, let the outer generator proceed normally. If\n      // context.method was \"next\", forget context.arg since it has been\n      // \"consumed\" by the delegate iterator. If context.method was\n      // \"return\", allow the original .return call to continue in the\n      // outer generator.\n\n      if (context.method !== \"return\") {\n        context.method = \"next\";\n        context.arg = undefined;\n      }\n    } else {\n      // Re-yield the result returned by the delegate method.\n      return info;\n    } // The delegate iterator is finished, so forget it and continue with\n    // the outer generator.\n\n\n    context.delegate = null;\n    return ContinueSentinel;\n  } // Define Generator.prototype.{next,throw,return} in terms of the\n  // unified ._invoke helper method.\n\n\n  defineIteratorMethods(Gp);\n  define(Gp, toStringTagSymbol, \"Generator\"); // A Generator should always return itself as the iterator object when the\n  // @@iterator function is called on it. Some browsers' implementations of the\n  // iterator prototype chain incorrectly implement this, causing the Generator\n  // object to not be returned from this call. This ensures that doesn't happen.\n  // See https://github.com/facebook/regenerator/issues/274 for more details.\n\n  define(Gp, iteratorSymbol, function () {\n    return this;\n  });\n  define(Gp, \"toString\", function () {\n    return \"[object Generator]\";\n  });\n\n  function pushTryEntry(locs) {\n    var entry = {\n      tryLoc: locs[0]\n    };\n\n    if (1 in locs) {\n      entry.catchLoc = locs[1];\n    }\n\n    if (2 in locs) {\n      entry.finallyLoc = locs[2];\n      entry.afterLoc = locs[3];\n    }\n\n    this.tryEntries.push(entry);\n  }\n\n  function resetTryEntry(entry) {\n    var record = entry.completion || {};\n    record.type = \"normal\";\n    delete record.arg;\n    entry.completion = record;\n  }\n\n  function Context(tryLocsList) {\n    // The root entry object (effectively a try statement without a catch\n    // or a finally block) gives us a place to store values thrown from\n    // locations where there is no enclosing try statement.\n    this.tryEntries = [{\n      tryLoc: \"root\"\n    }];\n    tryLocsList.forEach(pushTryEntry, this);\n    this.reset(true);\n  }\n\n  exports.keys = function (object) {\n    var keys = [];\n\n    for (var key in object) {\n      keys.push(key);\n    }\n\n    keys.reverse(); // Rather than returning an object with a next method, we keep\n    // things simple and return the next function itself.\n\n    return function next() {\n      while (keys.length) {\n        var key = keys.pop();\n\n        if (key in object) {\n          next.value = key;\n          next.done = false;\n          return next;\n        }\n      } // To avoid creating an additional object, we just hang the .value\n      // and .done properties off the next function object itself. This\n      // also ensures that the minifier will not anonymize the function.\n\n\n      next.done = true;\n      return next;\n    };\n  };\n\n  function values(iterable) {\n    if (iterable) {\n      var iteratorMethod = iterable[iteratorSymbol];\n\n      if (iteratorMethod) {\n        return iteratorMethod.call(iterable);\n      }\n\n      if (typeof iterable.next === \"function\") {\n        return iterable;\n      }\n\n      if (!isNaN(iterable.length)) {\n        var i = -1,\n            next = function next() {\n          while (++i < iterable.length) {\n            if (hasOwn.call(iterable, i)) {\n              next.value = iterable[i];\n              next.done = false;\n              return next;\n            }\n          }\n\n          next.value = undefined;\n          next.done = true;\n          return next;\n        };\n\n        return next.next = next;\n      }\n    } // Return an iterator with no values.\n\n\n    return {\n      next: doneResult\n    };\n  }\n\n  exports.values = values;\n\n  function doneResult() {\n    return {\n      value: undefined,\n      done: true\n    };\n  }\n\n  Context.prototype = {\n    constructor: Context,\n    reset: function reset(skipTempReset) {\n      this.prev = 0;\n      this.next = 0; // Resetting context._sent for legacy support of Babel's\n      // function.sent implementation.\n\n      this.sent = this._sent = undefined;\n      this.done = false;\n      this.delegate = null;\n      this.method = \"next\";\n      this.arg = undefined;\n      this.tryEntries.forEach(resetTryEntry);\n\n      if (!skipTempReset) {\n        for (var name in this) {\n          // Not sure about the optimal order of these conditions:\n          if (name.charAt(0) === \"t\" && hasOwn.call(this, name) && !isNaN(+name.slice(1))) {\n            this[name] = undefined;\n          }\n        }\n      }\n    },\n    stop: function stop() {\n      this.done = true;\n      var rootEntry = this.tryEntries[0];\n      var rootRecord = rootEntry.completion;\n\n      if (rootRecord.type === \"throw\") {\n        throw rootRecord.arg;\n      }\n\n      return this.rval;\n    },\n    dispatchException: function dispatchException(exception) {\n      if (this.done) {\n        throw exception;\n      }\n\n      var context = this;\n\n      function handle(loc, caught) {\n        record.type = \"throw\";\n        record.arg = exception;\n        context.next = loc;\n\n        if (caught) {\n          // If the dispatched exception was caught by a catch block,\n          // then let that catch block handle the exception normally.\n          context.method = \"next\";\n          context.arg = undefined;\n        }\n\n        return !!caught;\n      }\n\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        var record = entry.completion;\n\n        if (entry.tryLoc === \"root\") {\n          // Exception thrown outside of any try block that could handle\n          // it, so set the completion value of the entire function to\n          // throw the exception.\n          return handle(\"end\");\n        }\n\n        if (entry.tryLoc <= this.prev) {\n          var hasCatch = hasOwn.call(entry, \"catchLoc\");\n          var hasFinally = hasOwn.call(entry, \"finallyLoc\");\n\n          if (hasCatch && hasFinally) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            } else if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n          } else if (hasCatch) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            }\n          } else if (hasFinally) {\n            if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n          } else {\n            throw new Error(\"try statement without catch or finally\");\n          }\n        }\n      }\n    },\n    abrupt: function abrupt(type, arg) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n\n        if (entry.tryLoc <= this.prev && hasOwn.call(entry, \"finallyLoc\") && this.prev < entry.finallyLoc) {\n          var finallyEntry = entry;\n          break;\n        }\n      }\n\n      if (finallyEntry && (type === \"break\" || type === \"continue\") && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc) {\n        // Ignore the finally entry if control is not jumping to a\n        // location outside the try/catch block.\n        finallyEntry = null;\n      }\n\n      var record = finallyEntry ? finallyEntry.completion : {};\n      record.type = type;\n      record.arg = arg;\n\n      if (finallyEntry) {\n        this.method = \"next\";\n        this.next = finallyEntry.finallyLoc;\n        return ContinueSentinel;\n      }\n\n      return this.complete(record);\n    },\n    complete: function complete(record, afterLoc) {\n      if (record.type === \"throw\") {\n        throw record.arg;\n      }\n\n      if (record.type === \"break\" || record.type === \"continue\") {\n        this.next = record.arg;\n      } else if (record.type === \"return\") {\n        this.rval = this.arg = record.arg;\n        this.method = \"return\";\n        this.next = \"end\";\n      } else if (record.type === \"normal\" && afterLoc) {\n        this.next = afterLoc;\n      }\n\n      return ContinueSentinel;\n    },\n    finish: function finish(finallyLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n\n        if (entry.finallyLoc === finallyLoc) {\n          this.complete(entry.completion, entry.afterLoc);\n          resetTryEntry(entry);\n          return ContinueSentinel;\n        }\n      }\n    },\n    \"catch\": function _catch(tryLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n\n        if (entry.tryLoc === tryLoc) {\n          var record = entry.completion;\n\n          if (record.type === \"throw\") {\n            var thrown = record.arg;\n            resetTryEntry(entry);\n          }\n\n          return thrown;\n        }\n      } // The context.catch method must only be called with a location\n      // argument that corresponds to a known catch block.\n\n\n      throw new Error(\"illegal catch attempt\");\n    },\n    delegateYield: function delegateYield(iterable, resultName, nextLoc) {\n      this.delegate = {\n        iterator: values(iterable),\n        resultName: resultName,\n        nextLoc: nextLoc\n      };\n\n      if (this.method === \"next\") {\n        // Deliberately forget the last sent value so that we don't\n        // accidentally pass it on to the delegate.\n        this.arg = undefined;\n      }\n\n      return ContinueSentinel;\n    }\n  }; // Regardless of whether this script is executing as a CommonJS module\n  // or not, return the runtime object so that we can declare the variable\n  // regeneratorRuntime in the outer scope, which allows this module to be\n  // injected easily by `bin/regenerator --include-runtime script.js`.\n\n  return exports;\n}( // If this script is executing as a CommonJS module, use module.exports\n// as the regeneratorRuntime namespace. Otherwise create a new empty\n// object. Either way, the resulting object will be used to initialize\n// the regeneratorRuntime variable at the top of this file.\n( false ? 0 : _typeof(module)) === \"object\" ? module.exports : {});\n\ntry {\n  regeneratorRuntime = runtime;\n} catch (accidentalStrictMode) {\n  // This module should not be running in strict mode, so the above\n  // assignment should always work unless something is misconfigured. Just\n  // in case runtime.js accidentally runs in strict mode, in modern engines\n  // we can explicitly access globalThis. In older engines we can escape\n  // strict mode using a global Function call. This could conceivably fail\n  // if a Content Security Policy forbids using Function, but in that case\n  // the proper solution is to fix the accidental strict mode problem. If\n  // you've misconfigured your bundler to force strict mode and applied a\n  // CSP to forbid Function, and you're not willing to fix either of those\n  // problems, please detail your unique predicament in a GitHub issue.\n  if ((typeof globalThis === \"undefined\" ? \"undefined\" : _typeof(globalThis)) === \"object\") {\n    globalThis.regeneratorRuntime = runtime;\n  } else {\n    Function(\"r\", \"regeneratorRuntime = r\")(runtime);\n  }\n}\n\n//# sourceURL=webpack://WorkBox/./node_modules/regenerator-runtime/runtime.js?");

/***/ }),

/***/ "./node_modules/resolve-url/resolve-url.js":
/*!*************************************************!*\
  !*** ./node_modules/resolve-url/resolve-url.js ***!
  \*************************************************/
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;function _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\n// Copyright 2014 Simon Lydell\n// X11 (“MIT”) Licensed. (See LICENSE.)\nvoid function (root, factory) {\n  if (true) {\n    !(__WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) :\n\t\t__WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n  } else {}\n}(this, function () {\n  function resolveUrl() {\n    var numUrls = arguments.length;\n\n    if (numUrls === 0) {\n      throw new Error(\"resolveUrl requires at least one argument; got none.\");\n    }\n\n    var base = document.createElement(\"base\");\n    base.href = arguments[0];\n\n    if (numUrls === 1) {\n      return base.href;\n    }\n\n    var head = document.getElementsByTagName(\"head\")[0];\n    head.insertBefore(base, head.firstChild);\n    var a = document.createElement(\"a\");\n    var resolved;\n\n    for (var index = 1; index < numUrls; index++) {\n      a.href = arguments[index];\n      resolved = a.href;\n      base.href = resolved;\n    }\n\n    head.removeChild(base);\n    return resolved;\n  }\n\n  return resolveUrl;\n});\n\n//# sourceURL=webpack://WorkBox/./node_modules/resolve-url/resolve-url.js?");

/***/ }),

/***/ "./node_modules/sax/lib/sax.js":
/*!*************************************!*\
  !*** ./node_modules/sax/lib/sax.js ***!
  \*************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("function _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\n;\n\n(function (sax) {\n  // wrapper for non-node envs\n  sax.parser = function (strict, opt) {\n    return new SAXParser(strict, opt);\n  };\n\n  sax.SAXParser = SAXParser;\n  sax.SAXStream = SAXStream;\n  sax.createStream = createStream; // When we pass the MAX_BUFFER_LENGTH position, start checking for buffer overruns.\n  // When we check, schedule the next check for MAX_BUFFER_LENGTH - (max(buffer lengths)),\n  // since that's the earliest that a buffer overrun could occur.  This way, checks are\n  // as rare as required, but as often as necessary to ensure never crossing this bound.\n  // Furthermore, buffers are only tested at most once per write(), so passing a very\n  // large string into write() might have undesirable effects, but this is manageable by\n  // the caller, so it is assumed to be safe.  Thus, a call to write() may, in the extreme\n  // edge case, result in creating at most one complete copy of the string passed in.\n  // Set to Infinity to have unlimited buffers.\n\n  sax.MAX_BUFFER_LENGTH = 64 * 1024;\n  var buffers = ['comment', 'sgmlDecl', 'textNode', 'tagName', 'doctype', 'procInstName', 'procInstBody', 'entity', 'attribName', 'attribValue', 'cdata', 'script'];\n  sax.EVENTS = ['text', 'processinginstruction', 'sgmldeclaration', 'doctype', 'comment', 'opentagstart', 'attribute', 'opentag', 'closetag', 'opencdata', 'cdata', 'closecdata', 'error', 'end', 'ready', 'script', 'opennamespace', 'closenamespace'];\n\n  function SAXParser(strict, opt) {\n    if (!(this instanceof SAXParser)) {\n      return new SAXParser(strict, opt);\n    }\n\n    var parser = this;\n    clearBuffers(parser);\n    parser.q = parser.c = '';\n    parser.bufferCheckPosition = sax.MAX_BUFFER_LENGTH;\n    parser.opt = opt || {};\n    parser.opt.lowercase = parser.opt.lowercase || parser.opt.lowercasetags;\n    parser.looseCase = parser.opt.lowercase ? 'toLowerCase' : 'toUpperCase';\n    parser.tags = [];\n    parser.closed = parser.closedRoot = parser.sawRoot = false;\n    parser.tag = parser.error = null;\n    parser.strict = !!strict;\n    parser.noscript = !!(strict || parser.opt.noscript);\n    parser.state = S.BEGIN;\n    parser.strictEntities = parser.opt.strictEntities;\n    parser.ENTITIES = parser.strictEntities ? Object.create(sax.XML_ENTITIES) : Object.create(sax.ENTITIES);\n    parser.attribList = []; // namespaces form a prototype chain.\n    // it always points at the current tag,\n    // which protos to its parent tag.\n\n    if (parser.opt.xmlns) {\n      parser.ns = Object.create(rootNS);\n    } // mostly just for error reporting\n\n\n    parser.trackPosition = parser.opt.position !== false;\n\n    if (parser.trackPosition) {\n      parser.position = parser.line = parser.column = 0;\n    }\n\n    emit(parser, 'onready');\n  }\n\n  if (!Object.create) {\n    Object.create = function (o) {\n      function F() {}\n\n      F.prototype = o;\n      var newf = new F();\n      return newf;\n    };\n  }\n\n  if (!Object.keys) {\n    Object.keys = function (o) {\n      var a = [];\n\n      for (var i in o) {\n        if (o.hasOwnProperty(i)) a.push(i);\n      }\n\n      return a;\n    };\n  }\n\n  function checkBufferLength(parser) {\n    var maxAllowed = Math.max(sax.MAX_BUFFER_LENGTH, 10);\n    var maxActual = 0;\n\n    for (var i = 0, l = buffers.length; i < l; i++) {\n      var len = parser[buffers[i]].length;\n\n      if (len > maxAllowed) {\n        // Text/cdata nodes can get big, and since they're buffered,\n        // we can get here under normal conditions.\n        // Avoid issues by emitting the text node now,\n        // so at least it won't get any bigger.\n        switch (buffers[i]) {\n          case 'textNode':\n            closeText(parser);\n            break;\n\n          case 'cdata':\n            emitNode(parser, 'oncdata', parser.cdata);\n            parser.cdata = '';\n            break;\n\n          case 'script':\n            emitNode(parser, 'onscript', parser.script);\n            parser.script = '';\n            break;\n\n          default:\n            error(parser, 'Max buffer length exceeded: ' + buffers[i]);\n        }\n      }\n\n      maxActual = Math.max(maxActual, len);\n    } // schedule the next check for the earliest possible buffer overrun.\n\n\n    var m = sax.MAX_BUFFER_LENGTH - maxActual;\n    parser.bufferCheckPosition = m + parser.position;\n  }\n\n  function clearBuffers(parser) {\n    for (var i = 0, l = buffers.length; i < l; i++) {\n      parser[buffers[i]] = '';\n    }\n  }\n\n  function flushBuffers(parser) {\n    closeText(parser);\n\n    if (parser.cdata !== '') {\n      emitNode(parser, 'oncdata', parser.cdata);\n      parser.cdata = '';\n    }\n\n    if (parser.script !== '') {\n      emitNode(parser, 'onscript', parser.script);\n      parser.script = '';\n    }\n  }\n\n  SAXParser.prototype = {\n    end: function end() {\n      _end(this);\n    },\n    write: write,\n    resume: function resume() {\n      this.error = null;\n      return this;\n    },\n    close: function close() {\n      return this.write(null);\n    },\n    flush: function flush() {\n      flushBuffers(this);\n    }\n  };\n  var Stream;\n\n  try {\n    Stream = Object(function webpackMissingModule() { var e = new Error(\"Cannot find module 'stream'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }());\n  } catch (ex) {\n    Stream = function Stream() {};\n  }\n\n  var streamWraps = sax.EVENTS.filter(function (ev) {\n    return ev !== 'error' && ev !== 'end';\n  });\n\n  function createStream(strict, opt) {\n    return new SAXStream(strict, opt);\n  }\n\n  function SAXStream(strict, opt) {\n    if (!(this instanceof SAXStream)) {\n      return new SAXStream(strict, opt);\n    }\n\n    Stream.apply(this);\n    this._parser = new SAXParser(strict, opt);\n    this.writable = true;\n    this.readable = true;\n    var me = this;\n\n    this._parser.onend = function () {\n      me.emit('end');\n    };\n\n    this._parser.onerror = function (er) {\n      me.emit('error', er); // if didn't throw, then means error was handled.\n      // go ahead and clear error, so we can write again.\n\n      me._parser.error = null;\n    };\n\n    this._decoder = null;\n    streamWraps.forEach(function (ev) {\n      Object.defineProperty(me, 'on' + ev, {\n        get: function get() {\n          return me._parser['on' + ev];\n        },\n        set: function set(h) {\n          if (!h) {\n            me.removeAllListeners(ev);\n            me._parser['on' + ev] = h;\n            return h;\n          }\n\n          me.on(ev, h);\n        },\n        enumerable: true,\n        configurable: false\n      });\n    });\n  }\n\n  SAXStream.prototype = Object.create(Stream.prototype, {\n    constructor: {\n      value: SAXStream\n    }\n  });\n\n  SAXStream.prototype.write = function (data) {\n    if (typeof Buffer === 'function' && typeof Buffer.isBuffer === 'function' && Buffer.isBuffer(data)) {\n      if (!this._decoder) {\n        var SD = (__webpack_require__(/*! string_decoder */ \"./node_modules/string_decoder/lib/string_decoder.js\").StringDecoder);\n\n        this._decoder = new SD('utf8');\n      }\n\n      data = this._decoder.write(data);\n    }\n\n    this._parser.write(data.toString());\n\n    this.emit('data', data);\n    return true;\n  };\n\n  SAXStream.prototype.end = function (chunk) {\n    if (chunk && chunk.length) {\n      this.write(chunk);\n    }\n\n    this._parser.end();\n\n    return true;\n  };\n\n  SAXStream.prototype.on = function (ev, handler) {\n    var me = this;\n\n    if (!me._parser['on' + ev] && streamWraps.indexOf(ev) !== -1) {\n      me._parser['on' + ev] = function () {\n        var args = arguments.length === 1 ? [arguments[0]] : Array.apply(null, arguments);\n        args.splice(0, 0, ev);\n        me.emit.apply(me, args);\n      };\n    }\n\n    return Stream.prototype.on.call(me, ev, handler);\n  }; // this really needs to be replaced with character classes.\n  // XML allows all manner of ridiculous numbers and digits.\n\n\n  var CDATA = '[CDATA[';\n  var DOCTYPE = 'DOCTYPE';\n  var XML_NAMESPACE = 'http://www.w3.org/XML/1998/namespace';\n  var XMLNS_NAMESPACE = 'http://www.w3.org/2000/xmlns/';\n  var rootNS = {\n    xml: XML_NAMESPACE,\n    xmlns: XMLNS_NAMESPACE\n  }; // http://www.w3.org/TR/REC-xml/#NT-NameStartChar\n  // This implementation works on strings, a single character at a time\n  // as such, it cannot ever support astral-plane characters (10000-EFFFF)\n  // without a significant breaking change to either this  parser, or the\n  // JavaScript language.  Implementation of an emoji-capable xml parser\n  // is left as an exercise for the reader.\n\n  var nameStart = /[:_A-Za-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD]/;\n  var nameBody = /[:_A-Za-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\u00B7\\u0300-\\u036F\\u203F-\\u2040.\\d-]/;\n  var entityStart = /[#:_A-Za-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD]/;\n  var entityBody = /[#:_A-Za-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\u00B7\\u0300-\\u036F\\u203F-\\u2040.\\d-]/;\n\n  function isWhitespace(c) {\n    return c === ' ' || c === '\\n' || c === '\\r' || c === '\\t';\n  }\n\n  function isQuote(c) {\n    return c === '\"' || c === '\\'';\n  }\n\n  function isAttribEnd(c) {\n    return c === '>' || isWhitespace(c);\n  }\n\n  function isMatch(regex, c) {\n    return regex.test(c);\n  }\n\n  function notMatch(regex, c) {\n    return !isMatch(regex, c);\n  }\n\n  var S = 0;\n  sax.STATE = {\n    BEGIN: S++,\n    // leading byte order mark or whitespace\n    BEGIN_WHITESPACE: S++,\n    // leading whitespace\n    TEXT: S++,\n    // general stuff\n    TEXT_ENTITY: S++,\n    // &amp and such.\n    OPEN_WAKA: S++,\n    // <\n    SGML_DECL: S++,\n    // <!BLARG\n    SGML_DECL_QUOTED: S++,\n    // <!BLARG foo \"bar\n    DOCTYPE: S++,\n    // <!DOCTYPE\n    DOCTYPE_QUOTED: S++,\n    // <!DOCTYPE \"//blah\n    DOCTYPE_DTD: S++,\n    // <!DOCTYPE \"//blah\" [ ...\n    DOCTYPE_DTD_QUOTED: S++,\n    // <!DOCTYPE \"//blah\" [ \"foo\n    COMMENT_STARTING: S++,\n    // <!-\n    COMMENT: S++,\n    // <!--\n    COMMENT_ENDING: S++,\n    // <!-- blah -\n    COMMENT_ENDED: S++,\n    // <!-- blah --\n    CDATA: S++,\n    // <![CDATA[ something\n    CDATA_ENDING: S++,\n    // ]\n    CDATA_ENDING_2: S++,\n    // ]]\n    PROC_INST: S++,\n    // <?hi\n    PROC_INST_BODY: S++,\n    // <?hi there\n    PROC_INST_ENDING: S++,\n    // <?hi \"there\" ?\n    OPEN_TAG: S++,\n    // <strong\n    OPEN_TAG_SLASH: S++,\n    // <strong /\n    ATTRIB: S++,\n    // <a\n    ATTRIB_NAME: S++,\n    // <a foo\n    ATTRIB_NAME_SAW_WHITE: S++,\n    // <a foo _\n    ATTRIB_VALUE: S++,\n    // <a foo=\n    ATTRIB_VALUE_QUOTED: S++,\n    // <a foo=\"bar\n    ATTRIB_VALUE_CLOSED: S++,\n    // <a foo=\"bar\"\n    ATTRIB_VALUE_UNQUOTED: S++,\n    // <a foo=bar\n    ATTRIB_VALUE_ENTITY_Q: S++,\n    // <foo bar=\"&quot;\"\n    ATTRIB_VALUE_ENTITY_U: S++,\n    // <foo bar=&quot\n    CLOSE_TAG: S++,\n    // </a\n    CLOSE_TAG_SAW_WHITE: S++,\n    // </a   >\n    SCRIPT: S++,\n    // <script> ...\n    SCRIPT_ENDING: S++ // <script> ... <\n\n  };\n  sax.XML_ENTITIES = {\n    'amp': '&',\n    'gt': '>',\n    'lt': '<',\n    'quot': '\"',\n    'apos': \"'\"\n  };\n  sax.ENTITIES = {\n    'amp': '&',\n    'gt': '>',\n    'lt': '<',\n    'quot': '\"',\n    'apos': \"'\",\n    'AElig': 198,\n    'Aacute': 193,\n    'Acirc': 194,\n    'Agrave': 192,\n    'Aring': 197,\n    'Atilde': 195,\n    'Auml': 196,\n    'Ccedil': 199,\n    'ETH': 208,\n    'Eacute': 201,\n    'Ecirc': 202,\n    'Egrave': 200,\n    'Euml': 203,\n    'Iacute': 205,\n    'Icirc': 206,\n    'Igrave': 204,\n    'Iuml': 207,\n    'Ntilde': 209,\n    'Oacute': 211,\n    'Ocirc': 212,\n    'Ograve': 210,\n    'Oslash': 216,\n    'Otilde': 213,\n    'Ouml': 214,\n    'THORN': 222,\n    'Uacute': 218,\n    'Ucirc': 219,\n    'Ugrave': 217,\n    'Uuml': 220,\n    'Yacute': 221,\n    'aacute': 225,\n    'acirc': 226,\n    'aelig': 230,\n    'agrave': 224,\n    'aring': 229,\n    'atilde': 227,\n    'auml': 228,\n    'ccedil': 231,\n    'eacute': 233,\n    'ecirc': 234,\n    'egrave': 232,\n    'eth': 240,\n    'euml': 235,\n    'iacute': 237,\n    'icirc': 238,\n    'igrave': 236,\n    'iuml': 239,\n    'ntilde': 241,\n    'oacute': 243,\n    'ocirc': 244,\n    'ograve': 242,\n    'oslash': 248,\n    'otilde': 245,\n    'ouml': 246,\n    'szlig': 223,\n    'thorn': 254,\n    'uacute': 250,\n    'ucirc': 251,\n    'ugrave': 249,\n    'uuml': 252,\n    'yacute': 253,\n    'yuml': 255,\n    'copy': 169,\n    'reg': 174,\n    'nbsp': 160,\n    'iexcl': 161,\n    'cent': 162,\n    'pound': 163,\n    'curren': 164,\n    'yen': 165,\n    'brvbar': 166,\n    'sect': 167,\n    'uml': 168,\n    'ordf': 170,\n    'laquo': 171,\n    'not': 172,\n    'shy': 173,\n    'macr': 175,\n    'deg': 176,\n    'plusmn': 177,\n    'sup1': 185,\n    'sup2': 178,\n    'sup3': 179,\n    'acute': 180,\n    'micro': 181,\n    'para': 182,\n    'middot': 183,\n    'cedil': 184,\n    'ordm': 186,\n    'raquo': 187,\n    'frac14': 188,\n    'frac12': 189,\n    'frac34': 190,\n    'iquest': 191,\n    'times': 215,\n    'divide': 247,\n    'OElig': 338,\n    'oelig': 339,\n    'Scaron': 352,\n    'scaron': 353,\n    'Yuml': 376,\n    'fnof': 402,\n    'circ': 710,\n    'tilde': 732,\n    'Alpha': 913,\n    'Beta': 914,\n    'Gamma': 915,\n    'Delta': 916,\n    'Epsilon': 917,\n    'Zeta': 918,\n    'Eta': 919,\n    'Theta': 920,\n    'Iota': 921,\n    'Kappa': 922,\n    'Lambda': 923,\n    'Mu': 924,\n    'Nu': 925,\n    'Xi': 926,\n    'Omicron': 927,\n    'Pi': 928,\n    'Rho': 929,\n    'Sigma': 931,\n    'Tau': 932,\n    'Upsilon': 933,\n    'Phi': 934,\n    'Chi': 935,\n    'Psi': 936,\n    'Omega': 937,\n    'alpha': 945,\n    'beta': 946,\n    'gamma': 947,\n    'delta': 948,\n    'epsilon': 949,\n    'zeta': 950,\n    'eta': 951,\n    'theta': 952,\n    'iota': 953,\n    'kappa': 954,\n    'lambda': 955,\n    'mu': 956,\n    'nu': 957,\n    'xi': 958,\n    'omicron': 959,\n    'pi': 960,\n    'rho': 961,\n    'sigmaf': 962,\n    'sigma': 963,\n    'tau': 964,\n    'upsilon': 965,\n    'phi': 966,\n    'chi': 967,\n    'psi': 968,\n    'omega': 969,\n    'thetasym': 977,\n    'upsih': 978,\n    'piv': 982,\n    'ensp': 8194,\n    'emsp': 8195,\n    'thinsp': 8201,\n    'zwnj': 8204,\n    'zwj': 8205,\n    'lrm': 8206,\n    'rlm': 8207,\n    'ndash': 8211,\n    'mdash': 8212,\n    'lsquo': 8216,\n    'rsquo': 8217,\n    'sbquo': 8218,\n    'ldquo': 8220,\n    'rdquo': 8221,\n    'bdquo': 8222,\n    'dagger': 8224,\n    'Dagger': 8225,\n    'bull': 8226,\n    'hellip': 8230,\n    'permil': 8240,\n    'prime': 8242,\n    'Prime': 8243,\n    'lsaquo': 8249,\n    'rsaquo': 8250,\n    'oline': 8254,\n    'frasl': 8260,\n    'euro': 8364,\n    'image': 8465,\n    'weierp': 8472,\n    'real': 8476,\n    'trade': 8482,\n    'alefsym': 8501,\n    'larr': 8592,\n    'uarr': 8593,\n    'rarr': 8594,\n    'darr': 8595,\n    'harr': 8596,\n    'crarr': 8629,\n    'lArr': 8656,\n    'uArr': 8657,\n    'rArr': 8658,\n    'dArr': 8659,\n    'hArr': 8660,\n    'forall': 8704,\n    'part': 8706,\n    'exist': 8707,\n    'empty': 8709,\n    'nabla': 8711,\n    'isin': 8712,\n    'notin': 8713,\n    'ni': 8715,\n    'prod': 8719,\n    'sum': 8721,\n    'minus': 8722,\n    'lowast': 8727,\n    'radic': 8730,\n    'prop': 8733,\n    'infin': 8734,\n    'ang': 8736,\n    'and': 8743,\n    'or': 8744,\n    'cap': 8745,\n    'cup': 8746,\n    'int': 8747,\n    'there4': 8756,\n    'sim': 8764,\n    'cong': 8773,\n    'asymp': 8776,\n    'ne': 8800,\n    'equiv': 8801,\n    'le': 8804,\n    'ge': 8805,\n    'sub': 8834,\n    'sup': 8835,\n    'nsub': 8836,\n    'sube': 8838,\n    'supe': 8839,\n    'oplus': 8853,\n    'otimes': 8855,\n    'perp': 8869,\n    'sdot': 8901,\n    'lceil': 8968,\n    'rceil': 8969,\n    'lfloor': 8970,\n    'rfloor': 8971,\n    'lang': 9001,\n    'rang': 9002,\n    'loz': 9674,\n    'spades': 9824,\n    'clubs': 9827,\n    'hearts': 9829,\n    'diams': 9830\n  };\n  Object.keys(sax.ENTITIES).forEach(function (key) {\n    var e = sax.ENTITIES[key];\n    var s = typeof e === 'number' ? String.fromCharCode(e) : e;\n    sax.ENTITIES[key] = s;\n  });\n\n  for (var s in sax.STATE) {\n    sax.STATE[sax.STATE[s]] = s;\n  } // shorthand\n\n\n  S = sax.STATE;\n\n  function emit(parser, event, data) {\n    parser[event] && parser[event](data);\n  }\n\n  function emitNode(parser, nodeType, data) {\n    if (parser.textNode) closeText(parser);\n    emit(parser, nodeType, data);\n  }\n\n  function closeText(parser) {\n    parser.textNode = textopts(parser.opt, parser.textNode);\n    if (parser.textNode) emit(parser, 'ontext', parser.textNode);\n    parser.textNode = '';\n  }\n\n  function textopts(opt, text) {\n    if (opt.trim) text = text.trim();\n    if (opt.normalize) text = text.replace(/\\s+/g, ' ');\n    return text;\n  }\n\n  function error(parser, er) {\n    closeText(parser);\n\n    if (parser.trackPosition) {\n      er += '\\nLine: ' + parser.line + '\\nColumn: ' + parser.column + '\\nChar: ' + parser.c;\n    }\n\n    er = new Error(er);\n    parser.error = er;\n    emit(parser, 'onerror', er);\n    return parser;\n  }\n\n  function _end(parser) {\n    if (parser.sawRoot && !parser.closedRoot) strictFail(parser, 'Unclosed root tag');\n\n    if (parser.state !== S.BEGIN && parser.state !== S.BEGIN_WHITESPACE && parser.state !== S.TEXT) {\n      error(parser, 'Unexpected end');\n    }\n\n    closeText(parser);\n    parser.c = '';\n    parser.closed = true;\n    emit(parser, 'onend');\n    SAXParser.call(parser, parser.strict, parser.opt);\n    return parser;\n  }\n\n  function strictFail(parser, message) {\n    if (_typeof(parser) !== 'object' || !(parser instanceof SAXParser)) {\n      throw new Error('bad call to strictFail');\n    }\n\n    if (parser.strict) {\n      error(parser, message);\n    }\n  }\n\n  function newTag(parser) {\n    if (!parser.strict) parser.tagName = parser.tagName[parser.looseCase]();\n    var parent = parser.tags[parser.tags.length - 1] || parser;\n    var tag = parser.tag = {\n      name: parser.tagName,\n      attributes: {}\n    }; // will be overridden if tag contails an xmlns=\"foo\" or xmlns:foo=\"bar\"\n\n    if (parser.opt.xmlns) {\n      tag.ns = parent.ns;\n    }\n\n    parser.attribList.length = 0;\n    emitNode(parser, 'onopentagstart', tag);\n  }\n\n  function qname(name, attribute) {\n    var i = name.indexOf(':');\n    var qualName = i < 0 ? ['', name] : name.split(':');\n    var prefix = qualName[0];\n    var local = qualName[1]; // <x \"xmlns\"=\"http://foo\">\n\n    if (attribute && name === 'xmlns') {\n      prefix = 'xmlns';\n      local = '';\n    }\n\n    return {\n      prefix: prefix,\n      local: local\n    };\n  }\n\n  function attrib(parser) {\n    if (!parser.strict) {\n      parser.attribName = parser.attribName[parser.looseCase]();\n    }\n\n    if (parser.attribList.indexOf(parser.attribName) !== -1 || parser.tag.attributes.hasOwnProperty(parser.attribName)) {\n      parser.attribName = parser.attribValue = '';\n      return;\n    }\n\n    if (parser.opt.xmlns) {\n      var qn = qname(parser.attribName, true);\n      var prefix = qn.prefix;\n      var local = qn.local;\n\n      if (prefix === 'xmlns') {\n        // namespace binding attribute. push the binding into scope\n        if (local === 'xml' && parser.attribValue !== XML_NAMESPACE) {\n          strictFail(parser, 'xml: prefix must be bound to ' + XML_NAMESPACE + '\\n' + 'Actual: ' + parser.attribValue);\n        } else if (local === 'xmlns' && parser.attribValue !== XMLNS_NAMESPACE) {\n          strictFail(parser, 'xmlns: prefix must be bound to ' + XMLNS_NAMESPACE + '\\n' + 'Actual: ' + parser.attribValue);\n        } else {\n          var tag = parser.tag;\n          var parent = parser.tags[parser.tags.length - 1] || parser;\n\n          if (tag.ns === parent.ns) {\n            tag.ns = Object.create(parent.ns);\n          }\n\n          tag.ns[local] = parser.attribValue;\n        }\n      } // defer onattribute events until all attributes have been seen\n      // so any new bindings can take effect. preserve attribute order\n      // so deferred events can be emitted in document order\n\n\n      parser.attribList.push([parser.attribName, parser.attribValue]);\n    } else {\n      // in non-xmlns mode, we can emit the event right away\n      parser.tag.attributes[parser.attribName] = parser.attribValue;\n      emitNode(parser, 'onattribute', {\n        name: parser.attribName,\n        value: parser.attribValue\n      });\n    }\n\n    parser.attribName = parser.attribValue = '';\n  }\n\n  function openTag(parser, selfClosing) {\n    if (parser.opt.xmlns) {\n      // emit namespace binding events\n      var tag = parser.tag; // add namespace info to tag\n\n      var qn = qname(parser.tagName);\n      tag.prefix = qn.prefix;\n      tag.local = qn.local;\n      tag.uri = tag.ns[qn.prefix] || '';\n\n      if (tag.prefix && !tag.uri) {\n        strictFail(parser, 'Unbound namespace prefix: ' + JSON.stringify(parser.tagName));\n        tag.uri = qn.prefix;\n      }\n\n      var parent = parser.tags[parser.tags.length - 1] || parser;\n\n      if (tag.ns && parent.ns !== tag.ns) {\n        Object.keys(tag.ns).forEach(function (p) {\n          emitNode(parser, 'onopennamespace', {\n            prefix: p,\n            uri: tag.ns[p]\n          });\n        });\n      } // handle deferred onattribute events\n      // Note: do not apply default ns to attributes:\n      //   http://www.w3.org/TR/REC-xml-names/#defaulting\n\n\n      for (var i = 0, l = parser.attribList.length; i < l; i++) {\n        var nv = parser.attribList[i];\n        var name = nv[0];\n        var value = nv[1];\n        var qualName = qname(name, true);\n        var prefix = qualName.prefix;\n        var local = qualName.local;\n        var uri = prefix === '' ? '' : tag.ns[prefix] || '';\n        var a = {\n          name: name,\n          value: value,\n          prefix: prefix,\n          local: local,\n          uri: uri\n        }; // if there's any attributes with an undefined namespace,\n        // then fail on them now.\n\n        if (prefix && prefix !== 'xmlns' && !uri) {\n          strictFail(parser, 'Unbound namespace prefix: ' + JSON.stringify(prefix));\n          a.uri = prefix;\n        }\n\n        parser.tag.attributes[name] = a;\n        emitNode(parser, 'onattribute', a);\n      }\n\n      parser.attribList.length = 0;\n    }\n\n    parser.tag.isSelfClosing = !!selfClosing; // process the tag\n\n    parser.sawRoot = true;\n    parser.tags.push(parser.tag);\n    emitNode(parser, 'onopentag', parser.tag);\n\n    if (!selfClosing) {\n      // special case for <script> in non-strict mode.\n      if (!parser.noscript && parser.tagName.toLowerCase() === 'script') {\n        parser.state = S.SCRIPT;\n      } else {\n        parser.state = S.TEXT;\n      }\n\n      parser.tag = null;\n      parser.tagName = '';\n    }\n\n    parser.attribName = parser.attribValue = '';\n    parser.attribList.length = 0;\n  }\n\n  function closeTag(parser) {\n    if (!parser.tagName) {\n      strictFail(parser, 'Weird empty close tag.');\n      parser.textNode += '</>';\n      parser.state = S.TEXT;\n      return;\n    }\n\n    if (parser.script) {\n      if (parser.tagName !== 'script') {\n        parser.script += '</' + parser.tagName + '>';\n        parser.tagName = '';\n        parser.state = S.SCRIPT;\n        return;\n      }\n\n      emitNode(parser, 'onscript', parser.script);\n      parser.script = '';\n    } // first make sure that the closing tag actually exists.\n    // <a><b></c></b></a> will close everything, otherwise.\n\n\n    var t = parser.tags.length;\n    var tagName = parser.tagName;\n\n    if (!parser.strict) {\n      tagName = tagName[parser.looseCase]();\n    }\n\n    var closeTo = tagName;\n\n    while (t--) {\n      var close = parser.tags[t];\n\n      if (close.name !== closeTo) {\n        // fail the first time in strict mode\n        strictFail(parser, 'Unexpected close tag');\n      } else {\n        break;\n      }\n    } // didn't find it.  we already failed for strict, so just abort.\n\n\n    if (t < 0) {\n      strictFail(parser, 'Unmatched closing tag: ' + parser.tagName);\n      parser.textNode += '</' + parser.tagName + '>';\n      parser.state = S.TEXT;\n      return;\n    }\n\n    parser.tagName = tagName;\n    var s = parser.tags.length;\n\n    while (s-- > t) {\n      var tag = parser.tag = parser.tags.pop();\n      parser.tagName = parser.tag.name;\n      emitNode(parser, 'onclosetag', parser.tagName);\n      var x = {};\n\n      for (var i in tag.ns) {\n        x[i] = tag.ns[i];\n      }\n\n      var parent = parser.tags[parser.tags.length - 1] || parser;\n\n      if (parser.opt.xmlns && tag.ns !== parent.ns) {\n        // remove namespace bindings introduced by tag\n        Object.keys(tag.ns).forEach(function (p) {\n          var n = tag.ns[p];\n          emitNode(parser, 'onclosenamespace', {\n            prefix: p,\n            uri: n\n          });\n        });\n      }\n    }\n\n    if (t === 0) parser.closedRoot = true;\n    parser.tagName = parser.attribValue = parser.attribName = '';\n    parser.attribList.length = 0;\n    parser.state = S.TEXT;\n  }\n\n  function parseEntity(parser) {\n    var entity = parser.entity;\n    var entityLC = entity.toLowerCase();\n    var num;\n    var numStr = '';\n\n    if (parser.ENTITIES[entity]) {\n      return parser.ENTITIES[entity];\n    }\n\n    if (parser.ENTITIES[entityLC]) {\n      return parser.ENTITIES[entityLC];\n    }\n\n    entity = entityLC;\n\n    if (entity.charAt(0) === '#') {\n      if (entity.charAt(1) === 'x') {\n        entity = entity.slice(2);\n        num = parseInt(entity, 16);\n        numStr = num.toString(16);\n      } else {\n        entity = entity.slice(1);\n        num = parseInt(entity, 10);\n        numStr = num.toString(10);\n      }\n    }\n\n    entity = entity.replace(/^0+/, '');\n\n    if (isNaN(num) || numStr.toLowerCase() !== entity) {\n      strictFail(parser, 'Invalid character entity');\n      return '&' + parser.entity + ';';\n    }\n\n    return String.fromCodePoint(num);\n  }\n\n  function beginWhiteSpace(parser, c) {\n    if (c === '<') {\n      parser.state = S.OPEN_WAKA;\n      parser.startTagPosition = parser.position;\n    } else if (!isWhitespace(c)) {\n      // have to process this as a text node.\n      // weird, but happens.\n      strictFail(parser, 'Non-whitespace before first tag.');\n      parser.textNode = c;\n      parser.state = S.TEXT;\n    }\n  }\n\n  function charAt(chunk, i) {\n    var result = '';\n\n    if (i < chunk.length) {\n      result = chunk.charAt(i);\n    }\n\n    return result;\n  }\n\n  function write(chunk) {\n    var parser = this;\n\n    if (this.error) {\n      throw this.error;\n    }\n\n    if (parser.closed) {\n      return error(parser, 'Cannot write after close. Assign an onready handler.');\n    }\n\n    if (chunk === null) {\n      return _end(parser);\n    }\n\n    if (_typeof(chunk) === 'object') {\n      chunk = chunk.toString();\n    }\n\n    var i = 0;\n    var c = '';\n\n    while (true) {\n      c = charAt(chunk, i++);\n      parser.c = c;\n\n      if (!c) {\n        break;\n      }\n\n      if (parser.trackPosition) {\n        parser.position++;\n\n        if (c === '\\n') {\n          parser.line++;\n          parser.column = 0;\n        } else {\n          parser.column++;\n        }\n      }\n\n      switch (parser.state) {\n        case S.BEGIN:\n          parser.state = S.BEGIN_WHITESPACE;\n\n          if (c === \"\\uFEFF\") {\n            continue;\n          }\n\n          beginWhiteSpace(parser, c);\n          continue;\n\n        case S.BEGIN_WHITESPACE:\n          beginWhiteSpace(parser, c);\n          continue;\n\n        case S.TEXT:\n          if (parser.sawRoot && !parser.closedRoot) {\n            var starti = i - 1;\n\n            while (c && c !== '<' && c !== '&') {\n              c = charAt(chunk, i++);\n\n              if (c && parser.trackPosition) {\n                parser.position++;\n\n                if (c === '\\n') {\n                  parser.line++;\n                  parser.column = 0;\n                } else {\n                  parser.column++;\n                }\n              }\n            }\n\n            parser.textNode += chunk.substring(starti, i - 1);\n          }\n\n          if (c === '<' && !(parser.sawRoot && parser.closedRoot && !parser.strict)) {\n            parser.state = S.OPEN_WAKA;\n            parser.startTagPosition = parser.position;\n          } else {\n            if (!isWhitespace(c) && (!parser.sawRoot || parser.closedRoot)) {\n              strictFail(parser, 'Text data outside of root node.');\n            }\n\n            if (c === '&') {\n              parser.state = S.TEXT_ENTITY;\n            } else {\n              parser.textNode += c;\n            }\n          }\n\n          continue;\n\n        case S.SCRIPT:\n          // only non-strict\n          if (c === '<') {\n            parser.state = S.SCRIPT_ENDING;\n          } else {\n            parser.script += c;\n          }\n\n          continue;\n\n        case S.SCRIPT_ENDING:\n          if (c === '/') {\n            parser.state = S.CLOSE_TAG;\n          } else {\n            parser.script += '<' + c;\n            parser.state = S.SCRIPT;\n          }\n\n          continue;\n\n        case S.OPEN_WAKA:\n          // either a /, ?, !, or text is coming next.\n          if (c === '!') {\n            parser.state = S.SGML_DECL;\n            parser.sgmlDecl = '';\n          } else if (isWhitespace(c)) {// wait for it...\n          } else if (isMatch(nameStart, c)) {\n            parser.state = S.OPEN_TAG;\n            parser.tagName = c;\n          } else if (c === '/') {\n            parser.state = S.CLOSE_TAG;\n            parser.tagName = '';\n          } else if (c === '?') {\n            parser.state = S.PROC_INST;\n            parser.procInstName = parser.procInstBody = '';\n          } else {\n            strictFail(parser, 'Unencoded <'); // if there was some whitespace, then add that in.\n\n            if (parser.startTagPosition + 1 < parser.position) {\n              var pad = parser.position - parser.startTagPosition;\n              c = new Array(pad).join(' ') + c;\n            }\n\n            parser.textNode += '<' + c;\n            parser.state = S.TEXT;\n          }\n\n          continue;\n\n        case S.SGML_DECL:\n          if ((parser.sgmlDecl + c).toUpperCase() === CDATA) {\n            emitNode(parser, 'onopencdata');\n            parser.state = S.CDATA;\n            parser.sgmlDecl = '';\n            parser.cdata = '';\n          } else if (parser.sgmlDecl + c === '--') {\n            parser.state = S.COMMENT;\n            parser.comment = '';\n            parser.sgmlDecl = '';\n          } else if ((parser.sgmlDecl + c).toUpperCase() === DOCTYPE) {\n            parser.state = S.DOCTYPE;\n\n            if (parser.doctype || parser.sawRoot) {\n              strictFail(parser, 'Inappropriately located doctype declaration');\n            }\n\n            parser.doctype = '';\n            parser.sgmlDecl = '';\n          } else if (c === '>') {\n            emitNode(parser, 'onsgmldeclaration', parser.sgmlDecl);\n            parser.sgmlDecl = '';\n            parser.state = S.TEXT;\n          } else if (isQuote(c)) {\n            parser.state = S.SGML_DECL_QUOTED;\n            parser.sgmlDecl += c;\n          } else {\n            parser.sgmlDecl += c;\n          }\n\n          continue;\n\n        case S.SGML_DECL_QUOTED:\n          if (c === parser.q) {\n            parser.state = S.SGML_DECL;\n            parser.q = '';\n          }\n\n          parser.sgmlDecl += c;\n          continue;\n\n        case S.DOCTYPE:\n          if (c === '>') {\n            parser.state = S.TEXT;\n            emitNode(parser, 'ondoctype', parser.doctype);\n            parser.doctype = true; // just remember that we saw it.\n          } else {\n            parser.doctype += c;\n\n            if (c === '[') {\n              parser.state = S.DOCTYPE_DTD;\n            } else if (isQuote(c)) {\n              parser.state = S.DOCTYPE_QUOTED;\n              parser.q = c;\n            }\n          }\n\n          continue;\n\n        case S.DOCTYPE_QUOTED:\n          parser.doctype += c;\n\n          if (c === parser.q) {\n            parser.q = '';\n            parser.state = S.DOCTYPE;\n          }\n\n          continue;\n\n        case S.DOCTYPE_DTD:\n          parser.doctype += c;\n\n          if (c === ']') {\n            parser.state = S.DOCTYPE;\n          } else if (isQuote(c)) {\n            parser.state = S.DOCTYPE_DTD_QUOTED;\n            parser.q = c;\n          }\n\n          continue;\n\n        case S.DOCTYPE_DTD_QUOTED:\n          parser.doctype += c;\n\n          if (c === parser.q) {\n            parser.state = S.DOCTYPE_DTD;\n            parser.q = '';\n          }\n\n          continue;\n\n        case S.COMMENT:\n          if (c === '-') {\n            parser.state = S.COMMENT_ENDING;\n          } else {\n            parser.comment += c;\n          }\n\n          continue;\n\n        case S.COMMENT_ENDING:\n          if (c === '-') {\n            parser.state = S.COMMENT_ENDED;\n            parser.comment = textopts(parser.opt, parser.comment);\n\n            if (parser.comment) {\n              emitNode(parser, 'oncomment', parser.comment);\n            }\n\n            parser.comment = '';\n          } else {\n            parser.comment += '-' + c;\n            parser.state = S.COMMENT;\n          }\n\n          continue;\n\n        case S.COMMENT_ENDED:\n          if (c !== '>') {\n            strictFail(parser, 'Malformed comment'); // allow <!-- blah -- bloo --> in non-strict mode,\n            // which is a comment of \" blah -- bloo \"\n\n            parser.comment += '--' + c;\n            parser.state = S.COMMENT;\n          } else {\n            parser.state = S.TEXT;\n          }\n\n          continue;\n\n        case S.CDATA:\n          if (c === ']') {\n            parser.state = S.CDATA_ENDING;\n          } else {\n            parser.cdata += c;\n          }\n\n          continue;\n\n        case S.CDATA_ENDING:\n          if (c === ']') {\n            parser.state = S.CDATA_ENDING_2;\n          } else {\n            parser.cdata += ']' + c;\n            parser.state = S.CDATA;\n          }\n\n          continue;\n\n        case S.CDATA_ENDING_2:\n          if (c === '>') {\n            if (parser.cdata) {\n              emitNode(parser, 'oncdata', parser.cdata);\n            }\n\n            emitNode(parser, 'onclosecdata');\n            parser.cdata = '';\n            parser.state = S.TEXT;\n          } else if (c === ']') {\n            parser.cdata += ']';\n          } else {\n            parser.cdata += ']]' + c;\n            parser.state = S.CDATA;\n          }\n\n          continue;\n\n        case S.PROC_INST:\n          if (c === '?') {\n            parser.state = S.PROC_INST_ENDING;\n          } else if (isWhitespace(c)) {\n            parser.state = S.PROC_INST_BODY;\n          } else {\n            parser.procInstName += c;\n          }\n\n          continue;\n\n        case S.PROC_INST_BODY:\n          if (!parser.procInstBody && isWhitespace(c)) {\n            continue;\n          } else if (c === '?') {\n            parser.state = S.PROC_INST_ENDING;\n          } else {\n            parser.procInstBody += c;\n          }\n\n          continue;\n\n        case S.PROC_INST_ENDING:\n          if (c === '>') {\n            emitNode(parser, 'onprocessinginstruction', {\n              name: parser.procInstName,\n              body: parser.procInstBody\n            });\n            parser.procInstName = parser.procInstBody = '';\n            parser.state = S.TEXT;\n          } else {\n            parser.procInstBody += '?' + c;\n            parser.state = S.PROC_INST_BODY;\n          }\n\n          continue;\n\n        case S.OPEN_TAG:\n          if (isMatch(nameBody, c)) {\n            parser.tagName += c;\n          } else {\n            newTag(parser);\n\n            if (c === '>') {\n              openTag(parser);\n            } else if (c === '/') {\n              parser.state = S.OPEN_TAG_SLASH;\n            } else {\n              if (!isWhitespace(c)) {\n                strictFail(parser, 'Invalid character in tag name');\n              }\n\n              parser.state = S.ATTRIB;\n            }\n          }\n\n          continue;\n\n        case S.OPEN_TAG_SLASH:\n          if (c === '>') {\n            openTag(parser, true);\n            closeTag(parser);\n          } else {\n            strictFail(parser, 'Forward-slash in opening tag not followed by >');\n            parser.state = S.ATTRIB;\n          }\n\n          continue;\n\n        case S.ATTRIB:\n          // haven't read the attribute name yet.\n          if (isWhitespace(c)) {\n            continue;\n          } else if (c === '>') {\n            openTag(parser);\n          } else if (c === '/') {\n            parser.state = S.OPEN_TAG_SLASH;\n          } else if (isMatch(nameStart, c)) {\n            parser.attribName = c;\n            parser.attribValue = '';\n            parser.state = S.ATTRIB_NAME;\n          } else {\n            strictFail(parser, 'Invalid attribute name');\n          }\n\n          continue;\n\n        case S.ATTRIB_NAME:\n          if (c === '=') {\n            parser.state = S.ATTRIB_VALUE;\n          } else if (c === '>') {\n            strictFail(parser, 'Attribute without value');\n            parser.attribValue = parser.attribName;\n            attrib(parser);\n            openTag(parser);\n          } else if (isWhitespace(c)) {\n            parser.state = S.ATTRIB_NAME_SAW_WHITE;\n          } else if (isMatch(nameBody, c)) {\n            parser.attribName += c;\n          } else {\n            strictFail(parser, 'Invalid attribute name');\n          }\n\n          continue;\n\n        case S.ATTRIB_NAME_SAW_WHITE:\n          if (c === '=') {\n            parser.state = S.ATTRIB_VALUE;\n          } else if (isWhitespace(c)) {\n            continue;\n          } else {\n            strictFail(parser, 'Attribute without value');\n            parser.tag.attributes[parser.attribName] = '';\n            parser.attribValue = '';\n            emitNode(parser, 'onattribute', {\n              name: parser.attribName,\n              value: ''\n            });\n            parser.attribName = '';\n\n            if (c === '>') {\n              openTag(parser);\n            } else if (isMatch(nameStart, c)) {\n              parser.attribName = c;\n              parser.state = S.ATTRIB_NAME;\n            } else {\n              strictFail(parser, 'Invalid attribute name');\n              parser.state = S.ATTRIB;\n            }\n          }\n\n          continue;\n\n        case S.ATTRIB_VALUE:\n          if (isWhitespace(c)) {\n            continue;\n          } else if (isQuote(c)) {\n            parser.q = c;\n            parser.state = S.ATTRIB_VALUE_QUOTED;\n          } else {\n            strictFail(parser, 'Unquoted attribute value');\n            parser.state = S.ATTRIB_VALUE_UNQUOTED;\n            parser.attribValue = c;\n          }\n\n          continue;\n\n        case S.ATTRIB_VALUE_QUOTED:\n          if (c !== parser.q) {\n            if (c === '&') {\n              parser.state = S.ATTRIB_VALUE_ENTITY_Q;\n            } else {\n              parser.attribValue += c;\n            }\n\n            continue;\n          }\n\n          attrib(parser);\n          parser.q = '';\n          parser.state = S.ATTRIB_VALUE_CLOSED;\n          continue;\n\n        case S.ATTRIB_VALUE_CLOSED:\n          if (isWhitespace(c)) {\n            parser.state = S.ATTRIB;\n          } else if (c === '>') {\n            openTag(parser);\n          } else if (c === '/') {\n            parser.state = S.OPEN_TAG_SLASH;\n          } else if (isMatch(nameStart, c)) {\n            strictFail(parser, 'No whitespace between attributes');\n            parser.attribName = c;\n            parser.attribValue = '';\n            parser.state = S.ATTRIB_NAME;\n          } else {\n            strictFail(parser, 'Invalid attribute name');\n          }\n\n          continue;\n\n        case S.ATTRIB_VALUE_UNQUOTED:\n          if (!isAttribEnd(c)) {\n            if (c === '&') {\n              parser.state = S.ATTRIB_VALUE_ENTITY_U;\n            } else {\n              parser.attribValue += c;\n            }\n\n            continue;\n          }\n\n          attrib(parser);\n\n          if (c === '>') {\n            openTag(parser);\n          } else {\n            parser.state = S.ATTRIB;\n          }\n\n          continue;\n\n        case S.CLOSE_TAG:\n          if (!parser.tagName) {\n            if (isWhitespace(c)) {\n              continue;\n            } else if (notMatch(nameStart, c)) {\n              if (parser.script) {\n                parser.script += '</' + c;\n                parser.state = S.SCRIPT;\n              } else {\n                strictFail(parser, 'Invalid tagname in closing tag.');\n              }\n            } else {\n              parser.tagName = c;\n            }\n          } else if (c === '>') {\n            closeTag(parser);\n          } else if (isMatch(nameBody, c)) {\n            parser.tagName += c;\n          } else if (parser.script) {\n            parser.script += '</' + parser.tagName;\n            parser.tagName = '';\n            parser.state = S.SCRIPT;\n          } else {\n            if (!isWhitespace(c)) {\n              strictFail(parser, 'Invalid tagname in closing tag');\n            }\n\n            parser.state = S.CLOSE_TAG_SAW_WHITE;\n          }\n\n          continue;\n\n        case S.CLOSE_TAG_SAW_WHITE:\n          if (isWhitespace(c)) {\n            continue;\n          }\n\n          if (c === '>') {\n            closeTag(parser);\n          } else {\n            strictFail(parser, 'Invalid characters in closing tag');\n          }\n\n          continue;\n\n        case S.TEXT_ENTITY:\n        case S.ATTRIB_VALUE_ENTITY_Q:\n        case S.ATTRIB_VALUE_ENTITY_U:\n          var returnState;\n          var buffer;\n\n          switch (parser.state) {\n            case S.TEXT_ENTITY:\n              returnState = S.TEXT;\n              buffer = 'textNode';\n              break;\n\n            case S.ATTRIB_VALUE_ENTITY_Q:\n              returnState = S.ATTRIB_VALUE_QUOTED;\n              buffer = 'attribValue';\n              break;\n\n            case S.ATTRIB_VALUE_ENTITY_U:\n              returnState = S.ATTRIB_VALUE_UNQUOTED;\n              buffer = 'attribValue';\n              break;\n          }\n\n          if (c === ';') {\n            parser[buffer] += parseEntity(parser);\n            parser.entity = '';\n            parser.state = returnState;\n          } else if (isMatch(parser.entity.length ? entityBody : entityStart, c)) {\n            parser.entity += c;\n          } else {\n            strictFail(parser, 'Invalid character in entity name');\n            parser[buffer] += '&' + parser.entity + c;\n            parser.entity = '';\n            parser.state = returnState;\n          }\n\n          continue;\n\n        default:\n          throw new Error(parser, 'Unknown state: ' + parser.state);\n      }\n    } // while\n\n\n    if (parser.position >= parser.bufferCheckPosition) {\n      checkBufferLength(parser);\n    }\n\n    return parser;\n  }\n  /*! http://mths.be/fromcodepoint v0.1.0 by @mathias */\n\n  /* istanbul ignore next */\n\n\n  if (!String.fromCodePoint) {\n    (function () {\n      var stringFromCharCode = String.fromCharCode;\n      var floor = Math.floor;\n\n      var fromCodePoint = function fromCodePoint() {\n        var MAX_SIZE = 0x4000;\n        var codeUnits = [];\n        var highSurrogate;\n        var lowSurrogate;\n        var index = -1;\n        var length = arguments.length;\n\n        if (!length) {\n          return '';\n        }\n\n        var result = '';\n\n        while (++index < length) {\n          var codePoint = Number(arguments[index]);\n\n          if (!isFinite(codePoint) || // `NaN`, `+Infinity`, or `-Infinity`\n          codePoint < 0 || // not a valid Unicode code point\n          codePoint > 0x10FFFF || // not a valid Unicode code point\n          floor(codePoint) !== codePoint // not an integer\n          ) {\n            throw RangeError('Invalid code point: ' + codePoint);\n          }\n\n          if (codePoint <= 0xFFFF) {\n            // BMP code point\n            codeUnits.push(codePoint);\n          } else {\n            // Astral code point; split in surrogate halves\n            // http://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae\n            codePoint -= 0x10000;\n            highSurrogate = (codePoint >> 10) + 0xD800;\n            lowSurrogate = codePoint % 0x400 + 0xDC00;\n            codeUnits.push(highSurrogate, lowSurrogate);\n          }\n\n          if (index + 1 === length || codeUnits.length > MAX_SIZE) {\n            result += stringFromCharCode.apply(null, codeUnits);\n            codeUnits.length = 0;\n          }\n        }\n\n        return result;\n      };\n      /* istanbul ignore next */\n\n\n      if (Object.defineProperty) {\n        Object.defineProperty(String, 'fromCodePoint', {\n          value: fromCodePoint,\n          configurable: true,\n          writable: true\n        });\n      } else {\n        String.fromCodePoint = fromCodePoint;\n      }\n    })();\n  }\n})( false ? 0 : exports);\n\n//# sourceURL=webpack://WorkBox/./node_modules/sax/lib/sax.js?");

/***/ }),

/***/ "./node_modules/string_decoder/lib/string_decoder.js":
/*!***********************************************************!*\
  !*** ./node_modules/string_decoder/lib/string_decoder.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n/*<replacement>*/\n\nvar Buffer = (__webpack_require__(/*! safe-buffer */ \"./node_modules/string_decoder/node_modules/safe-buffer/index.js\").Buffer);\n/*</replacement>*/\n\n\nvar isEncoding = Buffer.isEncoding || function (encoding) {\n  encoding = '' + encoding;\n\n  switch (encoding && encoding.toLowerCase()) {\n    case 'hex':\n    case 'utf8':\n    case 'utf-8':\n    case 'ascii':\n    case 'binary':\n    case 'base64':\n    case 'ucs2':\n    case 'ucs-2':\n    case 'utf16le':\n    case 'utf-16le':\n    case 'raw':\n      return true;\n\n    default:\n      return false;\n  }\n};\n\nfunction _normalizeEncoding(enc) {\n  if (!enc) return 'utf8';\n  var retried;\n\n  while (true) {\n    switch (enc) {\n      case 'utf8':\n      case 'utf-8':\n        return 'utf8';\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return 'utf16le';\n\n      case 'latin1':\n      case 'binary':\n        return 'latin1';\n\n      case 'base64':\n      case 'ascii':\n      case 'hex':\n        return enc;\n\n      default:\n        if (retried) return; // undefined\n\n        enc = ('' + enc).toLowerCase();\n        retried = true;\n    }\n  }\n}\n\n; // Do not cache `Buffer.isEncoding` when checking encoding names as some\n// modules monkey-patch it to support additional encodings\n\nfunction normalizeEncoding(enc) {\n  var nenc = _normalizeEncoding(enc);\n\n  if (typeof nenc !== 'string' && (Buffer.isEncoding === isEncoding || !isEncoding(enc))) throw new Error('Unknown encoding: ' + enc);\n  return nenc || enc;\n} // StringDecoder provides an interface for efficiently splitting a series of\n// buffers into a series of JS strings without breaking apart multi-byte\n// characters.\n\n\nexports.StringDecoder = StringDecoder;\n\nfunction StringDecoder(encoding) {\n  this.encoding = normalizeEncoding(encoding);\n  var nb;\n\n  switch (this.encoding) {\n    case 'utf16le':\n      this.text = utf16Text;\n      this.end = utf16End;\n      nb = 4;\n      break;\n\n    case 'utf8':\n      this.fillLast = utf8FillLast;\n      nb = 4;\n      break;\n\n    case 'base64':\n      this.text = base64Text;\n      this.end = base64End;\n      nb = 3;\n      break;\n\n    default:\n      this.write = simpleWrite;\n      this.end = simpleEnd;\n      return;\n  }\n\n  this.lastNeed = 0;\n  this.lastTotal = 0;\n  this.lastChar = Buffer.allocUnsafe(nb);\n}\n\nStringDecoder.prototype.write = function (buf) {\n  if (buf.length === 0) return '';\n  var r;\n  var i;\n\n  if (this.lastNeed) {\n    r = this.fillLast(buf);\n    if (r === undefined) return '';\n    i = this.lastNeed;\n    this.lastNeed = 0;\n  } else {\n    i = 0;\n  }\n\n  if (i < buf.length) return r ? r + this.text(buf, i) : this.text(buf, i);\n  return r || '';\n};\n\nStringDecoder.prototype.end = utf8End; // Returns only complete characters in a Buffer\n\nStringDecoder.prototype.text = utf8Text; // Attempts to complete a partial non-UTF-8 character using bytes from a Buffer\n\nStringDecoder.prototype.fillLast = function (buf) {\n  if (this.lastNeed <= buf.length) {\n    buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);\n    return this.lastChar.toString(this.encoding, 0, this.lastTotal);\n  }\n\n  buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);\n  this.lastNeed -= buf.length;\n}; // Checks the type of a UTF-8 byte, whether it's ASCII, a leading byte, or a\n// continuation byte. If an invalid byte is detected, -2 is returned.\n\n\nfunction utf8CheckByte(byte) {\n  if (byte <= 0x7F) return 0;else if (byte >> 5 === 0x06) return 2;else if (byte >> 4 === 0x0E) return 3;else if (byte >> 3 === 0x1E) return 4;\n  return byte >> 6 === 0x02 ? -1 : -2;\n} // Checks at most 3 bytes at the end of a Buffer in order to detect an\n// incomplete multi-byte UTF-8 character. The total number of bytes (2, 3, or 4)\n// needed to complete the UTF-8 character (if applicable) are returned.\n\n\nfunction utf8CheckIncomplete(self, buf, i) {\n  var j = buf.length - 1;\n  if (j < i) return 0;\n  var nb = utf8CheckByte(buf[j]);\n\n  if (nb >= 0) {\n    if (nb > 0) self.lastNeed = nb - 1;\n    return nb;\n  }\n\n  if (--j < i || nb === -2) return 0;\n  nb = utf8CheckByte(buf[j]);\n\n  if (nb >= 0) {\n    if (nb > 0) self.lastNeed = nb - 2;\n    return nb;\n  }\n\n  if (--j < i || nb === -2) return 0;\n  nb = utf8CheckByte(buf[j]);\n\n  if (nb >= 0) {\n    if (nb > 0) {\n      if (nb === 2) nb = 0;else self.lastNeed = nb - 3;\n    }\n\n    return nb;\n  }\n\n  return 0;\n} // Validates as many continuation bytes for a multi-byte UTF-8 character as\n// needed or are available. If we see a non-continuation byte where we expect\n// one, we \"replace\" the validated continuation bytes we've seen so far with\n// a single UTF-8 replacement character ('\\ufffd'), to match v8's UTF-8 decoding\n// behavior. The continuation byte check is included three times in the case\n// where all of the continuation bytes for a character exist in the same buffer.\n// It is also done this way as a slight performance increase instead of using a\n// loop.\n\n\nfunction utf8CheckExtraBytes(self, buf, p) {\n  if ((buf[0] & 0xC0) !== 0x80) {\n    self.lastNeed = 0;\n    return \"\\uFFFD\";\n  }\n\n  if (self.lastNeed > 1 && buf.length > 1) {\n    if ((buf[1] & 0xC0) !== 0x80) {\n      self.lastNeed = 1;\n      return \"\\uFFFD\";\n    }\n\n    if (self.lastNeed > 2 && buf.length > 2) {\n      if ((buf[2] & 0xC0) !== 0x80) {\n        self.lastNeed = 2;\n        return \"\\uFFFD\";\n      }\n    }\n  }\n} // Attempts to complete a multi-byte UTF-8 character using bytes from a Buffer.\n\n\nfunction utf8FillLast(buf) {\n  var p = this.lastTotal - this.lastNeed;\n  var r = utf8CheckExtraBytes(this, buf, p);\n  if (r !== undefined) return r;\n\n  if (this.lastNeed <= buf.length) {\n    buf.copy(this.lastChar, p, 0, this.lastNeed);\n    return this.lastChar.toString(this.encoding, 0, this.lastTotal);\n  }\n\n  buf.copy(this.lastChar, p, 0, buf.length);\n  this.lastNeed -= buf.length;\n} // Returns all complete UTF-8 characters in a Buffer. If the Buffer ended on a\n// partial character, the character's bytes are buffered until the required\n// number of bytes are available.\n\n\nfunction utf8Text(buf, i) {\n  var total = utf8CheckIncomplete(this, buf, i);\n  if (!this.lastNeed) return buf.toString('utf8', i);\n  this.lastTotal = total;\n  var end = buf.length - (total - this.lastNeed);\n  buf.copy(this.lastChar, 0, end);\n  return buf.toString('utf8', i, end);\n} // For UTF-8, a replacement character is added when ending on a partial\n// character.\n\n\nfunction utf8End(buf) {\n  var r = buf && buf.length ? this.write(buf) : '';\n  if (this.lastNeed) return r + \"\\uFFFD\";\n  return r;\n} // UTF-16LE typically needs two bytes per character, but even if we have an even\n// number of bytes available, we need to check if we end on a leading/high\n// surrogate. In that case, we need to wait for the next two bytes in order to\n// decode the last character properly.\n\n\nfunction utf16Text(buf, i) {\n  if ((buf.length - i) % 2 === 0) {\n    var r = buf.toString('utf16le', i);\n\n    if (r) {\n      var c = r.charCodeAt(r.length - 1);\n\n      if (c >= 0xD800 && c <= 0xDBFF) {\n        this.lastNeed = 2;\n        this.lastTotal = 4;\n        this.lastChar[0] = buf[buf.length - 2];\n        this.lastChar[1] = buf[buf.length - 1];\n        return r.slice(0, -1);\n      }\n    }\n\n    return r;\n  }\n\n  this.lastNeed = 1;\n  this.lastTotal = 2;\n  this.lastChar[0] = buf[buf.length - 1];\n  return buf.toString('utf16le', i, buf.length - 1);\n} // For UTF-16LE we do not explicitly append special replacement characters if we\n// end on a partial character, we simply let v8 handle that.\n\n\nfunction utf16End(buf) {\n  var r = buf && buf.length ? this.write(buf) : '';\n\n  if (this.lastNeed) {\n    var end = this.lastTotal - this.lastNeed;\n    return r + this.lastChar.toString('utf16le', 0, end);\n  }\n\n  return r;\n}\n\nfunction base64Text(buf, i) {\n  var n = (buf.length - i) % 3;\n  if (n === 0) return buf.toString('base64', i);\n  this.lastNeed = 3 - n;\n  this.lastTotal = 3;\n\n  if (n === 1) {\n    this.lastChar[0] = buf[buf.length - 1];\n  } else {\n    this.lastChar[0] = buf[buf.length - 2];\n    this.lastChar[1] = buf[buf.length - 1];\n  }\n\n  return buf.toString('base64', i, buf.length - n);\n}\n\nfunction base64End(buf) {\n  var r = buf && buf.length ? this.write(buf) : '';\n  if (this.lastNeed) return r + this.lastChar.toString('base64', 0, 3 - this.lastNeed);\n  return r;\n} // Pass bytes on through for single-byte encodings (e.g. ascii, latin1, hex)\n\n\nfunction simpleWrite(buf) {\n  return buf.toString(this.encoding);\n}\n\nfunction simpleEnd(buf) {\n  return buf && buf.length ? this.write(buf) : '';\n}\n\n//# sourceURL=webpack://WorkBox/./node_modules/string_decoder/lib/string_decoder.js?");

/***/ }),

/***/ "./node_modules/string_decoder/node_modules/safe-buffer/index.js":
/*!***********************************************************************!*\
  !*** ./node_modules/string_decoder/node_modules/safe-buffer/index.js ***!
  \***********************************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval("/*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */\n\n/* eslint-disable node/no-deprecated-api */\nvar buffer = __webpack_require__(/*! buffer */ \"./node_modules/buffer/index.js\");\n\nvar Buffer = buffer.Buffer; // alternative to using Object.keys for old browsers\n\nfunction copyProps(src, dst) {\n  for (var key in src) {\n    dst[key] = src[key];\n  }\n}\n\nif (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {\n  module.exports = buffer;\n} else {\n  // Copy properties from require('buffer')\n  copyProps(buffer, exports);\n  exports.Buffer = SafeBuffer;\n}\n\nfunction SafeBuffer(arg, encodingOrOffset, length) {\n  return Buffer(arg, encodingOrOffset, length);\n}\n\nSafeBuffer.prototype = Object.create(Buffer.prototype); // Copy static methods from Buffer\n\ncopyProps(Buffer, SafeBuffer);\n\nSafeBuffer.from = function (arg, encodingOrOffset, length) {\n  if (typeof arg === 'number') {\n    throw new TypeError('Argument must not be a number');\n  }\n\n  return Buffer(arg, encodingOrOffset, length);\n};\n\nSafeBuffer.alloc = function (size, fill, encoding) {\n  if (typeof size !== 'number') {\n    throw new TypeError('Argument must be a number');\n  }\n\n  var buf = Buffer(size);\n\n  if (fill !== undefined) {\n    if (typeof encoding === 'string') {\n      buf.fill(fill, encoding);\n    } else {\n      buf.fill(fill);\n    }\n  } else {\n    buf.fill(0);\n  }\n\n  return buf;\n};\n\nSafeBuffer.allocUnsafe = function (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('Argument must be a number');\n  }\n\n  return Buffer(size);\n};\n\nSafeBuffer.allocUnsafeSlow = function (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('Argument must be a number');\n  }\n\n  return buffer.SlowBuffer(size);\n};\n\n//# sourceURL=webpack://WorkBox/./node_modules/string_decoder/node_modules/safe-buffer/index.js?");

/***/ }),

/***/ "./node_modules/ytdl-core/lib/cache.js":
/*!*********************************************!*\
  !*** ./node_modules/ytdl-core/lib/cache.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("function _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }\n\nfunction _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err); } _next(undefined); }); }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _get(target, property, receiver) { if (typeof Reflect !== \"undefined\" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }\n\nfunction _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } else if (call !== void 0) { throw new TypeError(\"Derived constructors may only return object or undefined\"); } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _wrapNativeSuper(Class) { var _cache = typeof Map === \"function\" ? new Map() : undefined; _wrapNativeSuper = function _wrapNativeSuper(Class) { if (Class === null || !_isNativeFunction(Class)) return Class; if (typeof Class !== \"function\") { throw new TypeError(\"Super expression must either be null or a function\"); } if (typeof _cache !== \"undefined\") { if (_cache.has(Class)) return _cache.get(Class); _cache.set(Class, Wrapper); } function Wrapper() { return _construct(Class, arguments, _getPrototypeOf(this).constructor); } Wrapper.prototype = Object.create(Class.prototype, { constructor: { value: Wrapper, enumerable: false, writable: true, configurable: true } }); return _setPrototypeOf(Wrapper, Class); }; return _wrapNativeSuper(Class); }\n\nfunction _construct(Parent, args, Class) { if (_isNativeReflectConstruct()) { _construct = Reflect.construct; } else { _construct = function _construct(Parent, args, Class) { var a = [null]; a.push.apply(a, args); var Constructor = Function.bind.apply(Parent, a); var instance = new Constructor(); if (Class) _setPrototypeOf(instance, Class.prototype); return instance; }; } return _construct.apply(null, arguments); }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _isNativeFunction(fn) { return Function.toString.call(fn).indexOf(\"[native code]\") !== -1; }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nvar _require = __webpack_require__(Object(function webpackMissingModule() { var e = new Error(\"Cannot find module 'timers'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }())),\n    setTimeout = _require.setTimeout; // A cache that expires.\n\n\nmodule.exports = /*#__PURE__*/function (_Map) {\n  _inherits(Cache, _Map);\n\n  var _super = _createSuper(Cache);\n\n  function Cache() {\n    var _this;\n\n    var timeout = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1000;\n\n    _classCallCheck(this, Cache);\n\n    _this = _super.call(this);\n    _this.timeout = timeout;\n    return _this;\n  }\n\n  _createClass(Cache, [{\n    key: \"set\",\n    value: function set(key, value) {\n      if (this.has(key)) {\n        clearTimeout(_get(_getPrototypeOf(Cache.prototype), \"get\", this).call(this, key).tid);\n      }\n\n      _get(_getPrototypeOf(Cache.prototype), \"set\", this).call(this, key, {\n        tid: setTimeout(this.delete.bind(this, key), this.timeout).unref(),\n        value: value\n      });\n    }\n  }, {\n    key: \"get\",\n    value: function get(key) {\n      var entry = _get(_getPrototypeOf(Cache.prototype), \"get\", this).call(this, key);\n\n      if (entry) {\n        return entry.value;\n      }\n\n      return null;\n    }\n  }, {\n    key: \"getOrSet\",\n    value: function getOrSet(key, fn) {\n      var _this2 = this;\n\n      if (this.has(key)) {\n        return this.get(key);\n      } else {\n        var value = fn();\n        this.set(key, value);\n\n        _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {\n          return regeneratorRuntime.wrap(function _callee$(_context) {\n            while (1) {\n              switch (_context.prev = _context.next) {\n                case 0:\n                  _context.prev = 0;\n                  _context.next = 3;\n                  return value;\n\n                case 3:\n                  _context.next = 8;\n                  break;\n\n                case 5:\n                  _context.prev = 5;\n                  _context.t0 = _context[\"catch\"](0);\n\n                  _this2.delete(key);\n\n                case 8:\n                case \"end\":\n                  return _context.stop();\n              }\n            }\n          }, _callee, null, [[0, 5]]);\n        }))();\n\n        return value;\n      }\n    }\n  }, {\n    key: \"delete\",\n    value: function _delete(key) {\n      var entry = _get(_getPrototypeOf(Cache.prototype), \"get\", this).call(this, key);\n\n      if (entry) {\n        clearTimeout(entry.tid);\n\n        _get(_getPrototypeOf(Cache.prototype), \"delete\", this).call(this, key);\n      }\n    }\n  }, {\n    key: \"clear\",\n    value: function clear() {\n      var _iterator = _createForOfIteratorHelper(this.values()),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var entry = _step.value;\n          clearTimeout(entry.tid);\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n\n      _get(_getPrototypeOf(Cache.prototype), \"clear\", this).call(this);\n    }\n  }]);\n\n  return Cache;\n}( /*#__PURE__*/_wrapNativeSuper(Map));\n\n//# sourceURL=webpack://WorkBox/./node_modules/ytdl-core/lib/cache.js?");

/***/ }),

/***/ "./node_modules/ytdl-core/lib/format-utils.js":
/*!****************************************************!*\
  !*** ./node_modules/ytdl-core/lib/format-utils.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("function _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nvar utils = __webpack_require__(/*! ./utils */ \"./node_modules/ytdl-core/lib/utils.js\");\n\nvar FORMATS = __webpack_require__(/*! ./formats */ \"./node_modules/ytdl-core/lib/formats.js\"); // Use these to help sort formats, higher index is better.\n\n\nvar audioEncodingRanks = ['mp4a', 'mp3', 'vorbis', 'aac', 'opus', 'flac'];\nvar videoEncodingRanks = ['mp4v', 'avc1', 'Sorenson H.283', 'MPEG-4 Visual', 'VP8', 'VP9', 'H.264'];\n\nvar getVideoBitrate = function getVideoBitrate(format) {\n  return format.bitrate || 0;\n};\n\nvar getVideoEncodingRank = function getVideoEncodingRank(format) {\n  return videoEncodingRanks.findIndex(function (enc) {\n    return format.codecs && format.codecs.includes(enc);\n  });\n};\n\nvar getAudioBitrate = function getAudioBitrate(format) {\n  return format.audioBitrate || 0;\n};\n\nvar getAudioEncodingRank = function getAudioEncodingRank(format) {\n  return audioEncodingRanks.findIndex(function (enc) {\n    return format.codecs && format.codecs.includes(enc);\n  });\n};\n/**\n * Sort formats by a list of functions.\n *\n * @param {Object} a\n * @param {Object} b\n * @param {Array.<Function>} sortBy\n * @returns {number}\n */\n\n\nvar sortFormatsBy = function sortFormatsBy(a, b, sortBy) {\n  var res = 0;\n\n  var _iterator = _createForOfIteratorHelper(sortBy),\n      _step;\n\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var fn = _step.value;\n      res = fn(b) - fn(a);\n\n      if (res !== 0) {\n        break;\n      }\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n\n  return res;\n};\n\nvar sortFormatsByVideo = function sortFormatsByVideo(a, b) {\n  return sortFormatsBy(a, b, [function (format) {\n    return parseInt(format.qualityLabel);\n  }, getVideoBitrate, getVideoEncodingRank]);\n};\n\nvar sortFormatsByAudio = function sortFormatsByAudio(a, b) {\n  return sortFormatsBy(a, b, [getAudioBitrate, getAudioEncodingRank]);\n};\n/**\n * Sort formats from highest quality to lowest.\n *\n * @param {Object} a\n * @param {Object} b\n * @returns {number}\n */\n\n\nexports.sortFormats = function (a, b) {\n  return sortFormatsBy(a, b, [// Formats with both video and audio are ranked highest.\n  function (format) {\n    return +!!format.isHLS;\n  }, function (format) {\n    return +!!format.isDashMPD;\n  }, function (format) {\n    return +(format.contentLength > 0);\n  }, function (format) {\n    return +(format.hasVideo && format.hasAudio);\n  }, function (format) {\n    return +format.hasVideo;\n  }, function (format) {\n    return parseInt(format.qualityLabel) || 0;\n  }, getVideoBitrate, getAudioBitrate, getVideoEncodingRank, getAudioEncodingRank]);\n};\n/**\n * Choose a format depending on the given options.\n *\n * @param {Array.<Object>} formats\n * @param {Object} options\n * @returns {Object}\n * @throws {Error} when no format matches the filter/format rules\n */\n\n\nexports.chooseFormat = function (formats, options) {\n  if (_typeof(options.format) === 'object') {\n    if (!options.format.url) {\n      throw Error('Invalid format given, did you use `ytdl.getInfo()`?');\n    }\n\n    return options.format;\n  }\n\n  if (options.filter) {\n    formats = exports.filterFormats(formats, options.filter);\n  } // We currently only support HLS-Formats for livestreams\n  // So we (now) remove all non-HLS streams\n\n\n  if (formats.some(function (fmt) {\n    return fmt.isHLS;\n  })) {\n    formats = formats.filter(function (fmt) {\n      return fmt.isHLS || !fmt.isLive;\n    });\n  }\n\n  var format;\n  var quality = options.quality || 'highest';\n\n  switch (quality) {\n    case 'highest':\n      format = formats[0];\n      break;\n\n    case 'lowest':\n      format = formats[formats.length - 1];\n      break;\n\n    case 'highestaudio':\n      {\n        formats = exports.filterFormats(formats, 'audio');\n        formats.sort(sortFormatsByAudio); // Filter for only the best audio format\n\n        var bestAudioFormat = formats[0];\n        formats = formats.filter(function (f) {\n          return sortFormatsByAudio(bestAudioFormat, f) === 0;\n        }); // Check for the worst video quality for the best audio quality and pick according\n        // This does not loose default sorting of video encoding and bitrate\n\n        var worstVideoQuality = formats.map(function (f) {\n          return parseInt(f.qualityLabel) || 0;\n        }).sort(function (a, b) {\n          return a - b;\n        })[0];\n        format = formats.find(function (f) {\n          return (parseInt(f.qualityLabel) || 0) === worstVideoQuality;\n        });\n        break;\n      }\n\n    case 'lowestaudio':\n      formats = exports.filterFormats(formats, 'audio');\n      formats.sort(sortFormatsByAudio);\n      format = formats[formats.length - 1];\n      break;\n\n    case 'highestvideo':\n      {\n        formats = exports.filterFormats(formats, 'video');\n        formats.sort(sortFormatsByVideo); // Filter for only the best video format\n\n        var bestVideoFormat = formats[0];\n        formats = formats.filter(function (f) {\n          return sortFormatsByVideo(bestVideoFormat, f) === 0;\n        }); // Check for the worst audio quality for the best video quality and pick according\n        // This does not loose default sorting of audio encoding and bitrate\n\n        var worstAudioQuality = formats.map(function (f) {\n          return f.audioBitrate || 0;\n        }).sort(function (a, b) {\n          return a - b;\n        })[0];\n        format = formats.find(function (f) {\n          return (f.audioBitrate || 0) === worstAudioQuality;\n        });\n        break;\n      }\n\n    case 'lowestvideo':\n      formats = exports.filterFormats(formats, 'video');\n      formats.sort(sortFormatsByVideo);\n      format = formats[formats.length - 1];\n      break;\n\n    default:\n      format = getFormatByQuality(quality, formats);\n      break;\n  }\n\n  if (!format) {\n    throw Error(\"No such format found: \".concat(quality));\n  }\n\n  return format;\n};\n/**\n * Gets a format based on quality or array of quality's\n *\n * @param {string|[string]} quality\n * @param {[Object]} formats\n * @returns {Object}\n */\n\n\nvar getFormatByQuality = function getFormatByQuality(quality, formats) {\n  var getFormat = function getFormat(itag) {\n    return formats.find(function (format) {\n      return \"\".concat(format.itag) === \"\".concat(itag);\n    });\n  };\n\n  if (Array.isArray(quality)) {\n    return getFormat(quality.find(function (q) {\n      return getFormat(q);\n    }));\n  } else {\n    return getFormat(quality);\n  }\n};\n/**\n * @param {Array.<Object>} formats\n * @param {Function} filter\n * @returns {Array.<Object>}\n */\n\n\nexports.filterFormats = function (formats, filter) {\n  var fn;\n\n  switch (filter) {\n    case 'videoandaudio':\n    case 'audioandvideo':\n      fn = function fn(format) {\n        return format.hasVideo && format.hasAudio;\n      };\n\n      break;\n\n    case 'video':\n      fn = function fn(format) {\n        return format.hasVideo;\n      };\n\n      break;\n\n    case 'videoonly':\n      fn = function fn(format) {\n        return format.hasVideo && !format.hasAudio;\n      };\n\n      break;\n\n    case 'audio':\n      fn = function fn(format) {\n        return format.hasAudio;\n      };\n\n      break;\n\n    case 'audioonly':\n      fn = function fn(format) {\n        return !format.hasVideo && format.hasAudio;\n      };\n\n      break;\n\n    default:\n      if (typeof filter === 'function') {\n        fn = filter;\n      } else {\n        throw TypeError(\"Given filter (\".concat(filter, \") is not supported\"));\n      }\n\n  }\n\n  return formats.filter(function (format) {\n    return !!format.url && fn(format);\n  });\n};\n/**\n * @param {Object} format\n * @returns {Object}\n */\n\n\nexports.addFormatMeta = function (format) {\n  format = Object.assign({}, FORMATS[format.itag], format);\n  format.hasVideo = !!format.qualityLabel;\n  format.hasAudio = !!format.audioBitrate;\n  format.container = format.mimeType ? format.mimeType.split(';')[0].split('/')[1] : null;\n  format.codecs = format.mimeType ? utils.between(format.mimeType, 'codecs=\"', '\"') : null;\n  format.videoCodec = format.hasVideo && format.codecs ? format.codecs.split(', ')[0] : null;\n  format.audioCodec = format.hasAudio && format.codecs ? format.codecs.split(', ').slice(-1)[0] : null;\n  format.isLive = /\\bsource[/=]yt_live_broadcast\\b/.test(format.url);\n  format.isHLS = /\\/manifest\\/hls_(variant|playlist)\\//.test(format.url);\n  format.isDashMPD = /\\/manifest\\/dash\\//.test(format.url);\n  return format;\n};\n\n//# sourceURL=webpack://WorkBox/./node_modules/ytdl-core/lib/format-utils.js?");

/***/ }),

/***/ "./node_modules/ytdl-core/lib/formats.js":
/*!***********************************************!*\
  !*** ./node_modules/ytdl-core/lib/formats.js ***!
  \***********************************************/
/***/ ((module) => {

eval("/**\n * http://en.wikipedia.org/wiki/YouTube#Quality_and_formats\n */\nmodule.exports = {\n  5: {\n    mimeType: 'video/flv; codecs=\"Sorenson H.283, mp3\"',\n    qualityLabel: '240p',\n    bitrate: 250000,\n    audioBitrate: 64\n  },\n  6: {\n    mimeType: 'video/flv; codecs=\"Sorenson H.263, mp3\"',\n    qualityLabel: '270p',\n    bitrate: 800000,\n    audioBitrate: 64\n  },\n  13: {\n    mimeType: 'video/3gp; codecs=\"MPEG-4 Visual, aac\"',\n    qualityLabel: null,\n    bitrate: 500000,\n    audioBitrate: null\n  },\n  17: {\n    mimeType: 'video/3gp; codecs=\"MPEG-4 Visual, aac\"',\n    qualityLabel: '144p',\n    bitrate: 50000,\n    audioBitrate: 24\n  },\n  18: {\n    mimeType: 'video/mp4; codecs=\"H.264, aac\"',\n    qualityLabel: '360p',\n    bitrate: 500000,\n    audioBitrate: 96\n  },\n  22: {\n    mimeType: 'video/mp4; codecs=\"H.264, aac\"',\n    qualityLabel: '720p',\n    bitrate: 2000000,\n    audioBitrate: 192\n  },\n  34: {\n    mimeType: 'video/flv; codecs=\"H.264, aac\"',\n    qualityLabel: '360p',\n    bitrate: 500000,\n    audioBitrate: 128\n  },\n  35: {\n    mimeType: 'video/flv; codecs=\"H.264, aac\"',\n    qualityLabel: '480p',\n    bitrate: 800000,\n    audioBitrate: 128\n  },\n  36: {\n    mimeType: 'video/3gp; codecs=\"MPEG-4 Visual, aac\"',\n    qualityLabel: '240p',\n    bitrate: 175000,\n    audioBitrate: 32\n  },\n  37: {\n    mimeType: 'video/mp4; codecs=\"H.264, aac\"',\n    qualityLabel: '1080p',\n    bitrate: 3000000,\n    audioBitrate: 192\n  },\n  38: {\n    mimeType: 'video/mp4; codecs=\"H.264, aac\"',\n    qualityLabel: '3072p',\n    bitrate: 3500000,\n    audioBitrate: 192\n  },\n  43: {\n    mimeType: 'video/webm; codecs=\"VP8, vorbis\"',\n    qualityLabel: '360p',\n    bitrate: 500000,\n    audioBitrate: 128\n  },\n  44: {\n    mimeType: 'video/webm; codecs=\"VP8, vorbis\"',\n    qualityLabel: '480p',\n    bitrate: 1000000,\n    audioBitrate: 128\n  },\n  45: {\n    mimeType: 'video/webm; codecs=\"VP8, vorbis\"',\n    qualityLabel: '720p',\n    bitrate: 2000000,\n    audioBitrate: 192\n  },\n  46: {\n    mimeType: 'audio/webm; codecs=\"vp8, vorbis\"',\n    qualityLabel: '1080p',\n    bitrate: null,\n    audioBitrate: 192\n  },\n  82: {\n    mimeType: 'video/mp4; codecs=\"H.264, aac\"',\n    qualityLabel: '360p',\n    bitrate: 500000,\n    audioBitrate: 96\n  },\n  83: {\n    mimeType: 'video/mp4; codecs=\"H.264, aac\"',\n    qualityLabel: '240p',\n    bitrate: 500000,\n    audioBitrate: 96\n  },\n  84: {\n    mimeType: 'video/mp4; codecs=\"H.264, aac\"',\n    qualityLabel: '720p',\n    bitrate: 2000000,\n    audioBitrate: 192\n  },\n  85: {\n    mimeType: 'video/mp4; codecs=\"H.264, aac\"',\n    qualityLabel: '1080p',\n    bitrate: 3000000,\n    audioBitrate: 192\n  },\n  91: {\n    mimeType: 'video/ts; codecs=\"H.264, aac\"',\n    qualityLabel: '144p',\n    bitrate: 100000,\n    audioBitrate: 48\n  },\n  92: {\n    mimeType: 'video/ts; codecs=\"H.264, aac\"',\n    qualityLabel: '240p',\n    bitrate: 150000,\n    audioBitrate: 48\n  },\n  93: {\n    mimeType: 'video/ts; codecs=\"H.264, aac\"',\n    qualityLabel: '360p',\n    bitrate: 500000,\n    audioBitrate: 128\n  },\n  94: {\n    mimeType: 'video/ts; codecs=\"H.264, aac\"',\n    qualityLabel: '480p',\n    bitrate: 800000,\n    audioBitrate: 128\n  },\n  95: {\n    mimeType: 'video/ts; codecs=\"H.264, aac\"',\n    qualityLabel: '720p',\n    bitrate: 1500000,\n    audioBitrate: 256\n  },\n  96: {\n    mimeType: 'video/ts; codecs=\"H.264, aac\"',\n    qualityLabel: '1080p',\n    bitrate: 2500000,\n    audioBitrate: 256\n  },\n  100: {\n    mimeType: 'audio/webm; codecs=\"VP8, vorbis\"',\n    qualityLabel: '360p',\n    bitrate: null,\n    audioBitrate: 128\n  },\n  101: {\n    mimeType: 'audio/webm; codecs=\"VP8, vorbis\"',\n    qualityLabel: '360p',\n    bitrate: null,\n    audioBitrate: 192\n  },\n  102: {\n    mimeType: 'audio/webm; codecs=\"VP8, vorbis\"',\n    qualityLabel: '720p',\n    bitrate: null,\n    audioBitrate: 192\n  },\n  120: {\n    mimeType: 'video/flv; codecs=\"H.264, aac\"',\n    qualityLabel: '720p',\n    bitrate: 2000000,\n    audioBitrate: 128\n  },\n  127: {\n    mimeType: 'audio/ts; codecs=\"aac\"',\n    qualityLabel: null,\n    bitrate: null,\n    audioBitrate: 96\n  },\n  128: {\n    mimeType: 'audio/ts; codecs=\"aac\"',\n    qualityLabel: null,\n    bitrate: null,\n    audioBitrate: 96\n  },\n  132: {\n    mimeType: 'video/ts; codecs=\"H.264, aac\"',\n    qualityLabel: '240p',\n    bitrate: 150000,\n    audioBitrate: 48\n  },\n  133: {\n    mimeType: 'video/mp4; codecs=\"H.264\"',\n    qualityLabel: '240p',\n    bitrate: 200000,\n    audioBitrate: null\n  },\n  134: {\n    mimeType: 'video/mp4; codecs=\"H.264\"',\n    qualityLabel: '360p',\n    bitrate: 300000,\n    audioBitrate: null\n  },\n  135: {\n    mimeType: 'video/mp4; codecs=\"H.264\"',\n    qualityLabel: '480p',\n    bitrate: 500000,\n    audioBitrate: null\n  },\n  136: {\n    mimeType: 'video/mp4; codecs=\"H.264\"',\n    qualityLabel: '720p',\n    bitrate: 1000000,\n    audioBitrate: null\n  },\n  137: {\n    mimeType: 'video/mp4; codecs=\"H.264\"',\n    qualityLabel: '1080p',\n    bitrate: 2500000,\n    audioBitrate: null\n  },\n  138: {\n    mimeType: 'video/mp4; codecs=\"H.264\"',\n    qualityLabel: '4320p',\n    bitrate: 13500000,\n    audioBitrate: null\n  },\n  139: {\n    mimeType: 'audio/mp4; codecs=\"aac\"',\n    qualityLabel: null,\n    bitrate: null,\n    audioBitrate: 48\n  },\n  140: {\n    mimeType: 'audio/m4a; codecs=\"aac\"',\n    qualityLabel: null,\n    bitrate: null,\n    audioBitrate: 128\n  },\n  141: {\n    mimeType: 'audio/mp4; codecs=\"aac\"',\n    qualityLabel: null,\n    bitrate: null,\n    audioBitrate: 256\n  },\n  151: {\n    mimeType: 'video/ts; codecs=\"H.264, aac\"',\n    qualityLabel: '720p',\n    bitrate: 50000,\n    audioBitrate: 24\n  },\n  160: {\n    mimeType: 'video/mp4; codecs=\"H.264\"',\n    qualityLabel: '144p',\n    bitrate: 100000,\n    audioBitrate: null\n  },\n  171: {\n    mimeType: 'audio/webm; codecs=\"vorbis\"',\n    qualityLabel: null,\n    bitrate: null,\n    audioBitrate: 128\n  },\n  172: {\n    mimeType: 'audio/webm; codecs=\"vorbis\"',\n    qualityLabel: null,\n    bitrate: null,\n    audioBitrate: 192\n  },\n  242: {\n    mimeType: 'video/webm; codecs=\"VP9\"',\n    qualityLabel: '240p',\n    bitrate: 100000,\n    audioBitrate: null\n  },\n  243: {\n    mimeType: 'video/webm; codecs=\"VP9\"',\n    qualityLabel: '360p',\n    bitrate: 250000,\n    audioBitrate: null\n  },\n  244: {\n    mimeType: 'video/webm; codecs=\"VP9\"',\n    qualityLabel: '480p',\n    bitrate: 500000,\n    audioBitrate: null\n  },\n  247: {\n    mimeType: 'video/webm; codecs=\"VP9\"',\n    qualityLabel: '720p',\n    bitrate: 700000,\n    audioBitrate: null\n  },\n  248: {\n    mimeType: 'video/webm; codecs=\"VP9\"',\n    qualityLabel: '1080p',\n    bitrate: 1500000,\n    audioBitrate: null\n  },\n  249: {\n    mimeType: 'audio/webm; codecs=\"opus\"',\n    qualityLabel: null,\n    bitrate: null,\n    audioBitrate: 48\n  },\n  250: {\n    mimeType: 'audio/webm; codecs=\"opus\"',\n    qualityLabel: null,\n    bitrate: null,\n    audioBitrate: 64\n  },\n  251: {\n    mimeType: 'audio/webm; codecs=\"opus\"',\n    qualityLabel: null,\n    bitrate: null,\n    audioBitrate: 160\n  },\n  264: {\n    mimeType: 'video/mp4; codecs=\"H.264\"',\n    qualityLabel: '1440p',\n    bitrate: 4000000,\n    audioBitrate: null\n  },\n  266: {\n    mimeType: 'video/mp4; codecs=\"H.264\"',\n    qualityLabel: '2160p',\n    bitrate: 12500000,\n    audioBitrate: null\n  },\n  271: {\n    mimeType: 'video/webm; codecs=\"VP9\"',\n    qualityLabel: '1440p',\n    bitrate: 9000000,\n    audioBitrate: null\n  },\n  272: {\n    mimeType: 'video/webm; codecs=\"VP9\"',\n    qualityLabel: '4320p',\n    bitrate: 20000000,\n    audioBitrate: null\n  },\n  278: {\n    mimeType: 'video/webm; codecs=\"VP9\"',\n    qualityLabel: '144p 30fps',\n    bitrate: 80000,\n    audioBitrate: null\n  },\n  298: {\n    mimeType: 'video/mp4; codecs=\"H.264\"',\n    qualityLabel: '720p',\n    bitrate: 3000000,\n    audioBitrate: null\n  },\n  299: {\n    mimeType: 'video/mp4; codecs=\"H.264\"',\n    qualityLabel: '1080p',\n    bitrate: 5500000,\n    audioBitrate: null\n  },\n  300: {\n    mimeType: 'video/ts; codecs=\"H.264, aac\"',\n    qualityLabel: '720p',\n    bitrate: 1318000,\n    audioBitrate: 48\n  },\n  302: {\n    mimeType: 'video/webm; codecs=\"VP9\"',\n    qualityLabel: '720p HFR',\n    bitrate: 2500000,\n    audioBitrate: null\n  },\n  303: {\n    mimeType: 'video/webm; codecs=\"VP9\"',\n    qualityLabel: '1080p HFR',\n    bitrate: 5000000,\n    audioBitrate: null\n  },\n  308: {\n    mimeType: 'video/webm; codecs=\"VP9\"',\n    qualityLabel: '1440p HFR',\n    bitrate: 10000000,\n    audioBitrate: null\n  },\n  313: {\n    mimeType: 'video/webm; codecs=\"VP9\"',\n    qualityLabel: '2160p',\n    bitrate: 13000000,\n    audioBitrate: null\n  },\n  315: {\n    mimeType: 'video/webm; codecs=\"VP9\"',\n    qualityLabel: '2160p HFR',\n    bitrate: 20000000,\n    audioBitrate: null\n  },\n  330: {\n    mimeType: 'video/webm; codecs=\"VP9\"',\n    qualityLabel: '144p HDR, HFR',\n    bitrate: 80000,\n    audioBitrate: null\n  },\n  331: {\n    mimeType: 'video/webm; codecs=\"VP9\"',\n    qualityLabel: '240p HDR, HFR',\n    bitrate: 100000,\n    audioBitrate: null\n  },\n  332: {\n    mimeType: 'video/webm; codecs=\"VP9\"',\n    qualityLabel: '360p HDR, HFR',\n    bitrate: 250000,\n    audioBitrate: null\n  },\n  333: {\n    mimeType: 'video/webm; codecs=\"VP9\"',\n    qualityLabel: '240p HDR, HFR',\n    bitrate: 500000,\n    audioBitrate: null\n  },\n  334: {\n    mimeType: 'video/webm; codecs=\"VP9\"',\n    qualityLabel: '720p HDR, HFR',\n    bitrate: 1000000,\n    audioBitrate: null\n  },\n  335: {\n    mimeType: 'video/webm; codecs=\"VP9\"',\n    qualityLabel: '1080p HDR, HFR',\n    bitrate: 1500000,\n    audioBitrate: null\n  },\n  336: {\n    mimeType: 'video/webm; codecs=\"VP9\"',\n    qualityLabel: '1440p HDR, HFR',\n    bitrate: 5000000,\n    audioBitrate: null\n  },\n  337: {\n    mimeType: 'video/webm; codecs=\"VP9\"',\n    qualityLabel: '2160p HDR, HFR',\n    bitrate: 12000000,\n    audioBitrate: null\n  }\n};\n\n//# sourceURL=webpack://WorkBox/./node_modules/ytdl-core/lib/formats.js?");

/***/ }),

/***/ "./node_modules/ytdl-core/lib/index.js":
/*!*********************************************!*\
  !*** ./node_modules/ytdl-core/lib/index.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var PassThrough = Object(function webpackMissingModule() { var e = new Error(\"Cannot find module 'stream'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }());\n\nvar getInfo = __webpack_require__(/*! ./info */ \"./node_modules/ytdl-core/lib/info.js\");\n\nvar utils = __webpack_require__(/*! ./utils */ \"./node_modules/ytdl-core/lib/utils.js\");\n\nvar formatUtils = __webpack_require__(/*! ./format-utils */ \"./node_modules/ytdl-core/lib/format-utils.js\");\n\nvar urlUtils = __webpack_require__(/*! ./url-utils */ \"./node_modules/ytdl-core/lib/url-utils.js\");\n\nvar sig = __webpack_require__(/*! ./sig */ \"./node_modules/ytdl-core/lib/sig.js\");\n\nvar miniget = __webpack_require__(/*! miniget */ \"./node_modules/miniget/dist/index.js\");\n\nvar m3u8stream = __webpack_require__(/*! m3u8stream */ \"./node_modules/m3u8stream/dist/index.js\");\n\nvar _require = __webpack_require__(/*! m3u8stream */ \"./node_modules/m3u8stream/dist/index.js\"),\n    parseTimestamp = _require.parseTimestamp;\n/**\n * @param {string} link\n * @param {!Object} options\n * @returns {ReadableStream}\n */\n\n\nvar ytdl = function ytdl(link, options) {\n  var stream = createStream(options);\n  ytdl.getInfo(link, options).then(function (info) {\n    downloadFromInfoCallback(stream, info, options);\n  }, stream.emit.bind(stream, 'error'));\n  return stream;\n};\n\nmodule.exports = ytdl;\nytdl.getBasicInfo = getInfo.getBasicInfo;\nytdl.getInfo = getInfo.getInfo;\nytdl.chooseFormat = formatUtils.chooseFormat;\nytdl.filterFormats = formatUtils.filterFormats;\nytdl.validateID = urlUtils.validateID;\nytdl.validateURL = urlUtils.validateURL;\nytdl.getURLVideoID = urlUtils.getURLVideoID;\nytdl.getVideoID = urlUtils.getVideoID;\nytdl.cache = {\n  sig: sig.cache,\n  info: getInfo.cache,\n  watch: getInfo.watchPageCache,\n  cookie: getInfo.cookieCache\n};\nytdl.version = (__webpack_require__(/*! ../package.json */ \"./node_modules/ytdl-core/package.json\").version);\n\nvar createStream = function createStream(options) {\n  var stream = new PassThrough({\n    highWaterMark: options && options.highWaterMark || 1024 * 512\n  });\n\n  stream._destroy = function () {\n    stream.destroyed = true;\n  };\n\n  return stream;\n};\n\nvar pipeAndSetEvents = function pipeAndSetEvents(req, stream, end) {\n  // Forward events from the request to the stream.\n  ['abort', 'request', 'response', 'error', 'redirect', 'retry', 'reconnect'].forEach(function (event) {\n    req.prependListener(event, stream.emit.bind(stream, event));\n  });\n  req.pipe(stream, {\n    end: end\n  });\n};\n/**\n * Chooses a format to download.\n *\n * @param {stream.Readable} stream\n * @param {Object} info\n * @param {Object} options\n */\n\n\nvar downloadFromInfoCallback = function downloadFromInfoCallback(stream, info, options) {\n  options = options || {};\n  var err = utils.playError(info.player_response, ['UNPLAYABLE', 'LIVE_STREAM_OFFLINE', 'LOGIN_REQUIRED']);\n\n  if (err) {\n    stream.emit('error', err);\n    return;\n  }\n\n  if (!info.formats.length) {\n    stream.emit('error', Error('This video is unavailable'));\n    return;\n  }\n\n  var format;\n\n  try {\n    format = formatUtils.chooseFormat(info.formats, options);\n  } catch (e) {\n    stream.emit('error', e);\n    return;\n  }\n\n  stream.emit('info', info, format);\n\n  if (stream.destroyed) {\n    return;\n  }\n\n  var contentLength,\n      downloaded = 0;\n\n  var ondata = function ondata(chunk) {\n    downloaded += chunk.length;\n    stream.emit('progress', chunk.length, downloaded, contentLength);\n  }; // Download the file in chunks, in this case the default is 10MB,\n  // anything over this will cause youtube to throttle the download\n\n\n  var dlChunkSize = options.dlChunkSize || 1024 * 1024 * 10;\n  var req;\n  var shouldEnd = true;\n\n  if (format.isHLS || format.isDashMPD) {\n    req = m3u8stream(format.url, {\n      chunkReadahead: +info.live_chunk_readahead,\n      begin: options.begin || format.isLive && Date.now(),\n      liveBuffer: options.liveBuffer,\n      requestOptions: options.requestOptions,\n      parser: format.isDashMPD ? 'dash-mpd' : 'm3u8',\n      id: format.itag\n    });\n    req.on('progress', function (segment, totalSegments) {\n      stream.emit('progress', segment.size, segment.num, totalSegments);\n    });\n    pipeAndSetEvents(req, stream, shouldEnd);\n  } else {\n    var requestOptions = Object.assign({}, options.requestOptions, {\n      maxReconnects: 6,\n      maxRetries: 3,\n      backoff: {\n        inc: 500,\n        max: 10000\n      }\n    });\n    var shouldBeChunked = dlChunkSize !== 0 && (!format.hasAudio || !format.hasVideo);\n\n    if (shouldBeChunked) {\n      var start = options.range && options.range.start || 0;\n      var end = start + dlChunkSize;\n      var rangeEnd = options.range && options.range.end;\n      contentLength = options.range ? (rangeEnd ? rangeEnd + 1 : parseInt(format.contentLength)) - start : parseInt(format.contentLength);\n\n      var getNextChunk = function getNextChunk() {\n        if (!rangeEnd && end >= contentLength) end = 0;\n        if (rangeEnd && end > rangeEnd) end = rangeEnd;\n        shouldEnd = !end || end === rangeEnd;\n        requestOptions.headers = Object.assign({}, requestOptions.headers, {\n          Range: \"bytes=\".concat(start, \"-\").concat(end || '')\n        });\n        req = miniget(format.url, requestOptions);\n        req.on('data', ondata);\n        req.on('end', function () {\n          if (stream.destroyed) {\n            return;\n          }\n\n          if (end && end !== rangeEnd) {\n            start = end + 1;\n            end += dlChunkSize;\n            getNextChunk();\n          }\n        });\n        pipeAndSetEvents(req, stream, shouldEnd);\n      };\n\n      getNextChunk();\n    } else {\n      // Audio only and video only formats don't support begin\n      if (options.begin) {\n        format.url += \"&begin=\".concat(parseTimestamp(options.begin));\n      }\n\n      if (options.range && (options.range.start || options.range.end)) {\n        requestOptions.headers = Object.assign({}, requestOptions.headers, {\n          Range: \"bytes=\".concat(options.range.start || '0', \"-\").concat(options.range.end || '')\n        });\n      }\n\n      req = miniget(format.url, requestOptions);\n      req.on('response', function (res) {\n        if (stream.destroyed) {\n          return;\n        }\n\n        contentLength = contentLength || parseInt(res.headers['content-length']);\n      });\n      req.on('data', ondata);\n      pipeAndSetEvents(req, stream, shouldEnd);\n    }\n  }\n\n  stream._destroy = function () {\n    stream.destroyed = true;\n    req.destroy();\n    req.end();\n  };\n};\n/**\n * Can be used to download video after its `info` is gotten through\n * `ytdl.getInfo()`. In case the user might want to look at the\n * `info` object before deciding to download.\n *\n * @param {Object} info\n * @param {!Object} options\n * @returns {ReadableStream}\n */\n\n\nytdl.downloadFromInfo = function (info, options) {\n  var stream = createStream(options);\n\n  if (!info.full) {\n    throw Error('Cannot use `ytdl.downloadFromInfo()` when called ' + 'with info from `ytdl.getBasicInfo()`');\n  }\n\n  setImmediate(function () {\n    downloadFromInfoCallback(stream, info, options);\n  });\n  return stream;\n};\n\n//# sourceURL=webpack://WorkBox/./node_modules/ytdl-core/lib/index.js?");

/***/ }),

/***/ "./node_modules/ytdl-core/lib/info-extras.js":
/*!***************************************************!*\
  !*** ./node_modules/ytdl-core/lib/info-extras.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\n\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== \"undefined\" && arr[Symbol.iterator] || arr[\"@@iterator\"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e2) { throw _e2; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e3) { didErr = true; err = _e3; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nvar utils = __webpack_require__(/*! ./utils */ \"./node_modules/ytdl-core/lib/utils.js\");\n\nvar qs = __webpack_require__(Object(function webpackMissingModule() { var e = new Error(\"Cannot find module 'querystring'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }()));\n\nvar _require = __webpack_require__(/*! m3u8stream */ \"./node_modules/m3u8stream/dist/index.js\"),\n    parseTimestamp = _require.parseTimestamp;\n\nvar BASE_URL = 'https://www.youtube.com/watch?v=';\nvar TITLE_TO_CATEGORY = {\n  song: {\n    name: 'Music',\n    url: 'https://music.youtube.com/'\n  }\n};\n\nvar getText = function getText(obj) {\n  return obj ? obj.runs ? obj.runs[0].text : obj.simpleText : null;\n};\n/**\n * Get video media.\n *\n * @param {Object} info\n * @returns {Object}\n */\n\n\nexports.getMedia = function (info) {\n  var media = {};\n  var results = [];\n\n  try {\n    results = info.response.contents.twoColumnWatchNextResults.results.results.contents;\n  } catch (err) {// Do nothing\n  }\n\n  var result = results.find(function (v) {\n    return v.videoSecondaryInfoRenderer;\n  });\n\n  if (!result) {\n    return {};\n  }\n\n  try {\n    var metadataRows = (result.metadataRowContainer || result.videoSecondaryInfoRenderer.metadataRowContainer).metadataRowContainerRenderer.rows;\n\n    var _iterator = _createForOfIteratorHelper(metadataRows),\n        _step;\n\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var row = _step.value;\n\n        if (row.metadataRowRenderer) {\n          var title = getText(row.metadataRowRenderer.title).toLowerCase();\n          var contents = row.metadataRowRenderer.contents[0];\n          media[title] = getText(contents);\n          var runs = contents.runs;\n\n          if (runs && runs[0].navigationEndpoint) {\n            media[\"\".concat(title, \"_url\")] = new URL(runs[0].navigationEndpoint.commandMetadata.webCommandMetadata.url, BASE_URL).toString();\n          }\n\n          if (title in TITLE_TO_CATEGORY) {\n            media.category = TITLE_TO_CATEGORY[title].name;\n            media.category_url = TITLE_TO_CATEGORY[title].url;\n          }\n        } else if (row.richMetadataRowRenderer) {\n          var _contents = row.richMetadataRowRenderer.contents;\n\n          var boxArt = _contents.filter(function (meta) {\n            return meta.richMetadataRenderer.style === 'RICH_METADATA_RENDERER_STYLE_BOX_ART';\n          });\n\n          var _iterator2 = _createForOfIteratorHelper(boxArt),\n              _step2;\n\n          try {\n            for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n              var richMetadataRenderer = _step2.value.richMetadataRenderer;\n              var meta = richMetadataRenderer;\n              media.year = getText(meta.subtitle);\n              var type = getText(meta.callToAction).split(' ')[1];\n              media[type] = getText(meta.title);\n              media[\"\".concat(type, \"_url\")] = new URL(meta.endpoint.commandMetadata.webCommandMetadata.url, BASE_URL).toString();\n              media.thumbnails = meta.thumbnail.thumbnails;\n            }\n          } catch (err) {\n            _iterator2.e(err);\n          } finally {\n            _iterator2.f();\n          }\n\n          var topic = _contents.filter(function (meta) {\n            return meta.richMetadataRenderer.style === 'RICH_METADATA_RENDERER_STYLE_TOPIC';\n          });\n\n          var _iterator3 = _createForOfIteratorHelper(topic),\n              _step3;\n\n          try {\n            for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n              var _richMetadataRenderer = _step3.value.richMetadataRenderer;\n              var _meta = _richMetadataRenderer;\n              media.category = getText(_meta.title);\n              media.category_url = new URL(_meta.endpoint.commandMetadata.webCommandMetadata.url, BASE_URL).toString();\n            }\n          } catch (err) {\n            _iterator3.e(err);\n          } finally {\n            _iterator3.f();\n          }\n        }\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n  } catch (err) {// Do nothing.\n  }\n\n  return media;\n};\n\nvar isVerified = function isVerified(badges) {\n  return !!(badges && badges.find(function (b) {\n    return b.metadataBadgeRenderer.tooltip === 'Verified';\n  }));\n};\n/**\n * Get video author.\n *\n * @param {Object} info\n * @returns {Object}\n */\n\n\nexports.getAuthor = function (info) {\n  var channelId,\n      thumbnails = [],\n      subscriberCount,\n      verified = false;\n\n  try {\n    var results = info.response.contents.twoColumnWatchNextResults.results.results.contents;\n    var v = results.find(function (v2) {\n      return v2.videoSecondaryInfoRenderer && v2.videoSecondaryInfoRenderer.owner && v2.videoSecondaryInfoRenderer.owner.videoOwnerRenderer;\n    });\n    var videoOwnerRenderer = v.videoSecondaryInfoRenderer.owner.videoOwnerRenderer;\n    channelId = videoOwnerRenderer.navigationEndpoint.browseEndpoint.browseId;\n    thumbnails = videoOwnerRenderer.thumbnail.thumbnails.map(function (thumbnail) {\n      thumbnail.url = new URL(thumbnail.url, BASE_URL).toString();\n      return thumbnail;\n    });\n    subscriberCount = utils.parseAbbreviatedNumber(getText(videoOwnerRenderer.subscriberCountText));\n    verified = isVerified(videoOwnerRenderer.badges);\n  } catch (err) {// Do nothing.\n  }\n\n  try {\n    var videoDetails = info.player_response.microformat && info.player_response.microformat.playerMicroformatRenderer;\n    var id = videoDetails && videoDetails.channelId || channelId || info.player_response.videoDetails.channelId;\n    var author = {\n      id: id,\n      name: videoDetails ? videoDetails.ownerChannelName : info.player_response.videoDetails.author,\n      user: videoDetails ? videoDetails.ownerProfileUrl.split('/').slice(-1)[0] : null,\n      channel_url: \"https://www.youtube.com/channel/\".concat(id),\n      external_channel_url: videoDetails ? \"https://www.youtube.com/channel/\".concat(videoDetails.externalChannelId) : '',\n      user_url: videoDetails ? new URL(videoDetails.ownerProfileUrl, BASE_URL).toString() : '',\n      thumbnails: thumbnails,\n      verified: verified,\n      subscriber_count: subscriberCount\n    };\n\n    if (thumbnails.length) {\n      utils.deprecate(author, 'avatar', author.thumbnails[0].url, 'author.avatar', 'author.thumbnails[0].url');\n    }\n\n    return author;\n  } catch (err) {\n    return {};\n  }\n};\n\nvar parseRelatedVideo = function parseRelatedVideo(details, rvsParams) {\n  if (!details) return;\n\n  try {\n    var viewCount = getText(details.viewCountText);\n    var shortViewCount = getText(details.shortViewCountText);\n    var rvsDetails = rvsParams.find(function (elem) {\n      return elem.id === details.videoId;\n    });\n\n    if (!/^\\d/.test(shortViewCount)) {\n      shortViewCount = rvsDetails && rvsDetails.short_view_count_text || '';\n    }\n\n    viewCount = (/^\\d/.test(viewCount) ? viewCount : shortViewCount).split(' ')[0];\n    var browseEndpoint = details.shortBylineText.runs[0].navigationEndpoint.browseEndpoint;\n    var channelId = browseEndpoint.browseId;\n    var name = getText(details.shortBylineText);\n    var user = (browseEndpoint.canonicalBaseUrl || '').split('/').slice(-1)[0];\n    var video = {\n      id: details.videoId,\n      title: getText(details.title),\n      published: getText(details.publishedTimeText),\n      author: _defineProperty({\n        id: channelId,\n        name: name,\n        user: user,\n        channel_url: \"https://www.youtube.com/channel/\".concat(channelId),\n        user_url: \"https://www.youtube.com/user/\".concat(user),\n        thumbnails: details.channelThumbnail.thumbnails.map(function (thumbnail) {\n          thumbnail.url = new URL(thumbnail.url, BASE_URL).toString();\n          return thumbnail;\n        }),\n        verified: isVerified(details.ownerBadges)\n      }, Symbol.toPrimitive, function () {\n        console.warn(\"`relatedVideo.author` will be removed in a near future release, \" + \"use `relatedVideo.author.name` instead.\");\n        return video.author.name;\n      }),\n      short_view_count_text: shortViewCount.split(' ')[0],\n      view_count: viewCount.replace(/,/g, ''),\n      length_seconds: details.lengthText ? Math.floor(parseTimestamp(getText(details.lengthText)) / 1000) : rvsParams && \"\".concat(rvsParams.length_seconds),\n      thumbnails: details.thumbnail.thumbnails,\n      richThumbnails: details.richThumbnail ? details.richThumbnail.movingThumbnailRenderer.movingThumbnailDetails.thumbnails : [],\n      isLive: !!(details.badges && details.badges.find(function (b) {\n        return b.metadataBadgeRenderer.label === 'LIVE NOW';\n      }))\n    };\n    utils.deprecate(video, 'author_thumbnail', video.author.thumbnails[0].url, 'relatedVideo.author_thumbnail', 'relatedVideo.author.thumbnails[0].url');\n    utils.deprecate(video, 'ucid', video.author.id, 'relatedVideo.ucid', 'relatedVideo.author.id');\n    utils.deprecate(video, 'video_thumbnail', video.thumbnails[0].url, 'relatedVideo.video_thumbnail', 'relatedVideo.thumbnails[0].url');\n    return video;\n  } catch (err) {// Skip.\n  }\n};\n/**\n * Get related videos.\n *\n * @param {Object} info\n * @returns {Array.<Object>}\n */\n\n\nexports.getRelatedVideos = function (info) {\n  var rvsParams = [],\n      secondaryResults = [];\n\n  try {\n    rvsParams = info.response.webWatchNextResponseExtensionData.relatedVideoArgs.split(',').map(function (e) {\n      return qs.parse(e);\n    });\n  } catch (err) {// Do nothing.\n  }\n\n  try {\n    secondaryResults = info.response.contents.twoColumnWatchNextResults.secondaryResults.secondaryResults.results;\n  } catch (err) {\n    return [];\n  }\n\n  var videos = [];\n\n  var _iterator4 = _createForOfIteratorHelper(secondaryResults || []),\n      _step4;\n\n  try {\n    for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n      var result = _step4.value;\n      var details = result.compactVideoRenderer;\n\n      if (details) {\n        var video = parseRelatedVideo(details, rvsParams);\n        if (video) videos.push(video);\n      } else {\n        var autoplay = result.compactAutoplayRenderer || result.itemSectionRenderer;\n        if (!autoplay || !Array.isArray(autoplay.contents)) continue;\n\n        var _iterator5 = _createForOfIteratorHelper(autoplay.contents),\n            _step5;\n\n        try {\n          for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n            var content = _step5.value;\n\n            var _video = parseRelatedVideo(content.compactVideoRenderer, rvsParams);\n\n            if (_video) videos.push(_video);\n          }\n        } catch (err) {\n          _iterator5.e(err);\n        } finally {\n          _iterator5.f();\n        }\n      }\n    }\n  } catch (err) {\n    _iterator4.e(err);\n  } finally {\n    _iterator4.f();\n  }\n\n  return videos;\n};\n/**\n * Get like count.\n *\n * @param {Object} info\n * @returns {number}\n */\n\n\nexports.getLikes = function (info) {\n  try {\n    var contents = info.response.contents.twoColumnWatchNextResults.results.results.contents;\n    var video = contents.find(function (r) {\n      return r.videoPrimaryInfoRenderer;\n    });\n    var buttons = video.videoPrimaryInfoRenderer.videoActions.menuRenderer.topLevelButtons;\n    var like = buttons.find(function (b) {\n      return b.toggleButtonRenderer && b.toggleButtonRenderer.defaultIcon.iconType === 'LIKE';\n    });\n    return parseInt(like.toggleButtonRenderer.defaultText.accessibility.accessibilityData.label.replace(/\\D+/g, ''));\n  } catch (err) {\n    return null;\n  }\n};\n/**\n * Get dislike count.\n *\n * @param {Object} info\n * @returns {number}\n */\n\n\nexports.getDislikes = function (info) {\n  try {\n    var contents = info.response.contents.twoColumnWatchNextResults.results.results.contents;\n    var video = contents.find(function (r) {\n      return r.videoPrimaryInfoRenderer;\n    });\n    var buttons = video.videoPrimaryInfoRenderer.videoActions.menuRenderer.topLevelButtons;\n    var dislike = buttons.find(function (b) {\n      return b.toggleButtonRenderer && b.toggleButtonRenderer.defaultIcon.iconType === 'DISLIKE';\n    });\n    return parseInt(dislike.toggleButtonRenderer.defaultText.accessibility.accessibilityData.label.replace(/\\D+/g, ''));\n  } catch (err) {\n    return null;\n  }\n};\n/**\n * Cleans up a few fields on `videoDetails`.\n *\n * @param {Object} videoDetails\n * @param {Object} info\n * @returns {Object}\n */\n\n\nexports.cleanVideoDetails = function (videoDetails, info) {\n  videoDetails.thumbnails = videoDetails.thumbnail.thumbnails;\n  delete videoDetails.thumbnail;\n  utils.deprecate(videoDetails, 'thumbnail', {\n    thumbnails: videoDetails.thumbnails\n  }, 'videoDetails.thumbnail.thumbnails', 'videoDetails.thumbnails');\n  videoDetails.description = videoDetails.shortDescription || getText(videoDetails.description);\n  delete videoDetails.shortDescription;\n  utils.deprecate(videoDetails, 'shortDescription', videoDetails.description, 'videoDetails.shortDescription', 'videoDetails.description'); // Use more reliable `lengthSeconds` from `playerMicroformatRenderer`.\n\n  videoDetails.lengthSeconds = info.player_response.microformat && info.player_response.microformat.playerMicroformatRenderer.lengthSeconds || info.player_response.videoDetails.lengthSeconds;\n  return videoDetails;\n};\n/**\n * Get storyboards info.\n *\n * @param {Object} info\n * @returns {Array.<Object>}\n */\n\n\nexports.getStoryboards = function (info) {\n  var parts = info.player_response.storyboards && info.player_response.storyboards.playerStoryboardSpecRenderer && info.player_response.storyboards.playerStoryboardSpecRenderer.spec && info.player_response.storyboards.playerStoryboardSpecRenderer.spec.split('|');\n  if (!parts) return [];\n  var url = new URL(parts.shift());\n  return parts.map(function (part, i) {\n    var _part$split = part.split('#'),\n        _part$split2 = _slicedToArray(_part$split, 8),\n        thumbnailWidth = _part$split2[0],\n        thumbnailHeight = _part$split2[1],\n        thumbnailCount = _part$split2[2],\n        columns = _part$split2[3],\n        rows = _part$split2[4],\n        interval = _part$split2[5],\n        nameReplacement = _part$split2[6],\n        sigh = _part$split2[7];\n\n    url.searchParams.set('sigh', sigh);\n    thumbnailCount = parseInt(thumbnailCount, 10);\n    columns = parseInt(columns, 10);\n    rows = parseInt(rows, 10);\n    var storyboardCount = Math.ceil(thumbnailCount / (columns * rows));\n    return {\n      templateUrl: url.toString().replace('$L', i).replace('$N', nameReplacement),\n      thumbnailWidth: parseInt(thumbnailWidth, 10),\n      thumbnailHeight: parseInt(thumbnailHeight, 10),\n      thumbnailCount: thumbnailCount,\n      interval: parseInt(interval, 10),\n      columns: columns,\n      rows: rows,\n      storyboardCount: storyboardCount\n    };\n  });\n};\n/**\n * Get chapters info.\n *\n * @param {Object} info\n * @returns {Array.<Object>}\n */\n\n\nexports.getChapters = function (info) {\n  var playerOverlayRenderer = info.response && info.response.playerOverlays && info.response.playerOverlays.playerOverlayRenderer;\n  var playerBar = playerOverlayRenderer && playerOverlayRenderer.decoratedPlayerBarRenderer && playerOverlayRenderer.decoratedPlayerBarRenderer.decoratedPlayerBarRenderer && playerOverlayRenderer.decoratedPlayerBarRenderer.decoratedPlayerBarRenderer.playerBar;\n  var markersMap = playerBar && playerBar.multiMarkersPlayerBarRenderer && playerBar.multiMarkersPlayerBarRenderer.markersMap;\n  var marker = Array.isArray(markersMap) && markersMap.find(function (m) {\n    return m.value && Array.isArray(m.value.chapters);\n  });\n  if (!marker) return [];\n  var chapters = marker.value.chapters;\n  return chapters.map(function (chapter) {\n    return {\n      title: getText(chapter.chapterRenderer.title),\n      start_time: chapter.chapterRenderer.timeRangeStartMillis / 1000\n    };\n  });\n};\n\n//# sourceURL=webpack://WorkBox/./node_modules/ytdl-core/lib/info-extras.js?");

/***/ }),

/***/ "./node_modules/ytdl-core/lib/info.js":
/*!********************************************!*\
  !*** ./node_modules/ytdl-core/lib/info.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("function _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }\n\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _iterableToArray(iter) { if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter); }\n\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }\n\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\n\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== \"undefined\" && arr[Symbol.iterator] || arr[\"@@iterator\"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e2) { throw _e2; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e3) { didErr = true; err = _e3; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }\n\nfunction _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err); } _next(undefined); }); }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } else if (call !== void 0) { throw new TypeError(\"Derived constructors may only return object or undefined\"); } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _wrapNativeSuper(Class) { var _cache = typeof Map === \"function\" ? new Map() : undefined; _wrapNativeSuper = function _wrapNativeSuper(Class) { if (Class === null || !_isNativeFunction(Class)) return Class; if (typeof Class !== \"function\") { throw new TypeError(\"Super expression must either be null or a function\"); } if (typeof _cache !== \"undefined\") { if (_cache.has(Class)) return _cache.get(Class); _cache.set(Class, Wrapper); } function Wrapper() { return _construct(Class, arguments, _getPrototypeOf(this).constructor); } Wrapper.prototype = Object.create(Class.prototype, { constructor: { value: Wrapper, enumerable: false, writable: true, configurable: true } }); return _setPrototypeOf(Wrapper, Class); }; return _wrapNativeSuper(Class); }\n\nfunction _construct(Parent, args, Class) { if (_isNativeReflectConstruct()) { _construct = Reflect.construct; } else { _construct = function _construct(Parent, args, Class) { var a = [null]; a.push.apply(a, args); var Constructor = Function.bind.apply(Parent, a); var instance = new Constructor(); if (Class) _setPrototypeOf(instance, Class.prototype); return instance; }; } return _construct.apply(null, arguments); }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _isNativeFunction(fn) { return Function.toString.call(fn).indexOf(\"[native code]\") !== -1; }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nvar querystring = __webpack_require__(Object(function webpackMissingModule() { var e = new Error(\"Cannot find module 'querystring'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }()));\n\nvar sax = __webpack_require__(/*! sax */ \"./node_modules/sax/lib/sax.js\");\n\nvar miniget = __webpack_require__(/*! miniget */ \"./node_modules/miniget/dist/index.js\");\n\nvar utils = __webpack_require__(/*! ./utils */ \"./node_modules/ytdl-core/lib/utils.js\"); // Forces Node JS version of setTimeout for Electron based applications\n\n\nvar _require = __webpack_require__(Object(function webpackMissingModule() { var e = new Error(\"Cannot find module 'timers'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }())),\n    setTimeout = _require.setTimeout;\n\nvar formatUtils = __webpack_require__(/*! ./format-utils */ \"./node_modules/ytdl-core/lib/format-utils.js\");\n\nvar urlUtils = __webpack_require__(/*! ./url-utils */ \"./node_modules/ytdl-core/lib/url-utils.js\");\n\nvar extras = __webpack_require__(/*! ./info-extras */ \"./node_modules/ytdl-core/lib/info-extras.js\");\n\nvar sig = __webpack_require__(/*! ./sig */ \"./node_modules/ytdl-core/lib/sig.js\");\n\nvar Cache = __webpack_require__(/*! ./cache */ \"./node_modules/ytdl-core/lib/cache.js\");\n\nvar BASE_URL = 'https://www.youtube.com/watch?v='; // Cached for storing basic/full info.\n\nexports.cache = new Cache();\nexports.cookieCache = new Cache(1000 * 60 * 60 * 24);\nexports.watchPageCache = new Cache(); // Cache for cver used in getVideoInfoPage\n\nvar cver = '2.20210622.10.00'; // Special error class used to determine if an error is unrecoverable,\n// as in, ytdl-core should not try again to fetch the video metadata.\n// In this case, the video is usually unavailable in some way.\n\nvar UnrecoverableError = /*#__PURE__*/function (_Error) {\n  _inherits(UnrecoverableError, _Error);\n\n  var _super = _createSuper(UnrecoverableError);\n\n  function UnrecoverableError() {\n    _classCallCheck(this, UnrecoverableError);\n\n    return _super.apply(this, arguments);\n  }\n\n  return UnrecoverableError;\n}( /*#__PURE__*/_wrapNativeSuper(Error)); // List of URLs that show up in `notice_url` for age restricted videos.\n\n\nvar AGE_RESTRICTED_URLS = ['support.google.com/youtube/?p=age_restrictions', 'youtube.com/t/community_guidelines'];\n/**\n * Gets info from a video without getting additional formats.\n *\n * @param {string} id\n * @param {Object} options\n * @returns {Promise<Object>}\n*/\n\nexports.getBasicInfo = /*#__PURE__*/function () {\n  var _ref = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(id, options) {\n    var retryOptions, validate, info, media, additional;\n    return regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            retryOptions = Object.assign({}, miniget.defaultOptions, options.requestOptions);\n            options.requestOptions = Object.assign({}, options.requestOptions, {});\n            options.requestOptions.headers = Object.assign({}, {\n              // eslint-disable-next-line max-len\n              'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/87.0.4280.101 Safari/537.36'\n            }, options.requestOptions.headers);\n\n            validate = function validate(info) {\n              var playErr = utils.playError(info.player_response, ['ERROR'], UnrecoverableError);\n              var privateErr = privateVideoError(info.player_response);\n\n              if (playErr || privateErr) {\n                throw playErr || privateErr;\n              }\n\n              return info && info.player_response && (info.player_response.streamingData || isRental(info.player_response) || isNotYetBroadcasted(info.player_response));\n            };\n\n            _context.next = 6;\n            return pipeline([id, options], validate, retryOptions, [getWatchHTMLPage, getWatchJSONPage, getVideoInfoPage]);\n\n          case 6:\n            info = _context.sent;\n            Object.assign(info, {\n              formats: parseFormats(info.player_response),\n              related_videos: extras.getRelatedVideos(info)\n            }); // Add additional properties to info.\n\n            media = extras.getMedia(info);\n            additional = {\n              author: extras.getAuthor(info),\n              media: media,\n              likes: extras.getLikes(info),\n              dislikes: extras.getDislikes(info),\n              age_restricted: !!(media && media.notice_url && AGE_RESTRICTED_URLS.some(function (url) {\n                return media.notice_url.includes(url);\n              })),\n              // Give the standard link to the video.\n              video_url: BASE_URL + id,\n              storyboards: extras.getStoryboards(info),\n              chapters: extras.getChapters(info)\n            };\n            info.videoDetails = extras.cleanVideoDetails(Object.assign({}, info.player_response && info.player_response.microformat && info.player_response.microformat.playerMicroformatRenderer, info.player_response && info.player_response.videoDetails, additional), info);\n            return _context.abrupt(\"return\", info);\n\n          case 12:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  }));\n\n  return function (_x, _x2) {\n    return _ref.apply(this, arguments);\n  };\n}();\n\nvar privateVideoError = function privateVideoError(player_response) {\n  var playability = player_response && player_response.playabilityStatus;\n\n  if (playability && playability.status === 'LOGIN_REQUIRED' && playability.messages && playability.messages.filter(function (m) {\n    return /This is a private video/.test(m);\n  }).length) {\n    return new UnrecoverableError(playability.reason || playability.messages && playability.messages[0]);\n  } else {\n    return null;\n  }\n};\n\nvar isRental = function isRental(player_response) {\n  var playability = player_response.playabilityStatus;\n  return playability && playability.status === 'UNPLAYABLE' && playability.errorScreen && playability.errorScreen.playerLegacyDesktopYpcOfferRenderer;\n};\n\nvar isNotYetBroadcasted = function isNotYetBroadcasted(player_response) {\n  var playability = player_response.playabilityStatus;\n  return playability && playability.status === 'LIVE_STREAM_OFFLINE';\n};\n\nvar getWatchHTMLURL = function getWatchHTMLURL(id, options) {\n  return \"\".concat(BASE_URL + id, \"&hl=\").concat(options.lang || 'en');\n};\n\nvar getWatchHTMLPageBody = function getWatchHTMLPageBody(id, options) {\n  var url = getWatchHTMLURL(id, options);\n  return exports.watchPageCache.getOrSet(url, function () {\n    return utils.exposedMiniget(url, options).text();\n  });\n};\n\nvar EMBED_URL = 'https://www.youtube.com/embed/';\n\nvar getEmbedPageBody = function getEmbedPageBody(id, options) {\n  var embedUrl = \"\".concat(EMBED_URL + id, \"?hl=\").concat(options.lang || 'en');\n  return utils.exposedMiniget(embedUrl, options).text();\n};\n\nvar getHTML5player = function getHTML5player(body) {\n  var html5playerRes = /<script\\s+src=\"([^\"]+)\"(?:\\s+type=\"text\\/javascript\")?\\s+name=\"player_ias\\/base\"\\s*>|\"jsUrl\":\"([^\"]+)\"/.exec(body);\n  return html5playerRes ? html5playerRes[1] || html5playerRes[2] : null;\n};\n\nvar getIdentityToken = function getIdentityToken(id, options, key, throwIfNotFound) {\n  return exports.cookieCache.getOrSet(key, /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2() {\n    var page, match;\n    return regeneratorRuntime.wrap(function _callee2$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            _context2.next = 2;\n            return getWatchHTMLPageBody(id, options);\n\n          case 2:\n            page = _context2.sent;\n            match = page.match(/([\"'])ID_TOKEN\\1[:,]\\s?\"([^\"]+)\"/);\n\n            if (!(!match && throwIfNotFound)) {\n              _context2.next = 6;\n              break;\n            }\n\n            throw new UnrecoverableError('Cookie header used in request, but unable to find YouTube identity token');\n\n          case 6:\n            return _context2.abrupt(\"return\", match && match[2]);\n\n          case 7:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, _callee2);\n  })));\n};\n/**\n * Goes through each endpoint in the pipeline, retrying on failure if the error is recoverable.\n * If unable to succeed with one endpoint, moves onto the next one.\n *\n * @param {Array.<Object>} args\n * @param {Function} validate\n * @param {Object} retryOptions\n * @param {Array.<Function>} endpoints\n * @returns {[Object, Object, Object]}\n */\n\n\nvar pipeline = /*#__PURE__*/function () {\n  var _ref3 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(args, validate, retryOptions, endpoints) {\n    var info, _iterator, _step, func, newInfo;\n\n    return regeneratorRuntime.wrap(function _callee3$(_context3) {\n      while (1) {\n        switch (_context3.prev = _context3.next) {\n          case 0:\n            _iterator = _createForOfIteratorHelper(endpoints);\n            _context3.prev = 1;\n\n            _iterator.s();\n\n          case 3:\n            if ((_step = _iterator.n()).done) {\n              _context3.next = 21;\n              break;\n            }\n\n            func = _step.value;\n            _context3.prev = 5;\n            _context3.next = 8;\n            return retryFunc(func, args.concat([info]), retryOptions);\n\n          case 8:\n            newInfo = _context3.sent;\n\n            if (newInfo.player_response) {\n              newInfo.player_response.videoDetails = assign(info && info.player_response && info.player_response.videoDetails, newInfo.player_response.videoDetails);\n              newInfo.player_response = assign(info && info.player_response, newInfo.player_response);\n            }\n\n            info = assign(info, newInfo);\n\n            if (!validate(info, false)) {\n              _context3.next = 13;\n              break;\n            }\n\n            return _context3.abrupt(\"break\", 21);\n\n          case 13:\n            _context3.next = 19;\n            break;\n\n          case 15:\n            _context3.prev = 15;\n            _context3.t0 = _context3[\"catch\"](5);\n\n            if (!(_context3.t0 instanceof UnrecoverableError || func === endpoints[endpoints.length - 1])) {\n              _context3.next = 19;\n              break;\n            }\n\n            throw _context3.t0;\n\n          case 19:\n            _context3.next = 3;\n            break;\n\n          case 21:\n            _context3.next = 26;\n            break;\n\n          case 23:\n            _context3.prev = 23;\n            _context3.t1 = _context3[\"catch\"](1);\n\n            _iterator.e(_context3.t1);\n\n          case 26:\n            _context3.prev = 26;\n\n            _iterator.f();\n\n            return _context3.finish(26);\n\n          case 29:\n            return _context3.abrupt(\"return\", info);\n\n          case 30:\n          case \"end\":\n            return _context3.stop();\n        }\n      }\n    }, _callee3, null, [[1, 23, 26, 29], [5, 15]]);\n  }));\n\n  return function pipeline(_x3, _x4, _x5, _x6) {\n    return _ref3.apply(this, arguments);\n  };\n}();\n/**\n * Like Object.assign(), but ignores `null` and `undefined` from `source`.\n *\n * @param {Object} target\n * @param {Object} source\n * @returns {Object}\n */\n\n\nvar assign = function assign(target, source) {\n  if (!target || !source) {\n    return target || source;\n  }\n\n  for (var _i = 0, _Object$entries = Object.entries(source); _i < _Object$entries.length; _i++) {\n    var _Object$entries$_i = _slicedToArray(_Object$entries[_i], 2),\n        key = _Object$entries$_i[0],\n        value = _Object$entries$_i[1];\n\n    if (value !== null && value !== undefined) {\n      target[key] = value;\n    }\n  }\n\n  return target;\n};\n/**\n * Given a function, calls it with `args` until it's successful,\n * or until it encounters an unrecoverable error.\n * Currently, any error from miniget is considered unrecoverable. Errors such as\n * too many redirects, invalid URL, status code 404, status code 502.\n *\n * @param {Function} func\n * @param {Array.<Object>} args\n * @param {Object} options\n * @param {number} options.maxRetries\n * @param {Object} options.backoff\n * @param {number} options.backoff.inc\n */\n\n\nvar retryFunc = /*#__PURE__*/function () {\n  var _ref4 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee5(func, args, options) {\n    var currentTry, result;\n    return regeneratorRuntime.wrap(function _callee5$(_context5) {\n      while (1) {\n        switch (_context5.prev = _context5.next) {\n          case 0:\n            currentTry = 0;\n\n          case 1:\n            if (!(currentTry <= options.maxRetries)) {\n              _context5.next = 14;\n              break;\n            }\n\n            _context5.prev = 2;\n            _context5.next = 5;\n            return func.apply(void 0, _toConsumableArray(args));\n\n          case 5:\n            result = _context5.sent;\n            return _context5.abrupt(\"break\", 14);\n\n          case 9:\n            _context5.prev = 9;\n            _context5.t0 = _context5[\"catch\"](2);\n            return _context5.delegateYield( /*#__PURE__*/regeneratorRuntime.mark(function _callee4() {\n              var wait;\n              return regeneratorRuntime.wrap(function _callee4$(_context4) {\n                while (1) {\n                  switch (_context4.prev = _context4.next) {\n                    case 0:\n                      if (!(_context5.t0 instanceof UnrecoverableError || _context5.t0 instanceof miniget.MinigetError && _context5.t0.statusCode < 500 || currentTry >= options.maxRetries)) {\n                        _context4.next = 2;\n                        break;\n                      }\n\n                      throw _context5.t0;\n\n                    case 2:\n                      wait = Math.min(++currentTry * options.backoff.inc, options.backoff.max);\n                      _context4.next = 5;\n                      return new Promise(function (resolve) {\n                        return setTimeout(resolve, wait);\n                      });\n\n                    case 5:\n                    case \"end\":\n                      return _context4.stop();\n                  }\n                }\n              }, _callee4);\n            })(), \"t1\", 12);\n\n          case 12:\n            _context5.next = 1;\n            break;\n\n          case 14:\n            return _context5.abrupt(\"return\", result);\n\n          case 15:\n          case \"end\":\n            return _context5.stop();\n        }\n      }\n    }, _callee5, null, [[2, 9]]);\n  }));\n\n  return function retryFunc(_x7, _x8, _x9) {\n    return _ref4.apply(this, arguments);\n  };\n}();\n\nvar jsonClosingChars = /^[)\\]}'\\s]+/;\n\nvar parseJSON = function parseJSON(source, varName, json) {\n  if (!json || _typeof(json) === 'object') {\n    return json;\n  } else {\n    try {\n      json = json.replace(jsonClosingChars, '');\n      return JSON.parse(json);\n    } catch (err) {\n      throw Error(\"Error parsing \".concat(varName, \" in \").concat(source, \": \").concat(err.message));\n    }\n  }\n};\n\nvar findJSON = function findJSON(source, varName, body, left, right, prependJSON) {\n  var jsonStr = utils.between(body, left, right);\n\n  if (!jsonStr) {\n    throw Error(\"Could not find \".concat(varName, \" in \").concat(source));\n  }\n\n  return parseJSON(source, varName, utils.cutAfterJSON(\"\".concat(prependJSON).concat(jsonStr)));\n};\n\nvar findPlayerResponse = function findPlayerResponse(source, info) {\n  var player_response = info && (info.args && info.args.player_response || info.player_response || info.playerResponse || info.embedded_player_response);\n  return parseJSON(source, 'player_response', player_response);\n};\n\nvar getWatchJSONURL = function getWatchJSONURL(id, options) {\n  return \"\".concat(getWatchHTMLURL(id, options), \"&pbj=1\");\n};\n\nvar getWatchJSONPage = /*#__PURE__*/function () {\n  var _ref5 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee7(id, options) {\n    var reqOptions, cookie, setIdentityToken, jsonUrl, body, parsedBody, info;\n    return regeneratorRuntime.wrap(function _callee7$(_context7) {\n      while (1) {\n        switch (_context7.prev = _context7.next) {\n          case 0:\n            reqOptions = Object.assign({\n              headers: {}\n            }, options.requestOptions);\n            cookie = reqOptions.headers.Cookie || reqOptions.headers.cookie;\n            reqOptions.headers = Object.assign({\n              'x-youtube-client-name': '1',\n              'x-youtube-client-version': cver,\n              'x-youtube-identity-token': exports.cookieCache.get(cookie || 'browser') || ''\n            }, reqOptions.headers);\n\n            setIdentityToken = /*#__PURE__*/function () {\n              var _ref6 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee6(key, throwIfNotFound) {\n                return regeneratorRuntime.wrap(function _callee6$(_context6) {\n                  while (1) {\n                    switch (_context6.prev = _context6.next) {\n                      case 0:\n                        if (!reqOptions.headers['x-youtube-identity-token']) {\n                          _context6.next = 2;\n                          break;\n                        }\n\n                        return _context6.abrupt(\"return\");\n\n                      case 2:\n                        _context6.next = 4;\n                        return getIdentityToken(id, options, key, throwIfNotFound);\n\n                      case 4:\n                        reqOptions.headers['x-youtube-identity-token'] = _context6.sent;\n\n                      case 5:\n                      case \"end\":\n                        return _context6.stop();\n                    }\n                  }\n                }, _callee6);\n              }));\n\n              return function setIdentityToken(_x12, _x13) {\n                return _ref6.apply(this, arguments);\n              };\n            }();\n\n            if (!cookie) {\n              _context7.next = 7;\n              break;\n            }\n\n            _context7.next = 7;\n            return setIdentityToken(cookie, true);\n\n          case 7:\n            jsonUrl = getWatchJSONURL(id, options);\n            _context7.next = 10;\n            return utils.exposedMiniget(jsonUrl, options, reqOptions).text();\n\n          case 10:\n            body = _context7.sent;\n            parsedBody = parseJSON('watch.json', 'body', body);\n\n            if (!(parsedBody.reload === 'now')) {\n              _context7.next = 15;\n              break;\n            }\n\n            _context7.next = 15;\n            return setIdentityToken('browser', false);\n\n          case 15:\n            if (!(parsedBody.reload === 'now' || !Array.isArray(parsedBody))) {\n              _context7.next = 17;\n              break;\n            }\n\n            throw Error('Unable to retrieve video metadata in watch.json');\n\n          case 17:\n            info = parsedBody.reduce(function (part, curr) {\n              return Object.assign(curr, part);\n            }, {});\n            info.player_response = findPlayerResponse('watch.json', info);\n            info.html5player = info.player && info.player.assets && info.player.assets.js;\n            return _context7.abrupt(\"return\", info);\n\n          case 21:\n          case \"end\":\n            return _context7.stop();\n        }\n      }\n    }, _callee7);\n  }));\n\n  return function getWatchJSONPage(_x10, _x11) {\n    return _ref5.apply(this, arguments);\n  };\n}();\n\nvar getWatchHTMLPage = /*#__PURE__*/function () {\n  var _ref7 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee8(id, options) {\n    var body, info, args;\n    return regeneratorRuntime.wrap(function _callee8$(_context8) {\n      while (1) {\n        switch (_context8.prev = _context8.next) {\n          case 0:\n            _context8.next = 2;\n            return getWatchHTMLPageBody(id, options);\n\n          case 2:\n            body = _context8.sent;\n            info = {\n              page: 'watch'\n            };\n\n            try {\n              cver = utils.between(body, '{\"key\":\"cver\",\"value\":\"', '\"}');\n              info.player_response = findJSON('watch.html', 'player_response', body, /\\bytInitialPlayerResponse\\s*=\\s*\\{/i, '</script>', '{');\n            } catch (err) {\n              args = findJSON('watch.html', 'player_response', body, /\\bytplayer\\.config\\s*=\\s*{/, '</script>', '{');\n              info.player_response = findPlayerResponse('watch.html', args);\n            }\n\n            info.response = findJSON('watch.html', 'response', body, /\\bytInitialData(\"\\])?\\s*=\\s*\\{/i, '</script>', '{');\n            info.html5player = getHTML5player(body);\n            return _context8.abrupt(\"return\", info);\n\n          case 8:\n          case \"end\":\n            return _context8.stop();\n        }\n      }\n    }, _callee8);\n  }));\n\n  return function getWatchHTMLPage(_x14, _x15) {\n    return _ref7.apply(this, arguments);\n  };\n}();\n\nvar INFO_HOST = 'www.youtube.com';\nvar INFO_PATH = '/get_video_info';\nvar VIDEO_EURL = 'https://youtube.googleapis.com/v/';\n\nvar getVideoInfoPage = /*#__PURE__*/function () {\n  var _ref8 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee9(id, options) {\n    var url, body, info;\n    return regeneratorRuntime.wrap(function _callee9$(_context9) {\n      while (1) {\n        switch (_context9.prev = _context9.next) {\n          case 0:\n            url = new URL(\"https://\".concat(INFO_HOST).concat(INFO_PATH));\n            url.searchParams.set('video_id', id);\n            url.searchParams.set('c', 'TVHTML5');\n            url.searchParams.set('cver', \"7\".concat(cver.substr(1)));\n            url.searchParams.set('eurl', VIDEO_EURL + id);\n            url.searchParams.set('ps', 'default');\n            url.searchParams.set('gl', 'US');\n            url.searchParams.set('hl', options.lang || 'en');\n            url.searchParams.set('html5', '1');\n            _context9.next = 11;\n            return utils.exposedMiniget(url.toString(), options).text();\n\n          case 11:\n            body = _context9.sent;\n            info = querystring.parse(body);\n            info.player_response = findPlayerResponse('get_video_info', info);\n            return _context9.abrupt(\"return\", info);\n\n          case 15:\n          case \"end\":\n            return _context9.stop();\n        }\n      }\n    }, _callee9);\n  }));\n\n  return function getVideoInfoPage(_x16, _x17) {\n    return _ref8.apply(this, arguments);\n  };\n}();\n/**\n * @param {Object} player_response\n * @returns {Array.<Object>}\n */\n\n\nvar parseFormats = function parseFormats(player_response) {\n  var formats = [];\n\n  if (player_response && player_response.streamingData) {\n    formats = formats.concat(player_response.streamingData.formats || []).concat(player_response.streamingData.adaptiveFormats || []);\n  }\n\n  return formats;\n};\n/**\n * Gets info from a video additional formats and deciphered URLs.\n *\n * @param {string} id\n * @param {Object} options\n * @returns {Promise<Object>}\n */\n\n\nexports.getInfo = /*#__PURE__*/function () {\n  var _ref9 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee10(id, options) {\n    var info, hasManifest, funcs, html5player, url, _url, results;\n\n    return regeneratorRuntime.wrap(function _callee10$(_context10) {\n      while (1) {\n        switch (_context10.prev = _context10.next) {\n          case 0:\n            _context10.next = 2;\n            return exports.getBasicInfo(id, options);\n\n          case 2:\n            info = _context10.sent;\n            hasManifest = info.player_response && info.player_response.streamingData && (info.player_response.streamingData.dashManifestUrl || info.player_response.streamingData.hlsManifestUrl);\n            funcs = [];\n\n            if (!info.formats.length) {\n              _context10.next = 25;\n              break;\n            }\n\n            _context10.t1 = info.html5player;\n\n            if (_context10.t1) {\n              _context10.next = 13;\n              break;\n            }\n\n            _context10.t2 = getHTML5player;\n            _context10.next = 11;\n            return getWatchHTMLPageBody(id, options);\n\n          case 11:\n            _context10.t3 = _context10.sent;\n            _context10.t1 = (0, _context10.t2)(_context10.t3);\n\n          case 13:\n            _context10.t0 = _context10.t1;\n\n            if (_context10.t0) {\n              _context10.next = 20;\n              break;\n            }\n\n            _context10.t4 = getHTML5player;\n            _context10.next = 18;\n            return getEmbedPageBody(id, options);\n\n          case 18:\n            _context10.t5 = _context10.sent;\n            _context10.t0 = (0, _context10.t4)(_context10.t5);\n\n          case 20:\n            info.html5player = _context10.t0;\n\n            if (info.html5player) {\n              _context10.next = 23;\n              break;\n            }\n\n            throw Error('Unable to find html5player file');\n\n          case 23:\n            html5player = new URL(info.html5player, BASE_URL).toString();\n            funcs.push(sig.decipherFormats(info.formats, html5player, options));\n\n          case 25:\n            if (hasManifest && info.player_response.streamingData.dashManifestUrl) {\n              url = info.player_response.streamingData.dashManifestUrl;\n              funcs.push(getDashManifest(url, options));\n            }\n\n            if (hasManifest && info.player_response.streamingData.hlsManifestUrl) {\n              _url = info.player_response.streamingData.hlsManifestUrl;\n              funcs.push(getM3U8(_url, options));\n            }\n\n            _context10.next = 29;\n            return Promise.all(funcs);\n\n          case 29:\n            results = _context10.sent;\n            info.formats = Object.values(Object.assign.apply(Object, [{}].concat(_toConsumableArray(results))));\n            info.formats = info.formats.map(formatUtils.addFormatMeta);\n            info.formats.sort(formatUtils.sortFormats);\n            info.full = true;\n            return _context10.abrupt(\"return\", info);\n\n          case 35:\n          case \"end\":\n            return _context10.stop();\n        }\n      }\n    }, _callee10);\n  }));\n\n  return function (_x18, _x19) {\n    return _ref9.apply(this, arguments);\n  };\n}();\n/**\n * Gets additional DASH formats.\n *\n * @param {string} url\n * @param {Object} options\n * @returns {Promise<Array.<Object>>}\n */\n\n\nvar getDashManifest = function getDashManifest(url, options) {\n  return new Promise(function (resolve, reject) {\n    var formats = {};\n    var parser = sax.parser(false);\n    parser.onerror = reject;\n    var adaptationSet;\n\n    parser.onopentag = function (node) {\n      if (node.name === 'ADAPTATIONSET') {\n        adaptationSet = node.attributes;\n      } else if (node.name === 'REPRESENTATION') {\n        var itag = parseInt(node.attributes.ID);\n\n        if (!isNaN(itag)) {\n          formats[url] = Object.assign({\n            itag: itag,\n            url: url,\n            bitrate: parseInt(node.attributes.BANDWIDTH),\n            mimeType: \"\".concat(adaptationSet.MIMETYPE, \"; codecs=\\\"\").concat(node.attributes.CODECS, \"\\\"\")\n          }, node.attributes.HEIGHT ? {\n            width: parseInt(node.attributes.WIDTH),\n            height: parseInt(node.attributes.HEIGHT),\n            fps: parseInt(node.attributes.FRAMERATE)\n          } : {\n            audioSampleRate: node.attributes.AUDIOSAMPLINGRATE\n          });\n        }\n      }\n    };\n\n    parser.onend = function () {\n      resolve(formats);\n    };\n\n    var req = utils.exposedMiniget(new URL(url, BASE_URL).toString(), options);\n    req.setEncoding('utf8');\n    req.on('error', reject);\n    req.on('data', function (chunk) {\n      parser.write(chunk);\n    });\n    req.on('end', parser.close.bind(parser));\n  });\n};\n/**\n * Gets additional formats.\n *\n * @param {string} url\n * @param {Object} options\n * @returns {Promise<Array.<Object>>}\n */\n\n\nvar getM3U8 = /*#__PURE__*/function () {\n  var _ref10 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee11(url, options) {\n    var body, formats;\n    return regeneratorRuntime.wrap(function _callee11$(_context11) {\n      while (1) {\n        switch (_context11.prev = _context11.next) {\n          case 0:\n            url = new URL(url, BASE_URL);\n            _context11.next = 3;\n            return utils.exposedMiniget(url.toString(), options).text();\n\n          case 3:\n            body = _context11.sent;\n            formats = {};\n            body.split('\\n').filter(function (line) {\n              return /^https?:\\/\\//.test(line);\n            }).forEach(function (line) {\n              var itag = parseInt(line.match(/\\/itag\\/(\\d+)\\//)[1]);\n              formats[line] = {\n                itag: itag,\n                url: line\n              };\n            });\n            return _context11.abrupt(\"return\", formats);\n\n          case 7:\n          case \"end\":\n            return _context11.stop();\n        }\n      }\n    }, _callee11);\n  }));\n\n  return function getM3U8(_x20, _x21) {\n    return _ref10.apply(this, arguments);\n  };\n}(); // Cache get info functions.\n// In case a user wants to get a video's info before downloading.\n\n\nvar _loop = function _loop() {\n  var funcName = _arr2[_i2];\n\n  /**\n   * @param {string} link\n   * @param {Object} options\n   * @returns {Promise<Object>}\n   */\n  var func = exports[funcName];\n\n  exports[funcName] = /*#__PURE__*/function () {\n    var _ref11 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee12(link) {\n      var options,\n          id,\n          key,\n          _args12 = arguments;\n      return regeneratorRuntime.wrap(function _callee12$(_context12) {\n        while (1) {\n          switch (_context12.prev = _context12.next) {\n            case 0:\n              options = _args12.length > 1 && _args12[1] !== undefined ? _args12[1] : {};\n              utils.checkForUpdates();\n              _context12.next = 4;\n              return urlUtils.getVideoID(link);\n\n            case 4:\n              id = _context12.sent;\n              key = [funcName, id, options.lang].join('-');\n              return _context12.abrupt(\"return\", exports.cache.getOrSet(key, function () {\n                return func(id, options);\n              }));\n\n            case 7:\n            case \"end\":\n              return _context12.stop();\n          }\n        }\n      }, _callee12);\n    }));\n\n    return function (_x22) {\n      return _ref11.apply(this, arguments);\n    };\n  }();\n};\n\nfor (var _i2 = 0, _arr2 = ['getBasicInfo', 'getInfo']; _i2 < _arr2.length; _i2++) {\n  _loop();\n} // Export a few helpers.\n\n\nexports.validateID = urlUtils.validateID;\nexports.validateURL = urlUtils.validateURL;\nexports.getURLVideoID = urlUtils.getURLVideoID;\nexports.getVideoID = urlUtils.getVideoID;\n\n//# sourceURL=webpack://WorkBox/./node_modules/ytdl-core/lib/info.js?");

/***/ }),

/***/ "./node_modules/ytdl-core/lib/sig.js":
/*!*******************************************!*\
  !*** ./node_modules/ytdl-core/lib/sig.js ***!
  \*******************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }\n\nfunction _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err); } _next(undefined); }); }; }\n\nvar querystring = __webpack_require__(Object(function webpackMissingModule() { var e = new Error(\"Cannot find module 'querystring'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }()));\n\nvar Cache = __webpack_require__(/*! ./cache */ \"./node_modules/ytdl-core/lib/cache.js\");\n\nvar utils = __webpack_require__(/*! ./utils */ \"./node_modules/ytdl-core/lib/utils.js\");\n\nvar vm = __webpack_require__(Object(function webpackMissingModule() { var e = new Error(\"Cannot find module 'vm'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }())); // A shared cache to keep track of html5player js functions.\n\n\nexports.cache = new Cache();\n/**\n * Extract signature deciphering and n parameter transform functions from html5player file.\n *\n * @param {string} html5playerfile\n * @param {Object} options\n * @returns {Promise<Array.<string>>}\n */\n\nexports.getFunctions = function (html5playerfile, options) {\n  return exports.cache.getOrSet(html5playerfile, /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {\n    var body, functions;\n    return regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            _context.next = 2;\n            return utils.exposedMiniget(html5playerfile, options).text();\n\n          case 2:\n            body = _context.sent;\n            functions = exports.extractFunctions(body);\n\n            if (!(!functions || !functions.length)) {\n              _context.next = 6;\n              break;\n            }\n\n            throw Error('Could not extract functions');\n\n          case 6:\n            exports.cache.set(html5playerfile, functions);\n            return _context.abrupt(\"return\", functions);\n\n          case 8:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  })));\n};\n/**\n * Extracts the actions that should be taken to decipher a signature\n * and tranform the n parameter\n *\n * @param {string} body\n * @returns {Array.<string>}\n */\n\n\nexports.extractFunctions = function (body) {\n  var functions = [];\n\n  var extractManipulations = function extractManipulations(caller) {\n    var functionName = utils.between(caller, \"a=a.split(\\\"\\\");\", \".\");\n    if (!functionName) return '';\n    var functionStart = \"var \".concat(functionName, \"={\");\n    var ndx = body.indexOf(functionStart);\n    if (ndx < 0) return '';\n    var subBody = body.slice(ndx + functionStart.length - 1);\n    return \"var \".concat(functionName, \"=\").concat(utils.cutAfterJSON(subBody));\n  };\n\n  var extractDecipher = function extractDecipher() {\n    var functionName = utils.between(body, \"a.set(\\\"alr\\\",\\\"yes\\\");c&&(c=\", \"(decodeURIC\");\n\n    if (functionName && functionName.length) {\n      var functionStart = \"\".concat(functionName, \"=function(a)\");\n      var ndx = body.indexOf(functionStart);\n\n      if (ndx >= 0) {\n        var subBody = body.slice(ndx + functionStart.length);\n        var functionBody = \"var \".concat(functionStart).concat(utils.cutAfterJSON(subBody));\n        functionBody = \"\".concat(extractManipulations(functionBody), \";\").concat(functionBody, \";\").concat(functionName, \"(sig);\");\n        functions.push(functionBody);\n      }\n    }\n  };\n\n  var extractNCode = function extractNCode() {\n    var functionName = utils.between(body, \"&&(b=a.get(\\\"n\\\"))&&(b=\", \"(b)\");\n    if (functionName.includes('[')) functionName = utils.between(body, \"\".concat(functionName.split('[')[0], \"=[\"), \"]\");\n\n    if (functionName && functionName.length) {\n      var functionStart = \"\".concat(functionName, \"=function(a)\");\n      var ndx = body.indexOf(functionStart);\n\n      if (ndx >= 0) {\n        var subBody = body.slice(ndx + functionStart.length);\n        var functionBody = \"var \".concat(functionStart).concat(utils.cutAfterJSON(subBody), \";\").concat(functionName, \"(ncode);\");\n        functions.push(functionBody);\n      }\n    }\n  };\n\n  extractDecipher();\n  extractNCode();\n  return functions;\n};\n/**\n * Apply decipher and n-transform to individual format\n *\n * @param {Object} format\n * @param {vm.Script} decipherScript\n * @param {vm.Script} nTransformScript\n */\n\n\nexports.setDownloadURL = function (format, decipherScript, nTransformScript) {\n  var decipher = function decipher(url) {\n    var args = querystring.parse(url);\n    if (!args.s || !decipherScript) return args.url;\n    var components = new URL(decodeURIComponent(args.url));\n    components.searchParams.set(args.sp ? args.sp : 'signature', decipherScript.runInNewContext({\n      sig: decodeURIComponent(args.s)\n    }));\n    return components.toString();\n  };\n\n  var ncode = function ncode(url) {\n    var components = new URL(decodeURIComponent(url));\n    var n = components.searchParams.get('n');\n    if (!n || !nTransformScript) return url;\n    components.searchParams.set('n', nTransformScript.runInNewContext({\n      ncode: n\n    }));\n    return components.toString();\n  };\n\n  var cipher = !format.url;\n  var url = format.url || format.signatureCipher || format.cipher;\n  format.url = cipher ? ncode(decipher(url)) : ncode(url);\n  delete format.signatureCipher;\n  delete format.cipher;\n};\n/**\n * Applies decipher and n parameter transforms to all format URL's.\n *\n * @param {Array.<Object>} formats\n * @param {string} html5player\n * @param {Object} options\n */\n\n\nexports.decipherFormats = /*#__PURE__*/function () {\n  var _ref2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(formats, html5player, options) {\n    var decipheredFormats, functions, decipherScript, nTransformScript;\n    return regeneratorRuntime.wrap(function _callee2$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            decipheredFormats = {};\n            _context2.next = 3;\n            return exports.getFunctions(html5player, options);\n\n          case 3:\n            functions = _context2.sent;\n            decipherScript = functions.length ? new vm.Script(functions[0]) : null;\n            nTransformScript = functions.length > 1 ? new vm.Script(functions[1]) : null;\n            formats.forEach(function (format) {\n              exports.setDownloadURL(format, decipherScript, nTransformScript);\n              decipheredFormats[format.url] = format;\n            });\n            return _context2.abrupt(\"return\", decipheredFormats);\n\n          case 8:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, _callee2);\n  }));\n\n  return function (_x, _x2, _x3) {\n    return _ref2.apply(this, arguments);\n  };\n}();\n\n//# sourceURL=webpack://WorkBox/./node_modules/ytdl-core/lib/sig.js?");

/***/ }),

/***/ "./node_modules/ytdl-core/lib/url-utils.js":
/*!*************************************************!*\
  !*** ./node_modules/ytdl-core/lib/url-utils.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("/**\n * Get video ID.\n *\n * There are a few type of video URL formats.\n *  - https://www.youtube.com/watch?v=VIDEO_ID\n *  - https://m.youtube.com/watch?v=VIDEO_ID\n *  - https://youtu.be/VIDEO_ID\n *  - https://www.youtube.com/v/VIDEO_ID\n *  - https://www.youtube.com/embed/VIDEO_ID\n *  - https://music.youtube.com/watch?v=VIDEO_ID\n *  - https://gaming.youtube.com/watch?v=VIDEO_ID\n *\n * @param {string} link\n * @return {string}\n * @throws {Error} If unable to find a id\n * @throws {TypeError} If videoid doesn't match specs\n */\nvar validQueryDomains = new Set(['youtube.com', 'www.youtube.com', 'm.youtube.com', 'music.youtube.com', 'gaming.youtube.com']);\nvar validPathDomains = /^https?:\\/\\/(youtu\\.be\\/|(www\\.)?youtube\\.com\\/(embed|v|shorts)\\/)/;\n\nexports.getURLVideoID = function (link) {\n  var parsed = new URL(link);\n  var id = parsed.searchParams.get('v');\n\n  if (validPathDomains.test(link) && !id) {\n    var paths = parsed.pathname.split('/');\n    id = parsed.host === 'youtu.be' ? paths[1] : paths[2];\n  } else if (parsed.hostname && !validQueryDomains.has(parsed.hostname)) {\n    throw Error('Not a YouTube domain');\n  }\n\n  if (!id) {\n    throw Error(\"No video id found: \".concat(link));\n  }\n\n  id = id.substring(0, 11);\n\n  if (!exports.validateID(id)) {\n    throw TypeError(\"Video id (\".concat(id, \") does not match expected \") + \"format (\".concat(idRegex.toString(), \")\"));\n  }\n\n  return id;\n};\n/**\n * Gets video ID either from a url or by checking if the given string\n * matches the video ID format.\n *\n * @param {string} str\n * @returns {string}\n * @throws {Error} If unable to find a id\n * @throws {TypeError} If videoid doesn't match specs\n */\n\n\nvar urlRegex = /^https?:\\/\\//;\n\nexports.getVideoID = function (str) {\n  if (exports.validateID(str)) {\n    return str;\n  } else if (urlRegex.test(str)) {\n    return exports.getURLVideoID(str);\n  } else {\n    throw Error(\"No video id found: \".concat(str));\n  }\n};\n/**\n * Returns true if given id satifies YouTube's id format.\n *\n * @param {string} id\n * @return {boolean}\n */\n\n\nvar idRegex = /^[a-zA-Z0-9-_]{11}$/;\n\nexports.validateID = function (id) {\n  return idRegex.test(id);\n};\n/**\n * Checks wether the input string includes a valid id.\n *\n * @param {string} string\n * @returns {boolean}\n */\n\n\nexports.validateURL = function (string) {\n  try {\n    exports.getURLVideoID(string);\n    return true;\n  } catch (e) {\n    return false;\n  }\n};\n\n//# sourceURL=webpack://WorkBox/./node_modules/ytdl-core/lib/url-utils.js?");

/***/ }),

/***/ "./node_modules/ytdl-core/lib/utils.js":
/*!*********************************************!*\
  !*** ./node_modules/ytdl-core/lib/utils.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\n\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== \"undefined\" && arr[Symbol.iterator] || arr[\"@@iterator\"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nvar miniget = __webpack_require__(/*! miniget */ \"./node_modules/miniget/dist/index.js\");\n/**\n * Extract string inbetween another.\n *\n * @param {string} haystack\n * @param {string} left\n * @param {string} right\n * @returns {string}\n */\n\n\nexports.between = function (haystack, left, right) {\n  var pos;\n\n  if (left instanceof RegExp) {\n    var match = haystack.match(left);\n\n    if (!match) {\n      return '';\n    }\n\n    pos = match.index + match[0].length;\n  } else {\n    pos = haystack.indexOf(left);\n\n    if (pos === -1) {\n      return '';\n    }\n\n    pos += left.length;\n  }\n\n  haystack = haystack.slice(pos);\n  pos = haystack.indexOf(right);\n\n  if (pos === -1) {\n    return '';\n  }\n\n  haystack = haystack.slice(0, pos);\n  return haystack;\n};\n/**\n * Get a number from an abbreviated number string.\n *\n * @param {string} string\n * @returns {number}\n */\n\n\nexports.parseAbbreviatedNumber = function (string) {\n  var match = string.replace(',', '.').replace(' ', '').match(/([\\d,.]+)([MK]?)/);\n\n  if (match) {\n    var _match = _slicedToArray(match, 3),\n        num = _match[1],\n        multi = _match[2];\n\n    num = parseFloat(num);\n    return Math.round(multi === 'M' ? num * 1000000 : multi === 'K' ? num * 1000 : num);\n  }\n\n  return null;\n};\n/**\n * Match begin and end braces of input JSON, return only json\n *\n * @param {string} mixedJson\n * @returns {string}\n*/\n\n\nexports.cutAfterJSON = function (mixedJson) {\n  var open, close;\n\n  if (mixedJson[0] === '[') {\n    open = '[';\n    close = ']';\n  } else if (mixedJson[0] === '{') {\n    open = '{';\n    close = '}';\n  }\n\n  if (!open) {\n    throw new Error(\"Can't cut unsupported JSON (need to begin with [ or { ) but got: \".concat(mixedJson[0]));\n  } // States if the loop is currently in a string\n\n\n  var isString = false; // States if the current character is treated as escaped or not\n\n  var isEscaped = false; // Current open brackets to be closed\n\n  var counter = 0;\n  var i;\n\n  for (i = 0; i < mixedJson.length; i++) {\n    // Toggle the isString boolean when leaving/entering string\n    if (mixedJson[i] === '\"' && !isEscaped) {\n      isString = !isString;\n      continue;\n    } // Toggle the isEscaped boolean for every backslash\n    // Reset for every regular character\n\n\n    isEscaped = mixedJson[i] === '\\\\' && !isEscaped;\n    if (isString) continue;\n\n    if (mixedJson[i] === open) {\n      counter++;\n    } else if (mixedJson[i] === close) {\n      counter--;\n    } // All brackets have been closed, thus end of JSON is reached\n\n\n    if (counter === 0) {\n      // Return the cut JSON\n      return mixedJson.substr(0, i + 1);\n    }\n  } // We ran through the whole string and ended up with an unclosed bracket\n\n\n  throw Error(\"Can't cut unsupported JSON (no matching closing bracket found)\");\n};\n/**\n * Checks if there is a playability error.\n *\n * @param {Object} player_response\n * @param {Array.<string>} statuses\n * @param {Error} ErrorType\n * @returns {!Error}\n */\n\n\nexports.playError = function (player_response, statuses) {\n  var ErrorType = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : Error;\n  var playability = player_response && player_response.playabilityStatus;\n\n  if (playability && statuses.includes(playability.status)) {\n    return new ErrorType(playability.reason || playability.messages && playability.messages[0]);\n  }\n\n  return null;\n};\n/**\n * Does a miniget request and calls options.requestCallback if present\n *\n * @param {string} url the request url\n * @param {Object} options an object with optional requestOptions and requestCallback parameters\n * @param {Object} requestOptionsOverwrite overwrite of options.requestOptions\n * @returns {miniget.Stream}\n */\n\n\nexports.exposedMiniget = function (url) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var requestOptionsOverwrite = arguments.length > 2 ? arguments[2] : undefined;\n  var req = miniget(url, requestOptionsOverwrite || options.requestOptions);\n  if (typeof options.requestCallback === 'function') options.requestCallback(req);\n  return req;\n};\n/**\n * Temporary helper to help deprecating a few properties.\n *\n * @param {Object} obj\n * @param {string} prop\n * @param {Object} value\n * @param {string} oldPath\n * @param {string} newPath\n */\n\n\nexports.deprecate = function (obj, prop, value, oldPath, newPath) {\n  Object.defineProperty(obj, prop, {\n    get: function get() {\n      console.warn(\"`\".concat(oldPath, \"` will be removed in a near future release, \") + \"use `\".concat(newPath, \"` instead.\"));\n      return value;\n    }\n  });\n}; // Check for updates.\n\n\nvar pkg = __webpack_require__(/*! ../package.json */ \"./node_modules/ytdl-core/package.json\");\n\nvar UPDATE_INTERVAL = 1000 * 60 * 60 * 12;\nexports.lastUpdateCheck = 0;\n\nexports.checkForUpdates = function () {\n  if (!process.env.YTDL_NO_UPDATE && !pkg.version.startsWith('0.0.0-') && Date.now() - exports.lastUpdateCheck >= UPDATE_INTERVAL) {\n    exports.lastUpdateCheck = Date.now();\n    return miniget('https://api.github.com/repos/fent/node-ytdl-core/releases/latest', {\n      headers: {\n        'User-Agent': 'ytdl-core'\n      }\n    }).text().then(function (response) {\n      if (JSON.parse(response).tag_name !== \"v\".concat(pkg.version)) {\n        console.warn('\\x1b[33mWARNING:\\x1B[0m ytdl-core is out of date! Update with \"npm install ytdl-core@latest\".');\n      }\n    }, function (err) {\n      console.warn('Error checking for updates:', err.message);\n      console.warn('You can disable this check by setting the `YTDL_NO_UPDATE` env variable.');\n    });\n  }\n\n  return null;\n};\n\n//# sourceURL=webpack://WorkBox/./node_modules/ytdl-core/lib/utils.js?");

/***/ }),

/***/ "./src/client/js/main.js":
/*!*******************************!*\
  !*** ./src/client/js/main.js ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _scss_style_scss__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../scss/style.scss */ \"./src/client/scss/style.scss\");\n/* harmony import */ var _videoHandler__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./videoHandler */ \"./src/client/js/videoHandler.js\");\n/* harmony import */ var _videoHandler__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_videoHandler__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _streamMusic_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./streamMusic.js */ \"./src/client/js/streamMusic.js\");\n/* CSS */\n\n/* JS */\n\n\n\n\n//# sourceURL=webpack://WorkBox/./src/client/js/main.js?");

/***/ }),

/***/ "./src/client/js/streamMusic.js":
/*!**************************************!*\
  !*** ./src/client/js/streamMusic.js ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _ffmpeg_ffmpeg__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ffmpeg/ffmpeg */ \"./node_modules/@ffmpeg/ffmpeg/src/index.js\");\n/* harmony import */ var _ffmpeg_ffmpeg__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_ffmpeg_ffmpeg__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var ytdl_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ytdl-core */ \"./node_modules/ytdl-core/lib/index.js\");\n/* harmony import */ var ytdl_core__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(ytdl_core__WEBPACK_IMPORTED_MODULE_1__);\nObject(function webpackMissingModule() { var e = new Error(\"Cannot find module 'fs'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }());\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }\n\nfunction _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err); } _next(undefined); }); }; }\n\n\n\n\nconsole.log(\"FFMEG!\");\nvar videoData = ytdl_core__WEBPACK_IMPORTED_MODULE_1___default()(\"http://www.youtube.com/watch?v=aqz-KE-bpKQ\").pipe(Object(function webpackMissingModule() { var e = new Error(\"Cannot find module 'fs'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }())(\"video.mp4\"));\n\nvar handleDownload = /*#__PURE__*/function () {\n  var _ref = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(videoUrl) {\n    var ffmpeg;\n    return regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            ffmpeg = (0,_ffmpeg_ffmpeg__WEBPACK_IMPORTED_MODULE_0__.createFFmpeg)({\n              log: true\n            });\n            _context.next = 3;\n            return ffmpeg.load();\n\n          case 3:\n            _context.t0 = ffmpeg;\n            _context.next = 6;\n            return (0,_ffmpeg_ffmpeg__WEBPACK_IMPORTED_MODULE_0__.fetchFile)(videoUrl);\n\n          case 6:\n            _context.t1 = _context.sent;\n\n            _context.t0.FS.call(_context.t0, \"writeFile\", \"mp4name\", _context.t1);\n\n            _context.next = 10;\n            return ffmpeg.run(\"-i\", \"mp4name\", \"-r\", \"60\", \"ouput.mp4\");\n\n          case 10:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  }));\n\n  return function handleDownload(_x) {\n    return _ref.apply(this, arguments);\n  };\n}();\n\n//# sourceURL=webpack://WorkBox/./src/client/js/streamMusic.js?");

/***/ }),

/***/ "./src/client/js/videoHandler.js":
/*!***************************************!*\
  !*** ./src/client/js/videoHandler.js ***!
  \***************************************/
/***/ (() => {

eval("var video = document.querySelector(\"video\");\nvar videoController = document.getElementById(\"videoController\");\nvar psBtn = videoController.querySelector(\"#playPauseBtn\");\nvar volumeBtn = videoController.querySelector(\"#volume\");\nvar volumeRange = videoController.querySelector(\"#volumeRange\");\nvar videoTimeValue = document.querySelector(\".video-time\");\nvar timeLine = document.querySelector(\".timeLine\");\nvar videoBackgroundBox = document.querySelector(\".video-box\");\nvar volumeValue = 0.5;\nvideo.volume = volumeValue;\n\nvar handleVideoClickPause = function handleVideoClickPause() {\n  if (video.paused) {\n    video.play();\n    psBtn.className = \"fas fa-pause\";\n  } else {\n    video.pause();\n    psBtn.className = \"fas fa-play\";\n  }\n};\n\nvideoBackgroundBox.addEventListener(\"click\", handleVideoClickPause);\n\nvar handlePlayAndStop = function handlePlayAndStop() {\n  if (video.paused) {\n    video.play();\n    psBtn.className = \"fas fa-pause\";\n  } else {\n    video.pause();\n    psBtn.className = \"fas fa-play\";\n  }\n};\n\nvar handleSound = function handleSound() {\n  if (video.muted) {\n    video.muted = false;\n    volumeRange.value = volumeValue;\n    volumeBtn.className = \"fas fa-volume-up\";\n  } else {\n    video.muted = true;\n    volumeRange.value = 0;\n    volumeBtn.className = \"fas fa-volume-mute\";\n  }\n};\n\nvar handleVolume = function handleVolume(event) {\n  var value = event.target.value;\n\n  if (video.muted) {\n    video.muted = false;\n    volumeBtn.className = \"fas fa-volume-mute\";\n  }\n\n  if (value === \"0\") {\n    volumeBtn.className = \"fas fa-volume-off\";\n  } else {\n    volumeBtn.className = \"fas fa-volume-up\";\n  }\n\n  video.volume = volumeValue = value;\n};\n\nvar setVideoTime = function setVideoTime() {\n  var durationValue = Math.floor(Number(video.duration));\n  var currentTime = Math.floor(video.currentTime); //F'를 눌러 전체 화면 모드로 들어가기, Esc 키를 눌러 전체 화면 모드에서 나오기\n\n  videoTimeValue.innerHTML = \"0:\".concat(currentTime < 10 ? \"0\".concat(currentTime) : currentTime, \" / 0:\").concat(durationValue);\n  var parsedValue = currentTime / durationValue * 100;\n  timeLine.value = parsedValue;\n};\n\nvar keyInputHandler = function keyInputHandler(e) {\n  console.log(e.code);\n  var value = e.code;\n\n  if (value === \"Space\") {\n    handlePlayAndStop();\n  } else if (value === \"KeyF\") {\n    //it is working at VSC with Chrome!\n    video.requestFullscreen();\n  } else if (value === \"KeyM\") {\n    if (!video.muted) {\n      volumeBtn.className = \"fas fa-volume-mute\";\n      return video.muted = true;\n    } else {\n      volumeBtn.className = \"fas fa-volume-up\";\n      return video.muted = false;\n    }\n  } else if (value === \"Escape\") {\n    //it is working at VSC with Chrome!\n    video.exitFullscreen();\n  }\n};\n\nvar timeLineHandler = function timeLineHandler(e) {\n  var inputValue = e.target.value;\n  var parsedValue = video.duration * inputValue * 0.01;\n  video.currentTime = parsedValue;\n};\n\ntimeLine.addEventListener(\"input\", timeLineHandler);\n\nfunction init() {\n  setInterval(setVideoTime, 100);\n  psBtn.addEventListener(\"click\", handlePlayAndStop);\n  volumeBtn.addEventListener(\"click\", handleSound);\n  volumeRange.addEventListener(\"input\", handleVolume);\n  document.onkeyup = keyInputHandler;\n}\n\ninit();\n\n//# sourceURL=webpack://WorkBox/./src/client/js/videoHandler.js?");

/***/ }),

/***/ "./src/client/scss/style.scss":
/*!************************************!*\
  !*** ./src/client/scss/style.scss ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n// extracted by mini-css-extract-plugin\n\n\n//# sourceURL=webpack://WorkBox/./src/client/scss/style.scss?");

/***/ }),

/***/ "./node_modules/@ffmpeg/ffmpeg/package.json":
/*!**************************************************!*\
  !*** ./node_modules/@ffmpeg/ffmpeg/package.json ***!
  \**************************************************/
/***/ (() => {

eval("throw new Error(\"Module build failed (from ./node_modules/babel-loader/lib/index.js):\\nSyntaxError: C:\\\\Users\\\\Delta\\\\Documents\\\\GitHub\\\\WorkBox\\\\node_modules\\\\@ffmpeg\\\\ffmpeg\\\\package.json: Missing semicolon. (2:8)\\n\\n\\u001b[0m \\u001b[90m 1 |\\u001b[39m {\\u001b[0m\\n\\u001b[0m\\u001b[31m\\u001b[1m>\\u001b[22m\\u001b[39m\\u001b[90m 2 |\\u001b[39m   \\u001b[32m\\\"name\\\"\\u001b[39m\\u001b[33m:\\u001b[39m \\u001b[32m\\\"@ffmpeg/ffmpeg\\\"\\u001b[39m\\u001b[33m,\\u001b[39m\\u001b[0m\\n\\u001b[0m \\u001b[90m   |\\u001b[39m         \\u001b[31m\\u001b[1m^\\u001b[22m\\u001b[39m\\u001b[0m\\n\\u001b[0m \\u001b[90m 3 |\\u001b[39m   \\u001b[32m\\\"version\\\"\\u001b[39m\\u001b[33m:\\u001b[39m \\u001b[32m\\\"0.10.1\\\"\\u001b[39m\\u001b[33m,\\u001b[39m\\u001b[0m\\n\\u001b[0m \\u001b[90m 4 |\\u001b[39m   \\u001b[32m\\\"description\\\"\\u001b[39m\\u001b[33m:\\u001b[39m \\u001b[32m\\\"FFmpeg WebAssembly version\\\"\\u001b[39m\\u001b[33m,\\u001b[39m\\u001b[0m\\n\\u001b[0m \\u001b[90m 5 |\\u001b[39m   \\u001b[32m\\\"main\\\"\\u001b[39m\\u001b[33m:\\u001b[39m \\u001b[32m\\\"src/index.js\\\"\\u001b[39m\\u001b[33m,\\u001b[39m\\u001b[0m\\n    at Parser._raise (C:\\\\Users\\\\Delta\\\\Documents\\\\GitHub\\\\WorkBox\\\\node_modules\\\\@babel\\\\parser\\\\lib\\\\index.js:510:17)\\n    at Parser.raiseWithData (C:\\\\Users\\\\Delta\\\\Documents\\\\GitHub\\\\WorkBox\\\\node_modules\\\\@babel\\\\parser\\\\lib\\\\index.js:503:17)\\n    at Parser.raise (C:\\\\Users\\\\Delta\\\\Documents\\\\GitHub\\\\WorkBox\\\\node_modules\\\\@babel\\\\parser\\\\lib\\\\index.js:464:17)\\n    at Parser.semicolon (C:\\\\Users\\\\Delta\\\\Documents\\\\GitHub\\\\WorkBox\\\\node_modules\\\\@babel\\\\parser\\\\lib\\\\index.js:3338:10)\\n    at Parser.parseExpressionStatement (C:\\\\Users\\\\Delta\\\\Documents\\\\GitHub\\\\WorkBox\\\\node_modules\\\\@babel\\\\parser\\\\lib\\\\index.js:13478:10)\\n    at Parser.parseStatementContent (C:\\\\Users\\\\Delta\\\\Documents\\\\GitHub\\\\WorkBox\\\\node_modules\\\\@babel\\\\parser\\\\lib\\\\index.js:13069:19)\\n    at Parser.parseStatement (C:\\\\Users\\\\Delta\\\\Documents\\\\GitHub\\\\WorkBox\\\\node_modules\\\\@babel\\\\parser\\\\lib\\\\index.js:12931:17)\\n    at Parser.parseBlockOrModuleBlockBody (C:\\\\Users\\\\Delta\\\\Documents\\\\GitHub\\\\WorkBox\\\\node_modules\\\\@babel\\\\parser\\\\lib\\\\index.js:13520:25)\\n    at Parser.parseBlockBody (C:\\\\Users\\\\Delta\\\\Documents\\\\GitHub\\\\WorkBox\\\\node_modules\\\\@babel\\\\parser\\\\lib\\\\index.js:13511:10)\\n    at Parser.parseBlock (C:\\\\Users\\\\Delta\\\\Documents\\\\GitHub\\\\WorkBox\\\\node_modules\\\\@babel\\\\parser\\\\lib\\\\index.js:13495:10)\");\n\n//# sourceURL=webpack://WorkBox/./node_modules/@ffmpeg/ffmpeg/package.json?");

/***/ }),

/***/ "./node_modules/ytdl-core/package.json":
/*!*********************************************!*\
  !*** ./node_modules/ytdl-core/package.json ***!
  \*********************************************/
/***/ (() => {

eval("throw new Error(\"Module build failed (from ./node_modules/babel-loader/lib/index.js):\\nSyntaxError: C:\\\\Users\\\\Delta\\\\Documents\\\\GitHub\\\\WorkBox\\\\node_modules\\\\ytdl-core\\\\package.json: Missing semicolon. (2:8)\\n\\n\\u001b[0m \\u001b[90m 1 |\\u001b[39m {\\u001b[0m\\n\\u001b[0m\\u001b[31m\\u001b[1m>\\u001b[22m\\u001b[39m\\u001b[90m 2 |\\u001b[39m   \\u001b[32m\\\"name\\\"\\u001b[39m\\u001b[33m:\\u001b[39m \\u001b[32m\\\"ytdl-core\\\"\\u001b[39m\\u001b[33m,\\u001b[39m\\u001b[0m\\n\\u001b[0m \\u001b[90m   |\\u001b[39m         \\u001b[31m\\u001b[1m^\\u001b[22m\\u001b[39m\\u001b[0m\\n\\u001b[0m \\u001b[90m 3 |\\u001b[39m   \\u001b[32m\\\"description\\\"\\u001b[39m\\u001b[33m:\\u001b[39m \\u001b[32m\\\"YouTube video downloader in pure javascript.\\\"\\u001b[39m\\u001b[33m,\\u001b[39m\\u001b[0m\\n\\u001b[0m \\u001b[90m 4 |\\u001b[39m   \\u001b[32m\\\"keywords\\\"\\u001b[39m\\u001b[33m:\\u001b[39m [\\u001b[0m\\n\\u001b[0m \\u001b[90m 5 |\\u001b[39m     \\u001b[32m\\\"youtube\\\"\\u001b[39m\\u001b[33m,\\u001b[39m\\u001b[0m\\n    at Parser._raise (C:\\\\Users\\\\Delta\\\\Documents\\\\GitHub\\\\WorkBox\\\\node_modules\\\\@babel\\\\parser\\\\lib\\\\index.js:510:17)\\n    at Parser.raiseWithData (C:\\\\Users\\\\Delta\\\\Documents\\\\GitHub\\\\WorkBox\\\\node_modules\\\\@babel\\\\parser\\\\lib\\\\index.js:503:17)\\n    at Parser.raise (C:\\\\Users\\\\Delta\\\\Documents\\\\GitHub\\\\WorkBox\\\\node_modules\\\\@babel\\\\parser\\\\lib\\\\index.js:464:17)\\n    at Parser.semicolon (C:\\\\Users\\\\Delta\\\\Documents\\\\GitHub\\\\WorkBox\\\\node_modules\\\\@babel\\\\parser\\\\lib\\\\index.js:3338:10)\\n    at Parser.parseExpressionStatement (C:\\\\Users\\\\Delta\\\\Documents\\\\GitHub\\\\WorkBox\\\\node_modules\\\\@babel\\\\parser\\\\lib\\\\index.js:13478:10)\\n    at Parser.parseStatementContent (C:\\\\Users\\\\Delta\\\\Documents\\\\GitHub\\\\WorkBox\\\\node_modules\\\\@babel\\\\parser\\\\lib\\\\index.js:13069:19)\\n    at Parser.parseStatement (C:\\\\Users\\\\Delta\\\\Documents\\\\GitHub\\\\WorkBox\\\\node_modules\\\\@babel\\\\parser\\\\lib\\\\index.js:12931:17)\\n    at Parser.parseBlockOrModuleBlockBody (C:\\\\Users\\\\Delta\\\\Documents\\\\GitHub\\\\WorkBox\\\\node_modules\\\\@babel\\\\parser\\\\lib\\\\index.js:13520:25)\\n    at Parser.parseBlockBody (C:\\\\Users\\\\Delta\\\\Documents\\\\GitHub\\\\WorkBox\\\\node_modules\\\\@babel\\\\parser\\\\lib\\\\index.js:13511:10)\\n    at Parser.parseBlock (C:\\\\Users\\\\Delta\\\\Documents\\\\GitHub\\\\WorkBox\\\\node_modules\\\\@babel\\\\parser\\\\lib\\\\index.js:13495:10)\");\n\n//# sourceURL=webpack://WorkBox/./node_modules/ytdl-core/package.json?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			id: moduleId,
/******/ 			loaded: false,
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/node module decorator */
/******/ 	(() => {
/******/ 		__webpack_require__.nmd = (module) => {
/******/ 			module.paths = [];
/******/ 			if (!module.children) module.children = [];
/******/ 			return module;
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/client/js/main.js");
/******/ 	
/******/ })()
;